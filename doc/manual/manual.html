<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Nix User's Guide</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Nix User's Guide"><div class="titlepage"><div><div><h1 class="title"><a name="id274838"></a>Nix User's Guide</h1></div><div><h2 class="subtitle">Draft (Version 0.16)</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Eelco</span> <span class="surname">Dolstra</span></h3><div class="affiliation"><span class="orgname">Delft University of Technology<br></span> <span class="orgdiv">Department of Software Technology<br></span></div></div></div><div><p class="copyright">Copyright © 2004, 2005, 2006, 2007, 2008, 2009, 2010 Eelco Dolstra</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#chap-introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#id481178">1.1. About Nix</a></span></dt><dt><span class="section"><a href="#id481879">1.2. About us</a></span></dt><dt><span class="section"><a href="#id481909">1.3. About this manual</a></span></dt><dt><span class="section"><a href="#id481920">1.4. License</a></span></dt><dt><span class="section"><a href="#id481946">1.5. More information</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-quick-start">2. Quick Start</a></span></dt><dt><span class="chapter"><a href="#chap-installation">3. Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#id481447">3.1. Supported platforms</a></span></dt><dt><span class="section"><a href="#id481554">3.2. Obtaining Nix</a></span></dt><dt><span class="section"><a href="#id481598">3.3. Prerequisites</a></span></dt><dt><span class="section"><a href="#id482067">3.4. Building Nix from source</a></span></dt><dt><span class="section"><a href="#id482173">3.5. Installing a binary distribution</a></span></dt><dt><span class="section"><a href="#id483117">3.6. Security</a></span></dt><dd><dl><dt><span class="section"><a href="#id483141">3.6.1. Single-user mode</a></span></dt><dt><span class="section"><a href="#ssec-multi-user">3.6.2. Multi-user mode</a></span></dt><dd><dl><dt><span class="section"><a href="#id483248">3.6.2.1. Setting up the build users</a></span></dt><dt><span class="section"><a href="#id483340">3.6.2.2. Nix store/database owned by root</a></span></dt><dt><span class="section"><a href="#id483397">3.6.2.3. Nix store/database not owned by root</a></span></dt><dt><span class="section"><a href="#id483502">3.6.2.4. Restricting access</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#id483542">3.7. Using Nix</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-package-management">4. Package Management</a></span></dt><dd><dl><dt><span class="section"><a href="#id482507">4.1. Basic package management</a></span></dt><dt><span class="section"><a href="#sec-profiles">4.2. Profiles</a></span></dt><dt><span class="section"><a href="#sec-garbage-collection">4.3. Garbage collection</a></span></dt><dd><dl><dt><span class="section"><a href="#ssec-gc-roots">4.3.1. Garbage collector roots</a></span></dt></dl></dd><dt><span class="section"><a href="#sec-channels">4.4. Channels</a></span></dt><dt><span class="section"><a href="#sec-one-click">4.5. One-click installs</a></span></dt><dt><span class="section"><a href="#sec-sharing-packages">4.6. Sharing packages between machines</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-writing-nix-expressions">5. Writing Nix Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#id489273">5.1. A simple Nix expression</a></span></dt><dd><dl><dt><span class="section"><a href="#id489196">5.1.1. The Nix expression</a></span></dt><dt><span class="section"><a href="#id488873">5.1.2. The builder</a></span></dt><dt><span class="section"><a href="#id488656">5.1.3. Composition</a></span></dt><dt><span class="section"><a href="#id488499">5.1.4. Testing</a></span></dt><dt><span class="section"><a href="#id488378">5.1.5. The generic builder</a></span></dt></dl></dd><dt><span class="section"><a href="#id488220">5.2. The Nix expression language</a></span></dt><dd><dl><dt><span class="section"><a href="#ssec-values">5.2.1. Values</a></span></dt><dt><span class="section"><a href="#id487820">5.2.2. Language constructs</a></span></dt><dt><span class="section"><a href="#id491116">5.2.3. Operators</a></span></dt><dt><span class="section"><a href="#ssec-derivation">5.2.4. Derivations</a></span></dt><dd><dl><dt><span class="section"><a href="#id491813">5.2.4.1. Advanced attributes</a></span></dt></dl></dd><dt><span class="section"><a href="#ssec-builtins">5.2.5. Built-in functions</a></span></dt></dl></dd><dt><span class="section"><a href="#sec-standard-environment">5.3. The standard environment</a></span></dt><dd><dl><dt><span class="section"><a href="#id493997">5.3.1. Customising the generic builder</a></span></dt><dt><span class="section"><a href="#id494024">5.3.2. Debugging failed builds</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap-build-farm">6. Setting up a Build Farm</a></span></dt><dd><dl><dt><span class="section"><a href="#id483072">6.1. Overview</a></span></dt><dt><span class="section"><a href="#sec-distributed-builds">6.2. Setting up distributed builds</a></span></dt></dl></dd><dt><span class="appendix"><a href="#id481062">A. Command Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#sec-common-options">A.1. Common options</a></span></dt><dt><span class="section"><a href="#sec-common-env">A.2. Common environment variables</a></span></dt><dt><span class="section"><a href="#sec-conf-file">A.3. Nix configuration file</a></span></dt><dt><span class="section"><a href="#id481080">A.4. Main commands</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#sec-nix-env">nix-env</a></span><span class="refpurpose"> &#8212; manipulate or query Nix user environments</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-instantiate">nix-instantiate</a></span><span class="refpurpose"> &#8212; instantiate store derivations from Nix expressions</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-store">nix-store</a></span><span class="refpurpose"> &#8212; manipulate or query the Nix store</span></dt></dl></dd><dt><span class="section"><a href="#id481099">A.5. Utilities</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#sec-nix-build">nix-build</a></span><span class="refpurpose"> &#8212; build a Nix expression</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-channel">nix-channel</a></span><span class="refpurpose"> &#8212; manage Nix channels</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-collect-garbage">nix-collect-garbage</a></span><span class="refpurpose"> &#8212; delete unreachable store paths</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-copy-closure">nix-copy-closure</a></span><span class="refpurpose"> &#8212; copy a closure to or from a remote machine via SSH</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-hash">nix-hash</a></span><span class="refpurpose"> &#8212; compute the cryptographic hash of a path</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-install-package">nix-install-package</a></span><span class="refpurpose"> &#8212; install a Nix Package file</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-prefetch-url">nix-prefetch-url</a></span><span class="refpurpose"> &#8212; copy a file from a URL into the store and print its MD5 hash</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-pull">nix-pull</a></span><span class="refpurpose"> &#8212; pull substitutes from a network cache</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-push">nix-push</a></span><span class="refpurpose"> &#8212; push store paths onto a network cache</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-worker">nix-worker</a></span><span class="refpurpose"> &#8212; Nix multi-user support daemon</span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#id480632">B. Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#id499788">B.1. Collisions in <span class="command"><strong>nix-env</strong></span></a></span></dt><dt><span class="section"><a href="#id499847">B.2. <span class="quote">&#8220;<span class="quote">Too many links</span>&#8221;</span> error in the Nix
store</a></span></dt></dl></dd><dt><span class="appendix"><a href="#id490343">C. Glossary</a></span></dt><dt><span class="appendix"><a href="#id481161">D. Nix Release Notes</a></span></dt><dd><dl><dt><span class="section"><a href="#ssec-relnotes-0.16">D.1. Release 0.16 (August 17, 2010)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.15">D.2. Release 0.15 (March 17, 2010)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.14">D.3. Release 0.14 (February 4, 2010)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.13">D.4. Release 0.13 (November 5,
2009)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.12">D.5. Release 0.12 (November 20,
2008)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.11">D.6. Release 0.11 (December 31,
2007)</a></span></dt><dt><span class="section"><a href="#id504154">D.7. Release 0.10.1 (October 11, 2006)</a></span></dt><dt><span class="section"><a href="#id504169">D.8. Release 0.10 (October 6, 2006)</a></span></dt><dt><span class="section"><a href="#id504804">D.9. Release 0.9.2 (September 21, 2005)</a></span></dt><dt><span class="section"><a href="#id504844">D.10. Release 0.9.1 (September 20, 2005)</a></span></dt><dt><span class="section"><a href="#id504865">D.11. Release 0.9 (September 16, 2005)</a></span></dt><dt><span class="section"><a href="#id505019">D.12. Release 0.8.1 (April 13, 2005)</a></span></dt><dt><span class="section"><a href="#id505043">D.13. Release 0.8 (April 11, 2005)</a></span></dt><dt><span class="section"><a href="#id505427">D.14. Release 0.7 (January 12, 2005)</a></span></dt><dt><span class="section"><a href="#id505470">D.15. Release 0.6 (November 14, 2004)</a></span></dt><dt><span class="section"><a href="#id505679">D.16. Release 0.5 and earlier</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>4.1. <a href="#fig-user-environments">User environments</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>5.1. <a href="#table-operators">Operators</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>5.1. <a href="#ex-hello-nix">Nix expression for GNU Hello
(<code class="filename">default.nix</code>)</a></dt><dt>5.2. <a href="#ex-hello-builder">Build script for GNU Hello
(<code class="filename">builder.sh</code>)</a></dt><dt>5.3. <a href="#ex-hello-composition">Composing GNU Hello
(<code class="filename">all-packages.nix</code>)</a></dt><dt>5.4. <a href="#ex-hello-builder2">Build script using the generic
build functions</a></dt><dt>5.5. <a href="#ex-subversion-nix">Nix expression for Subversion</a></dt><dt>5.6. <a href="#ex-toxml">Passing information to a builder
    using <code class="function">toXML</code></a></dt><dt>5.7. <a href="#ex-toxml-result">XML representation produced by
    <code class="function">toXML</code></a></dt><dt>6.1. <a href="#ex-remote-systems">Remote machine configuration:
<code class="filename">remote-systems.conf</code></a></dt><dt>A.1. <a href="#ex-nix-conf">Nix configuration file</a></dt></dl></div><div class="chapter" title="Chapter 1. Introduction"><div class="titlepage"><div><div><h2 class="title"><a name="chap-introduction"></a>Chapter 1. Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id481178">1.1. About Nix</a></span></dt><dt><span class="section"><a href="#id481879">1.2. About us</a></span></dt><dt><span class="section"><a href="#id481909">1.3. About this manual</a></span></dt><dt><span class="section"><a href="#id481920">1.4. License</a></span></dt><dt><span class="section"><a href="#id481946">1.5. More information</a></span></dt></dl></div><div class="section" title="1.1. About Nix"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481178"></a>1.1. About Nix</h2></div></div></div><p>Nix is a <span class="emphasis"><em>purely functional package manager</em></span>.
This means that it treats packages like values in purely functional
programming languages such as Haskell &#8212; they are built by functions
that don&#8217;t have side-effects, and they never change after they have
been built.  Nix stores packages in the <span class="emphasis"><em>Nix
store</em></span>, usually the directory
<code class="filename">/nix/store</code>, where each package has its own unique
subdirectory such as

</p><pre class="programlisting">
/nix/store/r8vvq9kq18pz08v249h8my6r9vs7s0n3-firefox-2.0.0.1/
</pre><p>

where <code class="literal">r8vvq9kq&#8230;</code> is a unique identifier for the
package that captures all its dependencies (it&#8217;s a cryptographic hash
of the package&#8217;s build dependency graph).  This enables many powerful
features.</p><div class="simplesect" title="Multiple versions"><div class="titlepage"><div><div><h3 class="title"><a name="id481209"></a>Multiple versions</h3></div></div></div><p>You can have multiple versions or variants of a package
installed at the same time.  This is especially important when
different applications have dependencies on different versions of the
same package &#8212; it prevents the &#8220;DLL hell&#8221;.  Because of the hashing
scheme, different versions of a package end up in different paths in
the Nix store, so they don&#8217;t interfere with each other.</p><p>An important consequence is that operations like upgrading or
uninstalling an application cannot break other applications, since
these operations never &#8220;destructively&#8221; update or delete files that are
used by other packages.</p></div><div class="simplesect" title="Complete dependencies"><div class="titlepage"><div><div><h3 class="title"><a name="id481228"></a>Complete dependencies</h3></div></div></div><p>Nix helps you make sure that package dependency specifications
are complete.  In general, when you&#8217;re making a package for a package
management system like RPM, you have to specify for each package what
its dependencies are, but there are no guarantees that this
specification is complete.  If you forget a dependency, then the
package will build and work correctly on <span class="emphasis"><em>your</em></span>
machine if you have the dependency installed, but not on the end
user's machine if it's not there.</p><p>Since Nix on the other hand doesn&#8217;t install packages in &#8220;global&#8221;
locations like <code class="filename">/usr/bin</code> but in package-specific
directories, the risk of incomplete dependencies is greatly reduced.
This is because tools such as compilers don&#8217;t search in per-packages
directories such as
<code class="filename">/nix/store/5lbfaxb722zp&#8230;-openssl-0.9.8d/include</code>,
so if a package builds correctly on your system, this is because you
specified the dependency explicitly.</p><p>Runtime dependencies are found by scanning binaries for the hash
parts of Nix store paths (such as <code class="literal">r8vvq9kq&#8230;</code>).  This
sounds risky, but it works extremely well.</p></div><div class="simplesect" title="Multi-user support"><div class="titlepage"><div><div><h3 class="title"><a name="id480812"></a>Multi-user support</h3></div></div></div><p>Starting at version 0.11, Nix has multi-user support.  This
means that non-privileged users can securely install software.  Each
user can have a different <span class="emphasis"><em>profile</em></span>, a set of
packages in the Nix store that appear in the user&#8217;s
<code class="envar">PATH</code>.  If a user installs a package that another user
has already installed previously, the package won&#8217;t be built or
downloaded a second time.  At the same time, it is not possible for
one user to inject a Trojan horse into a package that might be used by
another user.</p></div><div class="simplesect" title="Atomic upgrades and rollbacks"><div class="titlepage"><div><div><h3 class="title"><a name="id480836"></a>Atomic upgrades and rollbacks</h3></div></div></div><p>Since package management operations never overwrite packages in
the Nix store but just add new versions in different paths, they are
<span class="emphasis"><em>atomic</em></span>.  So during a package upgrade, there is no
time window in which the package has some files from the old version
and some files from the new version &#8212; which would be bad because a
program might well crash if it&#8217;s started during that period.</p><p>And since package aren&#8217;t overwritten, the old versions are still
there after an upgrade.  This means that you can <span class="emphasis"><em>roll
back</em></span> to the old version:</p><pre class="screen">
$ nix-env --upgrade <em class="replaceable"><code>some-packages</code></em>
$ nix-env --rollback
</pre></div><div class="simplesect" title="Garbage collection"><div class="titlepage"><div><div><h3 class="title"><a name="id480869"></a>Garbage collection</h3></div></div></div><p>When you install a package like this&#8230;

</p><pre class="screen">
$ nix-env --uninstall firefox
</pre><p>

the package isn&#8217;t deleted from the system right away (after all, you
might want to do a rollback, or it might be in the profiles of other
users).  Instead, unused packages can be deleted safely by running the
<span class="emphasis"><em>garbage collector</em></span>:

</p><pre class="screen">
$ nix-collect-garbage
</pre><p>

This deletes all packages that aren&#8217;t in use by any user profile or by
a currently running program.</p></div><div class="simplesect" title="Functional package language"><div class="titlepage"><div><div><h3 class="title"><a name="id480892"></a>Functional package language</h3></div></div></div><p>Packages are built from <span class="emphasis"><em>Nix expressions</em></span>,
which is a simple functional language.  A Nix expression describes
everything that goes into a package build action (a &#8220;derivation&#8221;):
other packages, sources, the build script, environment variables for
the build script, etc.  Nix tries very hard to ensure that Nix
expressions are <span class="emphasis"><em>deterministic</em></span>: building a Nix
expression twice should yield the same result.</p><p>Because it&#8217;s a functional language, it&#8217;s easy to support
building variants of a package: turn the Nix expression into a
function and call it any number of times with the appropriate
arguments.  Due to the hashing scheme, variants don&#8217;t conflict with
each other in the Nix store.</p></div><div class="simplesect" title="Transparent source/binary deployment"><div class="titlepage"><div><div><h3 class="title"><a name="id480919"></a>Transparent source/binary deployment</h3></div></div></div><p>Nix expressions generally describe how to build a package from
source, so an installation action like

</p><pre class="screen">
$ nix-env --install firefox
</pre><p>

<span class="emphasis"><em>could</em></span> cause quite a bit of build activity, as not
only Firefox but also all its dependencies (all the way up to the C
library and the compiler) would have to built, at least if they are
not already in the Nix store.  This is a <span class="emphasis"><em>source deployment
model</em></span>.  For most users, building from source is not very
pleasant as it takes far too long.  However, Nix can automatically
skip building from source and download a pre-built binary instead if
it knows about it.  <span class="emphasis"><em>Nix channels</em></span> provide Nix
expressions along with pre-built binaries.</p></div><div class="simplesect" title="Binary patching"><div class="titlepage"><div><div><h3 class="title"><a name="id480952"></a>Binary patching</h3></div></div></div><p>In addition to downloading binaries automatically if they&#8217;re
available, Nix can download binary deltas that patch an existing
package in the Nix store into a new version.  This speeds up
upgrades.</p></div><div class="simplesect" title="Nix Packages collection"><div class="titlepage"><div><div><h3 class="title"><a name="id481803"></a>Nix Packages collection</h3></div></div></div><p>We provide a large set of Nix expressions containing hundreds of
existing Unix packages, the <span class="emphasis"><em>Nix Packages
collection</em></span> (Nixpkgs).</p></div><div class="simplesect" title="Service deployment"><div class="titlepage"><div><div><h3 class="title"><a name="id481818"></a>Service deployment</h3></div></div></div><p>Nix can be used not only for rolling out packages, but also
complete <span class="emphasis"><em>configurations</em></span> of services.  This is
done by treating all the static bits of a service (such as software
packages, configuration files, control scripts, static web pages,
etc.) as &#8220;packages&#8221; that can be built by Nix expressions.  As a
result, all the features above apply to services as well: for
instance, you can roll back a web server configuration if a
configuration change turns out to be undesirable, you can easily have
multiple instances of a service (e.g., a test and production server),
and because the whole service is built in a purely functional way from
a Nix expression, it is repeatable so you can easily reproduce the
service on another machine.</p></div><div class="simplesect" title="Portability"><div class="titlepage"><div><div><h3 class="title"><a name="id481840"></a>Portability</h3></div></div></div><p>Nix should run on most Unix systems, including Linux, FreeBSD and
Mac OS X.  It is also supported on Windows using Cygwin.</p></div><div class="simplesect" title="NixOS"><div class="titlepage"><div><div><h3 class="title"><a name="id481851"></a>NixOS</h3></div></div></div><p>NixOS is a Linux distribution based on Nix.  It uses Nix not
just for package management but also to manage the system
configuration (e.g., to build configuration files in
<code class="filename">/etc</code>).  This means, among other things, that it&#8217;s
possible to easily roll back the entire configuration of the system to
an earlier state.  Also, users can install software without root
privileges.  For more information and downloads, see the <a class="link" href="http://nixos.org/" target="_top">NixOS homepage</a>.</p></div></div><div class="section" title="1.2. About us"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481879"></a>1.2. About us</h2></div></div></div><p>Nix was originally developed at the <a class="link" href="http://www.cs.uu.nl/" target="_top">Department of Information and
Computing Sciences</a>, Utrecht University by the <a class="link" href="http://www.cs.uu.nl/wiki/Trace/WebHome" target="_top">TraCE
project</a> (2003-2008).  The project was funded by the Software
Engineering Research Program <a class="link" href="http://www.jacquard.nl/" target="_top">Jacquard</a> to improve the
support for variability in software systems.  Further funding is now
provided by the NIRICT LaQuSo Build Farm project.</p></div><div class="section" title="1.3. About this manual"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481909"></a>1.3. About this manual</h2></div></div></div><p>This manual tells you how to install and use Nix and how to
write Nix expressions for software not already in the Nix Packages
collection.  It also discusses some advanced topics, such as setting
up a Nix-based build farm.</p></div><div class="section" title="1.4. License"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481920"></a>1.4. License</h2></div></div></div><p>Nix is free software; you can redistribute it and/or modify it
under the terms of the <a class="link" href="http://www.gnu.org/licenses/lgpl.html" target="_top">GNU Lesser General
Public License</a> as published by the <a class="link" href="http://www.fsf.org/" target="_top">Free Software Foundation</a>;
either version 2.1 of the License, or (at your option) any later
version.  Nix is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p></div><div class="section" title="1.5. More information"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481946"></a>1.5. More information</h2></div></div></div><p>Some background information on Nix can be found in a number of
papers.  The ICSE 2004 paper <em class="citetitle"><a class="citetitle" href="http://www.st.ewi.tudelft.nl/~dolstra/pubs/immdsd-icse2004-final.pdf" target="_top">Imposing
a Memory Management Discipline on Software Deployment</a></em>
discusses the hashing mechanism used to ensure reliable dependency
identification and non-interference between different versions and
variants of packages.  The LISA 2004 paper <em class="citetitle"><a class="citetitle" href="http://www.st.ewi.tudelft.nl/~dolstra/pubs/nspfssd-lisa2004-final.pdf" target="_top">Nix:
A Safe and Policy-Free System for Software Deployment</a></em>
gives a more general discussion of Nix from a system-administration
perspective.  The CBSE 2005 paper <em class="citetitle"><a class="citetitle" href="http://www.st.ewi.tudelft.nl/~dolstra/pubs/eupfcdm-cbse2005-final.pdf" target="_top">Efficient
Upgrading in a Purely Functional Component Deployment Model
</a></em> is about transparent patch deployment in Nix.  The SCM-12
paper <em class="citetitle"><a class="citetitle" href="http://www.st.ewi.tudelft.nl/~dolstra/pubs/servicecm-scm12-final.pdf" target="_top">
Service Configuration Management</a></em> shows how services (e.g.,
web servers) can be deployed and managed through Nix.  A short
overview of NixOS is given in the HotOS XI paper <em class="citetitle"><a class="citetitle" href="http://www.st.ewi.tudelft.nl/~dolstra/pubs/hotos-final.pdf" target="_top">Purely
Functional System Configuration Management</a></em>.  The Nix
homepage has <a class="link" href="http://nixos.org/docs/papers.html" target="_top">an up-to-date list
of Nix-related papers</a>.</p><p>Nix is the subject of Eelco Dolstra&#8217;s PhD thesis <em class="citetitle"><a class="citetitle" href="http://igitur-archive.library.uu.nl/dissertations/2006-0118-200031/index.htm" target="_top">The
Purely Functional Software Deployment Model</a></em>, which
contains most of the papers listed above.</p><p>Nix has a homepage at <a class="link" href="http://nixos.org/" target="_top">http://nixos.org/</a>.</p></div></div><div class="chapter" title="Chapter 2. Quick Start"><div class="titlepage"><div><div><h2 class="title"><a name="chap-quick-start"></a>Chapter 2. Quick Start</h2></div></div></div><p>This chapter is for impatient people who don't like reading
documentation.  For more in-depth information you are kindly referred
to the following chapters.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Download a source tarball, RPM or Deb from <a class="link" href="http://nixos.org/" target="_top">http://nixos.org/</a>.  Build source distributions using
the regular sequence:
        
</p><pre class="screen">
$ tar xvfj nix-<em class="replaceable"><code>version</code></em>.tar.bz2
$ ./configure
$ make
$ make install <em class="lineannotation"><span class="lineannotation">(as root)</span></em></pre><p>

This will install the Nix binaries in <code class="filename">/usr/local</code>
and keep the Nix store and other state in <code class="filename">/nix</code>.
You can change the former by specifying
<code class="option">--prefix=<em class="replaceable"><code>path</code></em></code>.  The
location of the store can be changed using
<code class="option">--with-store-dir=<em class="replaceable"><code>path</code></em></code>.
However, you shouldn't change the store location, if at all possible,
since that will make it impossible to use pre-built binaries from the
Nixpkgs channel and other channels.  The location of the state can be
changed using
<code class="option">--localstatedir=<em class="replaceable"><code>path</code></em>.</code></p></li><li class="listitem"><p>You should add
<code class="filename"><em class="replaceable"><code>prefix</code></em>/etc/profile.d/nix.sh</code>
to your <code class="filename">~/.bashrc</code> (or some other login
file).</p></li><li class="listitem"><p>Subscribe to the Nix Packages channel.

</p><pre class="screen">
$ nix-channel --add \
    http://nixos.org/releases/nixpkgs/channels/nixpkgs-unstable</pre><p>

</p></li><li class="listitem"><p>Download the latest Nix expressions available in the channel.
</p><pre class="screen">
$ nix-channel --update</pre><p>

Note that this in itself doesn't download any packages, it just
downloads the Nix expressions that build them and stores them
somewhere (under <code class="filename">~/.nix-defexpr</code>, in case you're
curious).  Also, it registers the fact that pre-built binaries are
available remotely.</p></li><li class="listitem"><p>See what installable packages are currently available
in the channel:

</p><pre class="screen">
$ nix-env -qa &#8217;*&#8217; <em class="lineannotation"><span class="lineannotation">(mind the quotes!)</span></em>
docbook-xml-4.2
firefox-1.0pre-PR-0.10.1
hello-2.1.1
libxslt-1.1.0
<em class="replaceable"><code>...</code></em></pre><p>

</p></li><li class="listitem"><p>Install some packages from the channel:
        
</p><pre class="screen">
$ nix-env -i hello firefox <em class="replaceable"><code>...</code></em> </pre><p>

This should download pre-built packages; it should not build them
locally (if it does, something went wrong).</p></li><li class="listitem"><p>Test that they work:

</p><pre class="screen">
$ which hello
/home/eelco/.nix-profile/bin/hello
$ hello
Hello, world!
$ firefox
<em class="lineannotation"><span class="lineannotation">(read Slashdot or something)</span></em></pre><p>

</p></li><li class="listitem"><p>Uninstall a package:

</p><pre class="screen">
$ nix-env -e hello</pre><p>

</p></li><li class="listitem"><p>To keep up-to-date with the channel, do:

</p><pre class="screen">
$ nix-channel --update
$ nix-env -u '*'</pre><p>

The latter command will upgrade each installed package for which there
is a &#8220;newer&#8221; version (as determined by comparing the version
numbers).</p></li><li class="listitem"><p>You can also install specific packages directly from
your web browser.  For instance, you can go to <a class="link" href="http://hydra.nixos.org/jobset/nixpkgs/trunk/channel/latest" target="_top">http://hydra.nixos.org/jobset/nixpkgs/trunk/channel/latest</a>
and click on any link for the individual packages for your platform.
Associate <code class="literal">application/nix-package</code> with the program
<code class="filename">/nix/bin/nix-install-package</code>.  A window should
appear asking you whether it&#8217;s okay to install the package.  Say
<code class="literal">Y</code>.  The package and all its dependencies will be
installed.</p></li><li class="listitem"><p>If you're unhappy with the result of a
<span class="command"><strong>nix-env</strong></span> action (e.g., an upgraded package turned
out not to work properly), you can go back:

</p><pre class="screen">
$ nix-env --rollback</pre><p>

</p></li><li class="listitem"><p>You should periodically run the Nix garbage collector
to get rid of unused packages, since uninstalls or upgrades don't
actually delete them:

</p><pre class="screen">
$ nix-collect-garbage -d</pre><p>



</p></li></ol></div></div><div class="chapter" title="Chapter 3. Installation"><div class="titlepage"><div><div><h2 class="title"><a name="chap-installation"></a>Chapter 3. Installation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id481447">3.1. Supported platforms</a></span></dt><dt><span class="section"><a href="#id481554">3.2. Obtaining Nix</a></span></dt><dt><span class="section"><a href="#id481598">3.3. Prerequisites</a></span></dt><dt><span class="section"><a href="#id482067">3.4. Building Nix from source</a></span></dt><dt><span class="section"><a href="#id482173">3.5. Installing a binary distribution</a></span></dt><dt><span class="section"><a href="#id483117">3.6. Security</a></span></dt><dd><dl><dt><span class="section"><a href="#id483141">3.6.1. Single-user mode</a></span></dt><dt><span class="section"><a href="#ssec-multi-user">3.6.2. Multi-user mode</a></span></dt><dd><dl><dt><span class="section"><a href="#id483248">3.6.2.1. Setting up the build users</a></span></dt><dt><span class="section"><a href="#id483340">3.6.2.2. Nix store/database owned by root</a></span></dt><dt><span class="section"><a href="#id483397">3.6.2.3. Nix store/database not owned by root</a></span></dt><dt><span class="section"><a href="#id483502">3.6.2.4. Restricting access</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#id483542">3.7. Using Nix</a></span></dt></dl></div><div class="section" title="3.1. Supported platforms"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481447"></a>3.1. Supported platforms</h2></div></div></div><p>Nix is currently supported on the following platforms:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Linux (particularly on x86, x86_64, and
  PowerPC).</p></li><li class="listitem"><p>Mac OS X, both on Intel and
  PowerPC.</p></li><li class="listitem"><p>FreeBSD (only tested on Intel).</p></li><li class="listitem"><p>Windows through <a class="link" href="http://www.cygwin.com/" target="_top">Cygwin</a>.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>On Cygwin, Nix <span class="emphasis"><em>must</em></span> be installed
  on an NTFS partition.  It will not work correctly on a FAT
  partition.</p></div></li></ul></div><p>

</p><p>Nix is pretty portable, so it should work on most other Unix
platforms as well.</p></div><div class="section" title="3.2. Obtaining Nix"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481554"></a>3.2. Obtaining Nix</h2></div></div></div><p>The easiest way to obtain Nix is to download a <a class="link" href="http://nixos.org/" target="_top">source distribution</a>.  RPMs
for Red Hat, SuSE, and Fedora Core are also available.</p><p>Alternatively, the most recent sources of Nix can be obtained
from its <a class="link" href="https://svn.nixos.org/repos/nix/nix/trunk" target="_top">Subversion
repository</a>.  For example, the following command will check out
the latest revision into a directory called
<code class="filename">nix</code>:</p><pre class="screen">
$ svn checkout https://svn.nixos.org/repos/nix/nix/trunk nix</pre><p>Likewise, specific releases can be obtained from the <a class="link" href="https://svn.nixos.org/repos/nix/nix/tags" target="_top">tags
directory</a> of the repository.</p></div><div class="section" title="3.3. Prerequisites"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481598"></a>3.3. Prerequisites</h2></div></div></div><p><span class="emphasis"><em>The following prerequisites only apply when you build
from source</em></span>.  Binary releases (e.g., RPMs) have no
prerequisites.</p><p>A fairly recent version of GCC/G++ is required.  Version 2.95
and higher should work.</p><p>To build this manual and the man-pages you need the
<span class="command"><strong>xmllint</strong></span> and <span class="command"><strong>xsltproc</strong></span> programs,
which are part of the <code class="literal">libxml2</code> and
<code class="literal">libxslt</code> packages, respectively.  You also need the
<a class="link" href="http://docbook.sourceforge.net/projects/xsl/" target="_top">DocBook XSL
stylesheets</a> and optionally the <a class="link" href="http://www.docbook.org/schemas/5x" target="_top"> DocBook 5.0 RELAX NG
schemas</a>.  Note that these are only required if you modify the
manual sources or when you are building from the Subversion
repository.</p><p>To build the parser, very <span class="emphasis"><em>recent</em></span> versions
of Bison and Flex are required.  (This is because Nix needs GLR
support in Bison and reentrancy support in Flex.)  For Bison, you need
version 2.3 or higher (1.875 does <span class="emphasis"><em>not</em></span> work),
which can be obtained from
the <a class="link" href="ftp://alpha.gnu.org/pub/gnu/bison" target="_top">GNU FTP
server</a>.  For Flex, you need version 2.5.33, which is available
on <a class="link" href="http://lex.sourceforge.net/" target="_top">SourceForge</a>.
Slightly older versions may also work, but ancient versions like the
ubiquitous 2.5.4a won't.  Note that these are only required if you
modify the parser or when you are building from the Subversion
repository.</p><p>Nix uses the bzip2 compressor (including the bzip2 library).  It
is included in the Nix source distribution.  If you build from the
Subversion repository, you must download it yourself and place it in
the <code class="filename">externals/</code> directory.  See
<code class="filename">externals/Makefile.am</code> for the precise URLs of
this packages.  Alternatively, if you already have it installed, you
can use <span class="command"><strong>configure</strong></span>'s <code class="option">--with-bzip2</code>
options to point to their respective locations.</p></div><div class="section" title="3.4. Building Nix from source"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id482067"></a>3.4. Building Nix from source</h2></div></div></div><p>After unpacking or checking out the Nix sources, issue the
following commands:

</p><pre class="screen">
$ ./configure <em class="replaceable"><code>options...</code></em>
$ make
$ make install</pre><p>

</p><p>When building from the Subversion repository, these should be
preceded by the command:

</p><pre class="screen">
$ ./bootstrap.sh</pre><p>

</p><p>The installation path can be specified by passing the
<code class="option">--prefix=<em class="replaceable"><code>prefix</code></em></code> to
<span class="command"><strong>configure</strong></span>.  The default installation directory is
<code class="filename">/usr/local</code>.  You can change this to any location
you like.  You must have write permission to the
<em class="replaceable"><code>prefix</code></em> path.</p><p>Nix keeps its <span class="emphasis"><em>store</em></span> (the place where
packages are stored) in <code class="filename">/nix/store</code> by default.
This can be changed using
<code class="option">--with-store-dir=<em class="replaceable"><code>path</code></em></code>.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>It is best <span class="emphasis"><em>not</em></span> to change the Nix
store from its default, since doing so makes it impossible to use
pre-built binaries from the standard Nixpkgs channels &#8212; that is, all
packages will need to be built from source.</p></div><p>Nix keeps state (such as its database and log files) in
<code class="filename">/nix/var</code> by default.  This can be changed using
<code class="option">--localstatedir=<em class="replaceable"><code>path</code></em></code>.</p><p>If you want to rebuild the documentation, pass the full path to
the DocBook RELAX NG schemas and to the DocBook XSL stylesheets using
the
<code class="option">--with-docbook-rng=<em class="replaceable"><code>path</code></em></code>
and
<code class="option">--with-docbook-xsl=<em class="replaceable"><code>path</code></em></code>
options.</p></div><div class="section" title="3.5. Installing a binary distribution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id482173"></a>3.5. Installing a binary distribution</h2></div></div></div><p>RPM and Deb packages of Nix for a number of different versions
of Fedora, openSUSE, Debian and Ubuntu can be downloaded from <a class="link" href="http://nixos.org/" target="_top">http://nixos.org/</a>.  Once downloaded, the RPMs can be
installed or upgraded using <span class="command"><strong>rpm -U</strong></span>.  For example,

</p><pre class="screen">
$ rpm -U nix-0.13pre18104-1.i386.rpm</pre><p>

Likewise, for a Deb package:

</p><pre class="screen">
$ dpkg -i nix_0.13pre18104-1_amd64.deb</pre><p>

</p><p>Nix can be uninstalled using <span class="command"><strong>rpm -e nix</strong></span> or
<span class="command"><strong>dpkg -r nix</strong></span>.  After this you should manually remove
the Nix store and other auxiliary data, if desired:

</p><pre class="screen">
$ rm -rf /nix/store
$ rm -rf /nix/var</pre><p>

</p></div><div class="section" title="3.6. Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id483117"></a>3.6. Security</h2></div></div></div><p>Nix has two basic security models.  First, it can be used in
&#8220;single-user mode&#8221;, which is similar to what most other package
management tools do: there is a single user (typically <code class="systemitem">root</code>) who performs all package
management operations.  All other users can then use the installed
packages, but they cannot perform package management operations
themselves.</p><p>Alternatively, you can configure Nix in &#8220;multi-user mode&#8221;.  In
this model, all users can perform package management operations &#8212; for
instance, every user can install software without requiring root
privileges.  Nix ensures that this is secure.  For instance, it&#8217;s not
possible for one user to overwrite a package used by another user with
a Trojan horse.</p><div class="section" title="3.6.1. Single-user mode"><div class="titlepage"><div><div><h3 class="title"><a name="id483141"></a>3.6.1. Single-user mode</h3></div></div></div><p>In single-user mode, all Nix operations that access the database
in <code class="filename"><em class="replaceable"><code>prefix</code></em>/var/nix/db</code>
or modify the Nix store in
<code class="filename"><em class="replaceable"><code>prefix</code></em>/store</code> must be
performed under the user ID that owns those directories.  This is
typically <code class="systemitem">root</code>.  (If you
install from RPM packages, that&#8217;s in fact the default ownership.)
However, on single-user machines, it is often convenient to
<span class="command"><strong>chown</strong></span> those directories to your normal user account
so that you don&#8217;t have to <span class="command"><strong>su</strong></span> to <code class="systemitem">root</code> all the time.</p></div><div class="section" title="3.6.2. Multi-user mode"><div class="titlepage"><div><div><h3 class="title"><a name="ssec-multi-user"></a>3.6.2. Multi-user mode</h3></div></div></div><p>To allow a Nix store to be shared safely among multiple users,
it is important that users are not able to run builders that modify
the Nix store or database in arbitrary ways, or that interfere with
builds started by other users.  If they could do so, they could
install a Trojan horse in some package and compromise the accounts of
other users.</p><p>To prevent this, the Nix store and database are owned by some
privileged user (usually <code class="literal">root</code>) and builders are
executed under special user accounts (usually named
<code class="literal">nixbld1</code>, <code class="literal">nixbld2</code>, etc.).  When a
unprivileged user runs a Nix command, actions that operate on the Nix
store (such as builds) are forwarded to a <span class="emphasis"><em>Nix
daemon</em></span> running under the owner of the Nix store/database
that performs the operation.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Multi-user mode has one important limitation: only
<code class="systemitem">root</code> can run <span class="command"><strong><a class="command" href="#sec-nix-pull" title="nix-pull">nix-pull</a></strong></span> to register the availability
of pre-built binaries.  However, those registrations are shared by all
users, so they still get the benefit from <span class="command"><strong>nix-pull</strong></span>s
done by <code class="systemitem">root</code>.</p></div><div class="section" title="3.6.2.1. Setting up the build users"><div class="titlepage"><div><div><h4 class="title"><a name="id483248"></a>3.6.2.1. Setting up the build users</h4></div></div></div><p>The <span class="emphasis"><em>build users</em></span> are the special UIDs under
which builds are performed.  They should all be members of the
<span class="emphasis"><em>build users group</em></span> (usually called
<code class="literal">nixbld</code>).  This group should have no other members.
The build users should not be members of any other group.</p><p>Here is a typical <code class="filename">/etc/group</code> definition of
the build users group with 10 build users:

</p><pre class="programlisting">
nixbld:!:30000:nixbld1,nixbld2,nixbld3,nixbld4,nixbld5,nixbld6,nixbld7,nixbld8,nixbld9,nixbld10
</pre><p>

In this example the <code class="literal">nixbld</code> group has UID 30000, but
of course it can be anything that doesn&#8217;t collide with an existing
group.</p><p>Here is the corresponding part of
<code class="filename">/etc/passwd</code>:

</p><pre class="programlisting">
nixbld1:x:30001:65534:Nix build user 1:/var/empty:/noshell
nixbld2:x:30002:65534:Nix build user 2:/var/empty:/noshell
nixbld3:x:30003:65534:Nix build user 3:/var/empty:/noshell
...
nixbld10:x:30010:65534:Nix build user 10:/var/empty:/noshell
</pre><p>

The home directory of the build users should not exist or should be an
empty directory to which they do not have write access.</p><p>The build users should have write access to the Nix store, but
they should not have the right to delete files.  Thus the Nix store&#8217;s
group should be the build users group, and it should have the sticky
bit turned on (like <code class="filename">/tmp</code>):

</p><pre class="screen">
$ chgrp nixbld /nix/store
$ chmod 1777 /nix/store
</pre><p>

</p><p>Finally, you should tell Nix to use the build users by
specifying the build users group in the <a class="link" href="#conf-build-users-group"><code class="literal">build-users-group</code>
option</a> in the <a class="link" href="#sec-conf-file" title="A.3. Nix configuration file">Nix configuration
file</a> (<code class="literal">/nix/etc/nix/nix.conf</code>):

</p><pre class="programlisting">
build-users-group = nixbld
</pre><p>

</p></div><div class="section" title="3.6.2.2. Nix store/database owned by root"><div class="titlepage"><div><div><h4 class="title"><a name="id483340"></a>3.6.2.2. Nix store/database owned by root</h4></div></div></div><p>The simplest setup is to let <code class="literal">root</code> own the Nix
store and database.  I.e.,

</p><pre class="screen">
$ chown -R root /nix/store /nix/var/nix</pre><p>

</p><p>The <a class="link" href="#sec-nix-worker" title="nix-worker">Nix daemon</a> should be
started as follows (as <code class="literal">root</code>):

</p><pre class="screen">
$ nix-worker --daemon</pre><p>

You&#8217;ll want to put that line somewhere in your system&#8217;s boot
scripts.</p><p>To let unprivileged users use the daemon, they should set the
<a class="link" href="#envar-remote"><code class="envar">NIX_REMOTE</code> environment
variable</a> to <code class="literal">daemon</code>.  So you should put a
line like

</p><pre class="programlisting">
export NIX_REMOTE=daemon</pre><p>

into the users&#8217; login scripts.</p></div><div class="section" title="3.6.2.3. Nix store/database not owned by root"><div class="titlepage"><div><div><h4 class="title"><a name="id483397"></a>3.6.2.3. Nix store/database not owned by root</h4></div></div></div><p>It is also possible to let the Nix store and database be owned
by a non-root user, which should be more secure<sup>[<a name="id483405" href="#ftn.id483405" class="footnote">1</a>]</sup>.  Typically, this user
is a special account called <code class="literal">nix</code>, but it can be
named anything.  It should own the Nix store and database:

</p><pre class="screen">
$ chown -R root /nix/store /nix/var/nix</pre><p>

and of course <span class="command"><strong>nix-worker --daemon</strong></span> should be started
under that user, e.g.,

</p><pre class="screen">
$ su - nix -c "exec /nix/bin/nix-worker --daemon"</pre><p>

</p><p>There is a catch, though: non-<code class="literal">root</code> users
cannot start builds under the build user accounts, since the
<code class="function">setuid</code> system call is obviously privileged.  To
allow a non-<code class="literal">root</code> Nix daemon to use the build user
feature, it calls a setuid-root helper program,
<span class="command"><strong>nix-setuid-helper</strong></span>.  This program is installed in
<code class="filename"><em class="replaceable"><code>prefix</code></em>/libexec/nix-setuid-helper</code>.
To set the permissions properly (Nix&#8217;s <span class="command"><strong>make install</strong></span>
doesn&#8217;t do this, since we don&#8217;t want to ship setuid-root programs
out-of-the-box):

</p><pre class="screen">
$ chown root.root /nix/libexec/nix-setuid-helper
$ chmod 4755 /nix/libexec/nix-setuid-helper
</pre><p>

(This example assumes that the Nix binaries are installed in
<code class="filename">/nix</code>.)</p><p>Of course, the <span class="command"><strong>nix-setuid-helper</strong></span> command
should not be usable by just anybody, since then anybody could run
commands under the Nix build user accounts.  For that reason there is
a configuration file <code class="filename">/etc/nix-setuid.conf</code> that
restricts the use of the helper.  This file should be a text file
containing precisely two lines, the first being the Nix daemon user
and the second being the build users group, e.g.,

</p><pre class="programlisting">
nix
nixbld
</pre><p>

The setuid-helper barfs if it is called by a user other than the one
specified on the first line, or if it is asked to execute a build
under a user who is not a member of the group specified on the second
line.  The file <code class="filename">/etc/nix-setuid.conf</code> must be
owned by root, and must not be group- or world-writable.  The
setuid-helper barfs if this is not the case.</p></div><div class="section" title="3.6.2.4. Restricting access"><div class="titlepage"><div><div><h4 class="title"><a name="id483502"></a>3.6.2.4. Restricting access</h4></div></div></div><p>To limit which users can perform Nix operations, you can use the
permissions on the directory
<code class="filename">/nix/var/nix/daemon-socket</code>.  For instance, if you
want to restrict the use of Nix to the members of a group called
<code class="literal">nix-users</code>, do

</p><pre class="screen">
$ chgrp nix-users /nix/var/nix/daemon-socket
$ chmod ug=rwx,o= /nix/var/nix/daemon-socket
</pre><p>

This way, users who are not in the <code class="literal">nix-users</code> group
cannot connect to the Unix domain socket
<code class="filename">/nix/var/nix/daemon-socket/socket</code>, so they cannot
perform Nix operations.</p></div></div></div><div class="section" title="3.7. Using Nix"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id483542"></a>3.7. Using Nix</h2></div></div></div><p>To use Nix, some environment variables should be set.  In
particular, <code class="envar">PATH</code> should contain the directories
<code class="filename"><em class="replaceable"><code>prefix</code></em>/bin</code> and
<code class="filename">~/.nix-profile/bin</code>.  The first directory contains
the Nix tools themselves, while <code class="filename">~/.nix-profile</code> is
a symbolic link to the current <span class="emphasis"><em>user environment</em></span>
(an automatically generated package consisting of symlinks to
installed packages).  The simplest way to set the required environment
variables is to include the file
<code class="filename"><em class="replaceable"><code>prefix</code></em>/etc/profile.d/nix.sh</code>
in your <code class="filename">~/.bashrc</code> (or similar), like this:</p><pre class="screen">
source <em class="replaceable"><code>prefix</code></em>/etc/profile.d/nix.sh</pre></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id483405" href="#id483405" class="para">1</a>] </sup>Note
however that even when the Nix daemon runs as root, not
<span class="emphasis"><em>that</em></span> much code is executed as root: Nix
expression evaluation is performed by the calling (unprivileged) user,
and builds are performed under the special build user accounts.  So
only the code that accesses the database and starts builds is executed
as <code class="literal">root</code>.</p></div></div></div><div class="chapter" title="Chapter 4. Package Management"><div class="titlepage"><div><div><h2 class="title"><a name="chap-package-management"></a>Chapter 4. Package Management</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id482507">4.1. Basic package management</a></span></dt><dt><span class="section"><a href="#sec-profiles">4.2. Profiles</a></span></dt><dt><span class="section"><a href="#sec-garbage-collection">4.3. Garbage collection</a></span></dt><dd><dl><dt><span class="section"><a href="#ssec-gc-roots">4.3.1. Garbage collector roots</a></span></dt></dl></dd><dt><span class="section"><a href="#sec-channels">4.4. Channels</a></span></dt><dt><span class="section"><a href="#sec-one-click">4.5. One-click installs</a></span></dt><dt><span class="section"><a href="#sec-sharing-packages">4.6. Sharing packages between machines</a></span></dt></dl></div><p>This chapter discusses how to do package management with Nix,
i.e., how to obtain, install, upgrade, and erase packages.  This is
the &#8220;user&#8217;s&#8221; perspective of the Nix system &#8212; people
who want to <span class="emphasis"><em>create</em></span> packages should consult
<a class="xref" href="#chap-writing-nix-expressions" title="Chapter 5. Writing Nix Expressions">Chapter 5, <i>Writing Nix Expressions</i></a>.</p><div class="section" title="4.1. Basic package management"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id482507"></a>4.1. Basic package management</h2></div></div></div><p>The main command for package management is <a class="link" href="#sec-nix-env" title="nix-env"><span class="command"><strong>nix-env</strong></span></a>.  You can use
it to install, upgrade, and erase packages, and to query what
packages are installed or are available for installation.</p><p>In Nix, different users can have different &#8220;views&#8221;
on the set of installed applications.  That is, there might be lots of
applications present on the system (possibly in many different
versions), but users can have a specific selection of those active &#8212;
where &#8220;active&#8221; just means that it appears in a directory
in the user&#8217;s <code class="envar">PATH</code>.  Such a view on the set of
installed applications is called a <span class="emphasis"><em>user
environment</em></span>, which is just a directory tree consisting of
symlinks to the files of the active applications.  </p><p>Components are installed from a set of <span class="emphasis"><em>Nix
expressions</em></span> that tell Nix how to build those packages,
including, if necessary, their dependencies.  There is a collection of
Nix expressions called the Nix Package collection that contains
packages ranging from basic development stuff such as GCC and Glibc,
to end-user applications like Mozilla Firefox.  (Nix is however not
tied to the Nix Package collection; you could write your own Nix
expressions based on it, or completely new ones.)  You can download
the latest version from <a class="link" href="http://nixos.org/nixpkgs/download.html" target="_top">http://nixos.org/nixpkgs/download.html</a>.</p><p>Assuming that you have downloaded and unpacked a release of Nix
Packages, you can view the set of available packages in the release:

</p><pre class="screen">
$ nix-env -qaf nixpkgs-<em class="replaceable"><code>version</code></em> '*'
ant-blackdown-1.4.2
aterm-2.2
bash-3.0
binutils-2.15
bison-1.875d
blackdown-1.4.2
bzip2-1.0.2
...</pre><p>

where <code class="literal">nixpkgs-<em class="replaceable"><code>version</code></em></code> is
where you&#8217;ve unpacked the release.  The flag <code class="option">-q</code>
specifies a query operation; <code class="option">-a</code> means that you want
to show the &#8220;available&#8221; (i.e., installable) packages, as opposed to
the installed packages; and <code class="option">-f</code>
<code class="filename">nixpkgs-<em class="replaceable"><code>version</code></em></code>
specifies the source of the packages.  The argument
<code class="literal">'*'</code> shows all installable packages. (The quotes are
necessary to prevent shell expansion.)  You can also select specific
packages by name:

</p><pre class="screen">
$ nix-env -qaf nixpkgs-<em class="replaceable"><code>version</code></em> gcc
gcc-3.4.6
gcc-4.0.3
gcc-4.1.1</pre><p>

</p><p>It is also possible to see the <span class="emphasis"><em>status</em></span> of
available packages, i.e., whether they are installed into the user
environment and/or present in the system:

</p><pre class="screen">
$ nix-env -qasf nixpkgs-<em class="replaceable"><code>version</code></em> '*'
...
-PS bash-3.0
--S binutils-2.15
IPS bison-1.875d
...</pre><p>

The first character (<code class="literal">I</code>) indicates whether the
package is installed in your current user environment.  The second
(<code class="literal">P</code>) indicates whether it is present on your system
(in which case installing it into your user environment would be a
very quick operation).  The last one (<code class="literal">S</code>) indicates
whether there is a so-called <span class="emphasis"><em>substitute</em></span> for the
package, which is Nix&#8217;s mechanism for doing binary deployment.  It
just means that Nix knows that it can fetch a pre-built package from
somewhere (typically a network server) instead of building it
locally.</p><p>So now that we have a set of Nix expressions we can build the
packages contained in them.  This is done using <code class="literal">nix-env
-i</code>.  For instance,

</p><pre class="screen">
$ nix-env -f nixpkgs-<em class="replaceable"><code>version</code></em> -i subversion</pre><p>

will install the package called <code class="literal">subversion</code> (which
is, of course, the <a class="link" href="http://subversion.tigris.org/" target="_top">Subversion version
management system</a>).</p><p>When you do this for the first time, Nix will start building
Subversion and all its dependencies.  This will take quite a while &#8212;
typically an hour or two on modern machines.  Fortunately, there is a
faster way (so do a Ctrl-C on that install operation!): you just need
to tell Nix that pre-built binaries of all those packages are
available somewhere.  This is done using the
<span class="command"><strong>nix-pull</strong></span> command, which must be supplied with a URL
containing a <span class="emphasis"><em>manifest</em></span> describing what binaries
are available.  This URL should correspond to the Nix Packages release
that you&#8217;re using.  For instance, if you obtained a release from <a class="link" href="http://nixos.org/releases/nixpkgs/nixpkgs-0.12pre11712-4lrp7j8x" target="_top">http://nixos.org/releases/nixpkgs/nixpkgs-0.12pre11712-4lrp7j8x</a>, then you should do:

</p><pre class="screen">
$ nix-pull http://nixos.org/releases/nixpkgs/nixpkgs-0.12pre11712-4lrp7j8x/MANIFEST</pre><p>

If you then issue the installation command, it should start
downloading binaries from <code class="systemitem">nixos.org</code>, instead of building
them from source.  This might still take a while since all
dependencies must be downloaded, but on a reasonably fast connection
such as an DSL line it&#8217;s on the order of a few minutes.</p><p>Naturally, packages can also be uninstalled:

</p><pre class="screen">
$ nix-env -e subversion</pre><p>

</p><p>Upgrading to a new version is just as easy.  If you have a new
release of Nix Packages, you can do:

</p><pre class="screen">
$ nix-env -f nixpkgs-<em class="replaceable"><code>version</code></em> -u subversion</pre><p>

This will <span class="emphasis"><em>only</em></span> upgrade Subversion if there is a
&#8220;newer&#8221; version in the new set of Nix expressions, as
defined by some pretty arbitrary rules regarding ordering of version
numbers (which generally do what you&#8217;d expect of them).  To just
unconditionally replace Subversion with whatever version is in the Nix
expressions, use <em class="parameter"><code>-i</code></em> instead of
<em class="parameter"><code>-u</code></em>; <em class="parameter"><code>-i</code></em> will remove
whatever version is already installed.</p><p>You can also upgrade all packages for which there are newer
versions:

</p><pre class="screen">
$ nix-env -f nixpkgs-<em class="replaceable"><code>version</code></em> -u '*'</pre><p>

</p><p>Sometimes it&#8217;s useful to be able to ask what
<span class="command"><strong>nix-env</strong></span> would do, without actually doing it.  For
instance, to find out what packages would be upgraded by
<code class="literal">nix-env -u '*'</code>, you can do

</p><pre class="screen">
$ nix-env ... -u '*' --dry-run
(dry run; not doing anything)
upgrading `libxslt-1.1.0' to `libxslt-1.1.10'
upgrading `graphviz-1.10' to `graphviz-1.12'
upgrading `coreutils-5.0' to `coreutils-5.2.1'</pre><p>

</p><p>If you grow bored of specifying the Nix expressions using
<em class="parameter"><code>-f</code></em> all the time, you can set a default
location:

</p><pre class="screen">
$ nix-env -I nixpkgs-<em class="replaceable"><code>version</code></em></pre><p>

After this you can just say, for instance, <code class="literal">nix-env -u
'*'</code>.<sup>[<a name="id482718" href="#ftn.id482718" class="footnote">2</a>]</sup></p></div><div class="section" title="4.2. Profiles"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-profiles"></a>4.2. Profiles</h2></div></div></div><p>Profiles and user environments are Nix&#8217;s mechanism for
implementing the ability to allow different users to have different
configurations, and to do atomic upgrades and rollbacks.  To
understand how they work, it&#8217;s useful to know a bit about how Nix
works.  In Nix, packages are stored in unique locations in the
<span class="emphasis"><em>Nix store</em></span> (typically,
<code class="filename">/nix/store</code>).  For instance, a particular version
of the Subversion package might be stored in a directory
<code class="filename">/nix/store/dpmvp969yhdqs7lm2r1a3gng7pyq6vy4-subversion-1.1.3/</code>,
while another version might be stored in
<code class="filename">/nix/store/5mq2jcn36ldlmh93yj1n8s9c95pj7c5s-subversion-1.1.2</code>.
The long strings prefixed to the directory names are cryptographic
hashes<sup>[<a name="id482766" href="#ftn.id482766" class="footnote">3</a>]</sup> of
<span class="emphasis"><em>all</em></span> inputs involved in building the package &#8212;
sources, dependencies, compiler flags, and so on.  So if two
packages differ in any way, they end up in different locations in
the file system, so they don&#8217;t interfere with each other.  <a class="xref" href="#fig-user-environments" title="Figure 4.1. User environments">Figure 4.1, &#8220;User environments&#8221;</a> shows a part of a typical Nix
store.</p><div class="figure"><a name="fig-user-environments"></a><p class="title"><b>Figure 4.1. User environments</b></p><div class="figure-contents"><div class="mediaobject"><img src="figures/user-environments.png" alt="User environments"></div></div></div><br class="figure-break"><p>Of course, you wouldn&#8217;t want to type

</p><pre class="screen">
$ /nix/store/dpmvp969yhdq...-subversion-1.1.3/bin/svn</pre><p>

every time you want to run Subversion.  Of course we could set up the
<code class="envar">PATH</code> environment variable to include the
<code class="filename">bin</code> directory of every package we want to use,
but this is not very convenient since changing <code class="envar">PATH</code>
doesn&#8217;t take effect for already existing processes.  The solution Nix
uses is to create directory trees of symlinks to
<span class="emphasis"><em>activated</em></span> packages.  These are called
<span class="emphasis"><em>user environments</em></span> and they are packages
themselves (though automatically generated by
<span class="command"><strong>nix-env</strong></span>), so they too reside in the Nix store.  For
instance, in <a class="xref" href="#fig-user-environments" title="Figure 4.1. User environments">Figure 4.1, &#8220;User environments&#8221;</a> the user
environment <code class="filename">/nix/store/5mq2jcn36ldl...-user-env</code>
contains a symlink to just Subversion 1.1.2 (arrows in the figure
indicate symlinks).  This would be what we would obtain if we had done

</p><pre class="screen">
$ nix-env -i subversion</pre><p>

on a set of Nix expressions that contained Subversion 1.1.2.</p><p>This doesn&#8217;t in itself solve the problem, of course; you
wouldn&#8217;t want to type
<code class="filename">/nix/store/0c1p5z4kda11...-user-env/bin/svn</code>
either.  That&#8217;s why there are symlinks outside of the store that point
to the user environments in the store; for instance, the symlinks
<code class="filename">default-42-link</code> and
<code class="filename">default-43-link</code> in the example.  These are called
<span class="emphasis"><em>generations</em></span> since every time you perform a
<span class="command"><strong>nix-env</strong></span> operation, a new user environment is
generated based on the current one.  For instance, generation 43 was
created from generation 42 when we did

</p><pre class="screen">
$ nix-env -i subversion mozilla</pre><p>

on a set of Nix expressions that contained Mozilla and a new version
of Subversion.</p><p>Generations are grouped together into
<span class="emphasis"><em>profiles</em></span> so that different users don&#8217;t interfere
with each other if they don&#8217;t want to.  For example:

</p><pre class="screen">
$ ls -l /nix/var/nix/profiles/
...
lrwxrwxrwx  1 eelco ... default-42-link -&gt; /nix/store/0c1p5z4kda11...-user-env
lrwxrwxrwx  1 eelco ... default-43-link -&gt; /nix/store/3aw2pdyx2jfc...-user-env
lrwxrwxrwx  1 eelco ... default -&gt; default-43-link</pre><p>

This shows a profile called <code class="filename">default</code>.  The file
<code class="filename">default</code> itself is actually a symlink that points
to the current generation.  When we do a <span class="command"><strong>nix-env</strong></span>
operation, a new user environment and generation link are created
based on the current one, and finally the <code class="filename">default</code>
symlink is made to point at the new generation.  This last step is
atomic on Unix, which explains how we can do atomic upgrades.  (Note
that the building/installing of new packages doesn&#8217;t interfere in
any way with old packages, since they are stored in different
locations in the Nix store.)</p><p>If you find that you want to undo a <span class="command"><strong>nix-env</strong></span>
operation, you can just do

</p><pre class="screen">
$ nix-env --rollback</pre><p>

which will just make the current generation link point at the previous
link.  E.g., <code class="filename">default</code> would be made to point at
<code class="filename">default-42-link</code>.  You can also switch to a
specific generation:

</p><pre class="screen">
$ nix-env --switch-generation 43</pre><p>

which in this example would roll forward to generation 43 again.  You
can also see all available generations:

</p><pre class="screen">
$ nix-env --list-generations</pre><p>Actually, there is another level of indirection not shown in the
figure above.  You generally wouldn&#8217;t have
<code class="filename">/nix/var/nix/profiles/<em class="replaceable"><code>some-profile</code></em>/bin</code>
in your <code class="envar">PATH</code>.  Rather, there is a symlink
<code class="filename">~/.nix-profile</code> that points to your current
profile.  This means that you should put
<code class="filename">~/.nix-profile/bin</code> in your <code class="envar">PATH</code>
(and indeed, that&#8217;s what the initialisation script
<code class="filename">/nix/etc/profile.d/nix.sh</code> does).  This makes it
easier to switch to a different profile.  You can do that using the
command <span class="command"><strong>nix-env --switch-profile</strong></span>:

</p><pre class="screen">
$ nix-env --switch-profile /nix/var/nix/profiles/my-profile

$ nix-env --switch-profile /nix/var/nix/profiles/default</pre><p>

These commands switch to the <code class="filename">my-profile</code> and
default profile, respectively.  If the profile doesn&#8217;t exist, it will
be created automatically.  You should be careful about storing a
profile in another location than the <code class="filename">profiles</code>
directory, since otherwise it might not be used as a root of the
garbage collector (see <a class="xref" href="#sec-garbage-collection" title="4.3. Garbage collection">Section 4.3, &#8220;Garbage collection&#8221;</a>).</p><p>All <span class="command"><strong>nix-env</strong></span> operations work on the profile
pointed to by <span class="command"><strong>~/.nix-profile</strong></span>, but you can override
this using the <code class="option">--profile</code> option (abbreviation
<code class="option">-p</code>):

</p><pre class="screen">
$ nix-env -p /nix/var/nix/profiles/other-profile -i subversion</pre><p>

This will <span class="emphasis"><em>not</em></span> change the
<span class="command"><strong>~/.nix-profile</strong></span> symlink.</p></div><div class="section" title="4.3. Garbage collection"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-garbage-collection"></a>4.3. Garbage collection</h2></div></div></div><p><span class="command"><strong>nix-env</strong></span> operations such as upgrades
(<code class="option">-u</code>) and uninstall (<code class="option">-e</code>) never
actually delete packages from the system.  All they do (as shown
above) is to create a new user environment that no longer contains
symlinks to the &#8220;deleted&#8221; packages.</p><p>Of course, since disk space is not infinite, unused packages
should be removed at some point.  You can do this by running the Nix
garbage collector.  It will remove from the Nix store any package
not used (directly or indirectly) by any generation of any
profile.</p><p>Note however that as long as old generations reference a
package, it will not be deleted.  After all, we wouldn&#8217;t be able to
do a rollback otherwise.  So in order for garbage collection to be
effective, you should also delete (some) old generations.  Of course,
this should only be done if you are certain that you will not need to
roll back.</p><p>To delete all old (non-current) generations of your current
profile:

</p><pre class="screen">
$ nix-env --delete-generations old</pre><p>

Instead of <code class="literal">old</code> you can also specify a list of
generations, e.g.,

</p><pre class="screen">
$ nix-env --delete-generations 10 11 14</pre><p>

</p><p>After removing appropriate old generations you can run the
garbage collector as follows:

</p><pre class="screen">
$ nix-store --gc</pre><p>

If you are feeling uncertain, you can also first view what files would
be deleted:

</p><pre class="screen">
$ nix-store --gc --print-dead</pre><p>

Likewise, the option <code class="option">--print-live</code> will show the paths
that <span class="emphasis"><em>won&#8217;t</em></span> be deleted.</p><p>There is also a convenient little utility
<span class="command"><strong>nix-collect-garbage</strong></span>, which when invoked with the
<code class="option">-d</code> (<code class="option">--delete-old</code>) switch deletes all
old generations of all profiles in
<code class="filename">/nix/var/nix/profiles</code>.  So

</p><pre class="screen">
$ nix-collect-garbage -d</pre><p>

is a quick and easy way to clean up your system.</p><div class="section" title="4.3.1. Garbage collector roots"><div class="titlepage"><div><div><h3 class="title"><a name="ssec-gc-roots"></a>4.3.1. Garbage collector roots</h3></div></div></div><p>The roots of the garbage collector are all store paths to which
there are symlinks in the directory
<code class="filename"><em class="replaceable"><code>prefix</code></em>/nix/var/nix/gcroots</code>.
For instance, the following command makes the path
<code class="filename">/nix/store/d718ef...-foo</code> a root of the collector:

</p><pre class="screen">
$ ln -s /nix/store/d718ef...-foo /nix/var/nix/gcroots/bar</pre><p>
	
That is, after this command, the garbage collector will not remove
<code class="filename">/nix/store/d718ef...-foo</code> or any of its
dependencies.</p><p>Subdirectories of
<code class="filename"><em class="replaceable"><code>prefix</code></em>/nix/var/nix/gcroots</code>
are also searched for symlinks.  Symlinks to non-store paths are
followed and searched for roots, but symlinks to non-store paths
<span class="emphasis"><em>inside</em></span> the paths reached in that way are not
followed to prevent infinite recursion.</p></div></div><div class="section" title="4.4. Channels"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-channels"></a>4.4. Channels</h2></div></div></div><p>If you want to stay up to date with a set of packages, it&#8217;s not
very convenient to manually download the latest set of Nix expressions
for those packages, use <span class="command"><strong>nix-pull</strong></span> to register
pre-built binaries (if available), and upgrade using
<span class="command"><strong>nix-env</strong></span>.  Fortunately, there&#8217;s a better way:
<span class="emphasis"><em>Nix channels</em></span>.</p><p>A Nix channel is just a URL that points to a place that contains
a set of Nix expressions and a manifest.  Using the command <a class="link" href="#sec-nix-channel" title="nix-channel"><span class="command"><strong>nix-channel</strong></span></a> you
can automatically stay up to date with whatever is available at that
URL.</p><p>You can &#8220;subscribe&#8221; to a channel using
<span class="command"><strong>nix-channel --add</strong></span>, e.g.,

</p><pre class="screen">
$ nix-channel --add http://nixos.org/releases/nixpkgs/channels/nixpkgs-unstable</pre><p>

subscribes you to a channel that always contains that latest version
of the Nix Packages collection.  (Instead of
<code class="literal">nixpkgs-unstable</code> you could also subscribe to
<code class="literal">nixpkgs-stable</code>, which should have a higher level of
stability, but right now is just outdated.)  Subscribing really just
means that the URL is added to the file
<code class="filename">~/.nix-channels</code>.  Right now there is no command
to &#8220;unsubscribe&#8221;; you should just edit that file manually
and delete the offending URL.</p><p>To obtain the latest Nix expressions available in a channel, do

</p><pre class="screen">
$ nix-channel --update</pre><p>

This downloads the Nix expressions in every channel (downloaded from
<code class="literal"><em class="replaceable"><code>url</code></em>/nixexprs.tar.bz2</code>)
and registers any available pre-built binaries in every channel
(by <span class="command"><strong>nix-pull</strong></span>ing
<code class="literal"><em class="replaceable"><code>url</code></em>/MANIFEST</code>).  It also
makes the union of each channel&#8217;s Nix expressions the default for
<span class="command"><strong>nix-env</strong></span> operations.  Consequently, you can then say

</p><pre class="screen">
$ nix-env -u '*'</pre><p>

to upgrade all packages in your profile to the latest versions
available in the subscribed channels.</p></div><div class="section" title="4.5. One-click installs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-one-click"></a>4.5. One-click installs</h2></div></div></div><p>Often, when you want to install a specific package (e.g., from
the <a class="link" href="http://nixos.org/nixpkgs/" target="_top">Nix
Packages collection</a>), subscribing to a channel is a bit
cumbersome.  And channels don&#8217;t help you at all if you want to install
an older version of a package than the one provided by the current
contents of the channel, or a package that has been removed from the
channel.  That&#8217;s when <span class="emphasis"><em>one-click installs</em></span> come in
handy: you can just go to the web page that contains the package,
click on it, and it will be installed with all the necessary
dependencies.</p><p>For instance, you can go to <a class="link" href="http://hydra.nixos.org/jobset/nixpkgs/trunk/channel/latest" target="_top">http://hydra.nixos.org/jobset/nixpkgs/trunk/channel/latest</a> and click on any link for the individual packages for your
platform.  The first time you do this, your browser will ask what to
do with <code class="literal">application/nix-package</code> files.  You should
open them with <code class="filename">/nix/bin/nix-install-package</code>.
This will open a window that asks you to confirm that you want to
install the package.  When you answer <code class="literal">Y</code>, the
package and all its dependencies will be installed.  This is a binary
deployment mechanism &#8212; you get packages pre-compiled for the selected
platform type.</p><p>You can also install <code class="literal">application/nix-package</code>
files from the command line directly.  See <a class="xref" href="#sec-nix-install-package" title="nix-install-package"><span class="refentrytitle">nix-install-package</span>(1)</a> for details.</p></div><div class="section" title="4.6. Sharing packages between machines"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-sharing-packages"></a>4.6. Sharing packages between machines</h2></div></div></div><p>Sometimes you want to copy a package from one machine to
another.  Or, you want to install some packages and you know that
another machine already has some or all of those packages or their
dependencies.  In that case there are mechanisms to quickly copy
packages between machines.</p><p>The command <span class="command"><strong><a class="command" href="#sec-nix-copy-closure" title="nix-copy-closure">nix-copy-closure</a></strong></span> copies a Nix
store path along with all its dependencies to or from another machine
via the SSH protocol.  It doesn&#8217;t copy store paths that are already
present on the target machine.  For example, the following command
copies Firefox with all its dependencies:

</p><pre class="screen">
$ nix-copy-closure --to alice@itchy.example.org $(type -p firefox)</pre><p>

See <a class="xref" href="#sec-nix-copy-closure" title="nix-copy-closure"><span class="refentrytitle">nix-copy-closure</span>(1)</a> for details.</p><p>With <span class="command"><strong><a class="command" href="#refsec-nix-store-export" title="Operation --export">nix-store
--export</a></strong></span> and <span class="command"><strong><a class="command" href="#refsec-nix-store-import" title="Operation --import">nix-store --import</a></strong></span> you can
write the closure of a store path (that is, the path and all its
dependencies) to a file, and then unpack that file into another Nix
store.  For example,

</p><pre class="screen">
$ nix-store --export $(type -p firefox) &gt; firefox.closure</pre><p>

writes the closure of Firefox to a file.  You can then copy this file
to another machine and install the closure:

</p><pre class="screen">
$ nix-store --import &lt; firefox.closure</pre><p>

Any store paths in the closure that are already present in the target
store are ignored.  It is also possible to pipe the export into
another command, e.g. to copy and install a closure directly to/on
another machine:

</p><pre class="screen">
$ nix-store --export $(type -p firefox) | bzip2 | \
    ssh alice@itchy.example.org "bunzip2 | nix-store --import"</pre><p>

But note that <span class="command"><strong>nix-copy-closure</strong></span> is generally more
efficient in this example because it only copies paths that are not
already present in the target Nix store.</p><p>Finally, if you can mount the Nix store of a remote machine in
your local filesystem, Nix can copy paths from the remote Nix store to
the local Nix store <span class="emphasis"><em>on demand</em></span>.  For instance,
suppose that you mount a remote machine containing a Nix store via
<span class="command"><strong><a class="command" href="http://fuse.sourceforge.net/sshfs.html" target="_top">sshfs</a></strong></span>:

</p><pre class="screen">
$ sshfs alice@itchy.example.org:/ /mnt</pre><p>

You should then set the <code class="envar">NIX_OTHER_STORES</code> environment
variable to tell Nix about this remote Nix store:

</p><pre class="screen">
$ export NIX_OTHER_STORES=/mnt/nix</pre><p>

Then if you do any Nix operation, e.g.

</p><pre class="screen">
$ nix-env -i firefox</pre><p>

and Nix has to build a path that it sees is already present in
<code class="filename">/mnt/nix</code>, then it will just copy from there
instead of building it from source.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id482718" href="#id482718" class="para">2</a>] </sup>Setting a default using
<em class="parameter"><code>-I</code></em> currently clashes with using Nix channels,
since <code class="literal">nix-channel --update</code> calls <code class="literal">nix-env
-I</code> to set the default to the Nix expressions it downloaded
from the channel, replacing whatever default you had
set.</p></div><div class="footnote"><p><sup>[<a name="ftn.id482766" href="#id482766" class="para">3</a>] </sup>160-bit truncations of SHA-256 hashes encoded in
a base-32 notation, to be precise.</p></div></div></div><div class="chapter" title="Chapter 5. Writing Nix Expressions"><div class="titlepage"><div><div><h2 class="title"><a name="chap-writing-nix-expressions"></a>Chapter 5. Writing Nix Expressions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id489273">5.1. A simple Nix expression</a></span></dt><dd><dl><dt><span class="section"><a href="#id489196">5.1.1. The Nix expression</a></span></dt><dt><span class="section"><a href="#id488873">5.1.2. The builder</a></span></dt><dt><span class="section"><a href="#id488656">5.1.3. Composition</a></span></dt><dt><span class="section"><a href="#id488499">5.1.4. Testing</a></span></dt><dt><span class="section"><a href="#id488378">5.1.5. The generic builder</a></span></dt></dl></dd><dt><span class="section"><a href="#id488220">5.2. The Nix expression language</a></span></dt><dd><dl><dt><span class="section"><a href="#ssec-values">5.2.1. Values</a></span></dt><dt><span class="section"><a href="#id487820">5.2.2. Language constructs</a></span></dt><dt><span class="section"><a href="#id491116">5.2.3. Operators</a></span></dt><dt><span class="section"><a href="#ssec-derivation">5.2.4. Derivations</a></span></dt><dd><dl><dt><span class="section"><a href="#id491813">5.2.4.1. Advanced attributes</a></span></dt></dl></dd><dt><span class="section"><a href="#ssec-builtins">5.2.5. Built-in functions</a></span></dt></dl></dd><dt><span class="section"><a href="#sec-standard-environment">5.3. The standard environment</a></span></dt><dd><dl><dt><span class="section"><a href="#id493997">5.3.1. Customising the generic builder</a></span></dt><dt><span class="section"><a href="#id494024">5.3.2. Debugging failed builds</a></span></dt></dl></dd></dl></div><p>This chapter shows you how to write Nix expressions, which are
the things that tell Nix how to build packages.  It starts with a
simple example (a Nix expression for GNU Hello), and then moves
on to a more in-depth look at the Nix expression language.</p><div class="section" title="5.1. A simple Nix expression"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id489273"></a>5.1. A simple Nix expression</h2></div></div></div><p>This section shows how to add and test the <a class="link" href="http://www.gnu.org/software/hello/hello.html" target="_top">GNU Hello
package</a> to the Nix Packages collection.  Hello is a program
that prints out the text <span class="quote">&#8220;<span class="quote">Hello, world!</span>&#8221;</span>.</p><p>To add a package to the Nix Packages collection, you generally
need to do three things:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Write a Nix expression for the package.  This is a
  file that describes all the inputs involved in building the package,
  such as dependencies, sources, and so on.</p></li><li class="listitem"><p>Write a <span class="emphasis"><em>builder</em></span>.  This is a
  shell script<sup>[<a name="id489240" href="#ftn.id489240" class="footnote">4</a>]</sup> that actually builds the package from
  the inputs.</p></li><li class="listitem"><p>Add the package to the file
  <code class="filename">pkgs/top-level/all-packages.nix</code>.  The Nix
  expression written in the first step is a
  <span class="emphasis"><em>function</em></span>; it requires other packages in order
  to build it.  In this step you put it all together, i.e., you call
  the function with the right arguments to build the actual
  package.</p></li></ol></div><p>

</p><div class="section" title="5.1.1. The Nix expression"><div class="titlepage"><div><div><h3 class="title"><a name="id489196"></a>5.1.1. The Nix expression</h3></div></div></div><div class="example"><a name="ex-hello-nix"></a><p class="title"><b>Example 5.1. Nix expression for GNU Hello
(<code class="filename">default.nix</code>)</b></p><div class="example-contents"><pre class="programlisting">
{stdenv, fetchurl, perl}: <a name="ex-hello-nix-co-1"></a><img src="images/callouts/1.gif" alt="1" border="0">

stdenv.mkDerivation { <a name="ex-hello-nix-co-2"></a><img src="images/callouts/2.gif" alt="2" border="0">
  name = "hello-2.1.1"; <a name="ex-hello-nix-co-3"></a><img src="images/callouts/3.gif" alt="3" border="0">
  builder = ./builder.sh; <a name="ex-hello-nix-co-4"></a><img src="images/callouts/4.gif" alt="4" border="0">
  src = fetchurl { <a name="ex-hello-nix-co-5"></a><img src="images/callouts/5.gif" alt="5" border="0">
    url = ftp://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz;
    md5 = "70c9ccf9fac07f762c24f2df2290784d";
  };
  inherit perl; <a name="ex-hello-nix-co-6"></a><img src="images/callouts/6.gif" alt="6" border="0">
}</pre></div></div><br class="example-break"><p><a class="xref" href="#ex-hello-nix" title="Example 5.1. Nix expression for GNU Hello (default.nix)">Example 5.1, &#8220;Nix expression for GNU Hello
(<code class="filename">default.nix</code>)&#8221;</a> shows a Nix expression for GNU
Hello.  It's actually already in the Nix Packages collection in
<code class="filename">pkgs/applications/misc/hello/ex-1/default.nix</code>.
It is customary to place each package in a separate directory and call
the single Nix expression in that directory
<code class="filename">default.nix</code>.  The file has the following elements
(referenced from the figure by number):

</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-nix-co-1"><img src="images/callouts/1.gif" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>This states that the expression is a
    <span class="emphasis"><em>function</em></span> that expects to be called with three
    arguments: <code class="varname">stdenv</code>, <code class="varname">fetchurl</code>,
    and <code class="varname">perl</code>.  They are needed to build Hello, but
    we don't know how to build them here; that's why they are function
    arguments.  <code class="varname">stdenv</code> is a package that is used
    by almost all Nix Packages packages; it provides a
    <span class="quote">&#8220;<span class="quote">standard</span>&#8221;</span> environment consisting of the things you
    would expect in a basic Unix environment: a C/C++ compiler (GCC,
    to be precise), the Bash shell, fundamental Unix tools such as
    <span class="command"><strong>cp</strong></span>, <span class="command"><strong>grep</strong></span>,
    <span class="command"><strong>tar</strong></span>, etc.  <code class="varname">fetchurl</code> is a
    function that downloads files.  <code class="varname">perl</code> is the
    Perl interpreter.</p><p>Nix functions generally have the form <code class="literal">{x, y, ...,
    z}: e</code> where <code class="varname">x</code>, <code class="varname">y</code>,
    etc. are the names of the expected arguments, and where
    <em class="replaceable"><code>e</code></em> is the body of the function.  So
    here, the entire remainder of the file is the body of the
    function; when given the required arguments, the body should
    describe how to build an instance of the Hello package.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-nix-co-2"><img src="images/callouts/2.gif" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>So we have to build a package.  Building something from
    other stuff is called a <span class="emphasis"><em>derivation</em></span> in Nix (as
    opposed to sources, which are built by humans instead of
    computers).  We perform a derivation by calling
    <code class="varname">stdenv.mkDerivation</code>.
    <code class="varname">mkDerivation</code> is a function provided by
    <code class="varname">stdenv</code> that builds a package from a set of
    <span class="emphasis"><em>attributes</em></span>.  An attribute set is just a list
    of key/value pairs where each value is an arbitrary Nix
    expression.  They take the general form
    <code class="literal">{<em class="replaceable"><code>name1</code></em> =
    <em class="replaceable"><code>expr1</code></em>; <em class="replaceable"><code>...</code></em>
    <em class="replaceable"><code>nameN</code></em> =
    <em class="replaceable"><code>exprN</code></em>;}</code>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-nix-co-3"><img src="images/callouts/3.gif" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The attribute <code class="varname">name</code> specifies the symbolic
    name and version of the package.  Nix doesn't really care about
    these things, but they are used by for instance <span class="command"><strong>nix-env
    -q</strong></span> to show a <span class="quote">&#8220;<span class="quote">human-readable</span>&#8221;</span> name for
    packages.  This attribute is required by
    <code class="varname">mkDerivation</code>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-nix-co-4"><img src="images/callouts/4.gif" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The attribute <code class="varname">builder</code> specifies the
    builder.  This attribute can sometimes be omitted, in which case
    <code class="varname">mkDerivation</code> will fill in a default builder
    (which does a <code class="literal">configure; make; make install</code>, in
    essence).  Hello is sufficiently simple that the default builder
    would suffice, but in this case, we will show an actual builder
    for educational purposes.  The value
    <span class="command"><strong>./builder.sh</strong></span> refers to the shell script shown
    in <a class="xref" href="#ex-hello-builder" title="Example 5.2. Build script for GNU Hello (builder.sh)">Example 5.2, &#8220;Build script for GNU Hello
(<code class="filename">builder.sh</code>)&#8221;</a>, discussed below.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-nix-co-5"><img src="images/callouts/5.gif" alt="5" border="0"></a> </p></td><td valign="top" align="left"><p>The builder has to know what the sources of the package
    are.  Here, the attribute <code class="varname">src</code> is bound to the
    result of a call to the <span class="command"><strong>fetchurl</strong></span> function.
    Given a URL and an MD5 hash of the expected contents of the file
    at that URL, this function builds a derivation that downloads the
    file and checks its hash.  So the sources are a dependency that
    like all other dependencies is built before Hello itself is
    built.</p><p>Instead of <code class="varname">src</code> any other name could have
    been used, and in fact there can be any number of sources (bound
    to different attributes).  However, <code class="varname">src</code> is
    customary, and it's also expected by the default builder (which we
    don't use in this example).</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-nix-co-6"><img src="images/callouts/6.gif" alt="6" border="0"></a> </p></td><td valign="top" align="left"><p>Since the derivation requires Perl, we have to pass the
    value of the <code class="varname">perl</code> function argument to the
    builder.  All attributes in the set are actually passed as
    environment variables to the builder, so declaring an attribute

    </p><pre class="programlisting">
perl = perl;</pre><p>

    will do the trick: it binds an attribute <code class="varname">perl</code>
    to the function argument which also happens to be called
    <code class="varname">perl</code>.  However, it looks a bit silly, so there
    is a shorter syntax.  The <code class="literal">inherit</code> keyword
    causes the specified attributes to be bound to whatever variables
    with the same name happen to be in scope.</p></td></tr></table></div><p>

</p></div><div class="section" title="5.1.2. The builder"><div class="titlepage"><div><div><h3 class="title"><a name="id488873"></a>5.1.2. The builder</h3></div></div></div><div class="example"><a name="ex-hello-builder"></a><p class="title"><b>Example 5.2. Build script for GNU Hello
(<code class="filename">builder.sh</code>)</b></p><div class="example-contents"><pre class="programlisting">
source $stdenv/setup <a name="ex-hello-builder-co-1"></a><img src="images/callouts/1.gif" alt="1" border="0">

PATH=$perl/bin:$PATH <a name="ex-hello-builder-co-2"></a><img src="images/callouts/2.gif" alt="2" border="0">

tar xvfz $src <a name="ex-hello-builder-co-3"></a><img src="images/callouts/3.gif" alt="3" border="0">
cd hello-*
./configure --prefix=$out <a name="ex-hello-builder-co-4"></a><img src="images/callouts/4.gif" alt="4" border="0">
make <a name="ex-hello-builder-co-5"></a><img src="images/callouts/5.gif" alt="5" border="0">
make install</pre></div></div><br class="example-break"><p><a class="xref" href="#ex-hello-builder" title="Example 5.2. Build script for GNU Hello (builder.sh)">Example 5.2, &#8220;Build script for GNU Hello
(<code class="filename">builder.sh</code>)&#8221;</a> shows the builder referenced
from Hello's Nix expression (stored in
<code class="filename">pkgs/applications/misc/hello/ex-1/builder.sh</code>).
The builder can actually be made a lot shorter by using the
<span class="emphasis"><em>generic builder</em></span> functions provided by
<code class="varname">stdenv</code>, but here we write out the build steps to
elucidate what a builder does.  It performs the following
steps:</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-builder-co-1"><img src="images/callouts/1.gif" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>When Nix runs a builder, it initially completely clears the
    environment (except for the attributes declared in the
    derivation).  For instance, the <code class="envar">PATH</code> variable is
    empty<sup>[<a name="id488809" href="#ftn.id488809" class="footnote">5</a>]</sup>.  This is done to prevent
    undeclared inputs from being used in the build process.  If for
    example the <code class="envar">PATH</code> contained
    <code class="filename">/usr/bin</code>, then you might accidentally use
    <code class="filename">/usr/bin/gcc</code>.</p><p>So the first step is to set up the environment.  This is
    done by calling the <code class="filename">setup</code> script of the
    standard environment.  The environment variable
    <code class="envar">stdenv</code> points to the location of the standard
    environment being used.  (It wasn't specified explicitly as an
    attribute in <a class="xref" href="#ex-hello-nix" title="Example 5.1. Nix expression for GNU Hello (default.nix)">Example 5.1, &#8220;Nix expression for GNU Hello
(<code class="filename">default.nix</code>)&#8221;</a>, but
    <code class="varname">mkDerivation</code> adds it automatically.)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-builder-co-2"><img src="images/callouts/2.gif" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>Since Hello needs Perl, we have to make sure that Perl is in
    the <code class="envar">PATH</code>.  The <code class="envar">perl</code> environment
    variable points to the location of the Perl package (since it
    was passed in as an attribute to the derivation), so
    <code class="filename"><em class="replaceable"><code>$perl</code></em>/bin</code> is the
    directory containing the Perl interpreter.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-builder-co-3"><img src="images/callouts/3.gif" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>Now we have to unpack the sources.  The
    <code class="varname">src</code> attribute was bound to the result of
    fetching the Hello source tarball from the network, so the
    <code class="envar">src</code> environment variable points to the location in
    the Nix store to which the tarball was downloaded.  After
    unpacking, we <span class="command"><strong>cd</strong></span> to the resulting source
    directory.</p><p>The whole build is performed in a temporary directory
    created in <code class="varname">/tmp</code>, by the way.  This directory is
    removed after the builder finishes, so there is no need to clean
    up the sources afterwards.  Also, the temporary directory is
    always newly created, so you don't have to worry about files from
    previous builds interfering with the current build.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-builder-co-4"><img src="images/callouts/4.gif" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>GNU Hello is a typical Autoconf-based package, so we first
    have to run its <code class="filename">configure</code> script.  In Nix
    every package is stored in a separate location in the Nix store,
    for instance
    <code class="filename">/nix/store/9a54ba97fb71b65fda531012d0443ce2-hello-2.1.1</code>.
    Nix computes this path by cryptographically hashing all attributes
    of the derivation.  The path is passed to the builder through the
    <code class="envar">out</code> environment variable.  So here we give
    <code class="filename">configure</code> the parameter
    <code class="literal">--prefix=$out</code> to cause Hello to be installed in
    the expected location.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-builder-co-5"><img src="images/callouts/5.gif" alt="5" border="0"></a> </p></td><td valign="top" align="left"><p>Finally we build Hello (<code class="literal">make</code>) and install
    it into the location specified by <code class="envar">out</code>
    (<code class="literal">make install</code>).</p></td></tr></table></div><p>If you are wondering about the absence of error checking on the
result of various commands called in the builder: this is because the
shell script is evaluated with Bash's <code class="option">-e</code> option,
which causes the script to be aborted if any command fails without an
error check.</p></div><div class="section" title="5.1.3. Composition"><div class="titlepage"><div><div><h3 class="title"><a name="id488656"></a>5.1.3. Composition</h3></div></div></div><div class="example"><a name="ex-hello-composition"></a><p class="title"><b>Example 5.3. Composing GNU Hello
(<code class="filename">all-packages.nix</code>)</b></p><div class="example-contents"><pre class="programlisting">
...

rec { <a name="ex-hello-composition-co-1"></a><img src="images/callouts/1.gif" alt="1" border="0">
  
  hello = (import ../applications/misc/hello/ex-1 <a name="ex-hello-composition-co-2"></a><img src="images/callouts/2.gif" alt="2" border="0">) { <a name="ex-hello-composition-co-3"></a><img src="images/callouts/3.gif" alt="3" border="0">
    inherit fetchurl stdenv perl;
  };

  perl = (import ../development/interpreters/perl) { <a name="ex-hello-composition-co-4"></a><img src="images/callouts/4.gif" alt="4" border="0">
    inherit fetchurl stdenv;
  };

  fetchurl = (import ../build-support/fetchurl) { 
    inherit stdenv; ...
  };
  
  stdenv = ...;

}
</pre></div></div><br class="example-break"><p>The Nix expression in <a class="xref" href="#ex-hello-nix" title="Example 5.1. Nix expression for GNU Hello (default.nix)">Example 5.1, &#8220;Nix expression for GNU Hello
(<code class="filename">default.nix</code>)&#8221;</a> is a
function; it is missing some arguments that have to be filled in
somewhere.  In the Nix Packages collection this is done in the file
<code class="filename">pkgs/top-level/all-packages.nix</code>, where all
Nix expressions for packages are imported and called with the
appropriate arguments.  <a class="xref" href="#ex-hello-composition" title="Example 5.3. Composing GNU Hello (all-packages.nix)">Example 5.3, &#8220;Composing GNU Hello
(<code class="filename">all-packages.nix</code>)&#8221;</a> shows
some fragments of
<code class="filename">all-packages.nix</code>.</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-composition-co-1"><img src="images/callouts/1.gif" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>This file defines a set of attributes, all of which are
    concrete derivations (i.e., not functions).  In fact, we define a
    <span class="emphasis"><em>mutually recursive</em></span> set of attributes.  That
    is, the attributes can refer to each other.  This is precisely
    what we want since we want to <span class="quote">&#8220;<span class="quote">plug</span>&#8221;</span> the
    various packages into each other.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-composition-co-2"><img src="images/callouts/2.gif" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>Here we <span class="emphasis"><em>import</em></span> the Nix expression for
    GNU Hello.  The import operation just loads and returns the
    specified Nix expression. In fact, we could just have put the
    contents of <a class="xref" href="#ex-hello-nix" title="Example 5.1. Nix expression for GNU Hello (default.nix)">Example 5.1, &#8220;Nix expression for GNU Hello
(<code class="filename">default.nix</code>)&#8221;</a> in
    <code class="filename">all-packages.nix</code> at this point.  That
    would be completely equivalent, but it would make the file rather
    bulky.</p><p>Note that we refer to
    <code class="filename">../applications/misc/hello/ex-1</code>, not
    <code class="filename">../applications/misc/hello/ex-1/default.nix</code>.
    When you try to import a directory, Nix automatically appends
    <code class="filename">/default.nix</code> to the file name.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-composition-co-3"><img src="images/callouts/3.gif" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>This is where the actual composition takes place.  Here we
    <span class="emphasis"><em>call</em></span> the function imported from
    <code class="filename">../applications/misc/hello/ex-1</code> with an
    attribute set containing the things that the function expects,
    namely <code class="varname">fetchurl</code>, <code class="varname">stdenv</code>, and
    <code class="varname">perl</code>.  We use inherit again to use the
    attributes defined in the surrounding scope (we could also have
    written <code class="literal">fetchurl = fetchurl;</code>, etc.).</p><p>The result of this function call is an actual derivation
    that can be built by Nix (since when we fill in the arguments of
    the function, what we get is its body, which is the call to
    <code class="varname">stdenv.mkDerivation</code> in <a class="xref" href="#ex-hello-nix" title="Example 5.1. Nix expression for GNU Hello (default.nix)">Example 5.1, &#8220;Nix expression for GNU Hello
(<code class="filename">default.nix</code>)&#8221;</a>).</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-composition-co-4"><img src="images/callouts/4.gif" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>Likewise, we have to instantiate Perl,
    <code class="varname">fetchurl</code>, and the standard environment.</p></td></tr></table></div></div><div class="section" title="5.1.4. Testing"><div class="titlepage"><div><div><h3 class="title"><a name="id488499"></a>5.1.4. Testing</h3></div></div></div><p>You can now try to build Hello.  Of course, you could do
<code class="literal">nix-env -f pkgs/top-level/all-packages.nix -i hello</code>,
but you may not want to install a possibly broken package just yet.
The best way to test the package is by using the command <span class="command"><strong><a class="command" href="#sec-nix-build" title="nix-build">nix-build</a></strong></span>, which builds a Nix
expression and creates a symlink named <code class="filename">result</code> in
the current directory:

</p><pre class="screen">
$ nix-build pkgs/top-level/all-packages.nix -A hello
building path `/nix/store/632d2b22514d...-hello-2.1.1'
hello-2.1.1/
hello-2.1.1/intl/
hello-2.1.1/intl/ChangeLog
<em class="replaceable"><code>...</code></em>

$ ls -l result
lrwxrwxrwx ... 2006-09-29 10:43 result -&gt; /nix/store/632d2b22514d...-hello-2.1.1

$ ./result/bin/hello
Hello, world!</pre><p>

The <a class="link" href="#opt-attr"><code class="option">-A</code></a> option selects
the <code class="literal">hello</code> attribute from
<code class="filename">all-packages.nix</code>.  This is faster than using the
symbolic package name specified by the <code class="literal">name</code>
attribute (which also happens to be <code class="literal">hello</code>) and is
unambiguous (there can be multiple packages with the symbolic name
<code class="literal">hello</code>, but there can be only one attribute in a set
named <code class="literal">hello</code>).</p><p><span class="command"><strong>nix-build</strong></span> registers the
<code class="filename">./result</code> symlink as a garbage collection root, so
unless and until you delete the <code class="filename">./result</code> symlink,
the output of the build will be safely kept on your system.  You can
use <span class="command"><strong>nix-build</strong></span>&#8217;s <code class="option"><a class="option" href="#opt-out-link">-o</a></code> switch to give the symlink another
name.</p><p>Nix has a transactional semantics.  Once a build finishes
successfully, Nix makes a note of this in its database: it registers
that the path denoted by <code class="envar">out</code> is now
<span class="quote">&#8220;<span class="quote">valid</span>&#8221;</span>.  If you try to build the derivation again, Nix
will see that the path is already valid and finish immediately.  If a
build fails, either because it returns a non-zero exit code, because
Nix or the builder are killed, or because the machine crashes, then
the output path will not be registered as valid.  If you try to build
the derivation again, Nix will remove the output path if it exists
(e.g., because the builder died half-way through <code class="literal">make
install</code>) and try again.  Note that there is no
<span class="quote">&#8220;<span class="quote">negative caching</span>&#8221;</span>: Nix doesn't remember that a build
failed, and so a failed build can always be repeated.  This is because
Nix cannot distinguish between permanent failures (e.g., a compiler
error due to a syntax error in the source) and transient failures
(e.g., a disk full condition).</p><p>Nix also performs locking.  If you run multiple Nix builds
simultaneously, and they try to build the same derivation, the first
Nix instance that gets there will perform the build, while the others
block (or perform other derivations if available) until the build
finishes:

</p><pre class="screen">
$ nix-build pkgs/top-level/all-packages.nix -A hello
waiting for lock on `/nix/store/0h5b7hp8d4hqfrw8igvx97x1xawrjnac-hello-2.1.1x'</pre><p>

So it is always safe to run multiple instances of Nix in parallel
(which isn&#8217;t the case with, say, <span class="command"><strong>make</strong></span>).</p><p>If you have a system with multiple CPUs, you may want to have
Nix build different derivations in parallel (insofar as possible).
Just pass the option <a class="link" href="#opt-max-jobs"><code class="option">-j
<em class="replaceable"><code>N</code></em></code></a>, where
<em class="replaceable"><code>N</code></em> is the maximum number of jobs to be run
in parallel, or set.  Typically this should be the number of
CPUs.</p></div><div class="section" title="5.1.5. The generic builder"><div class="titlepage"><div><div><h3 class="title"><a name="id488378"></a>5.1.5. The generic builder</h3></div></div></div><p>Recall from <a class="xref" href="#ex-hello-builder" title="Example 5.2. Build script for GNU Hello (builder.sh)">Example 5.2, &#8220;Build script for GNU Hello
(<code class="filename">builder.sh</code>)&#8221;</a> that the builder
looked something like this:

</p><pre class="programlisting">
PATH=$perl/bin:$PATH
tar xvfz $src
cd hello-*
./configure --prefix=$out
make
make install</pre><p>

The builders for almost all Unix packages look like this &#8212; set up some
environment variables, unpack the sources, configure, build, and
install.  For this reason the standard environment provides some Bash
functions that automate the build process.  A builder using the
generic build facilities in shown in <a class="xref" href="#ex-hello-builder2" title="Example 5.4. Build script using the generic build functions">Example 5.4, &#8220;Build script using the generic
build functions&#8221;</a>.</p><div class="example"><a name="ex-hello-builder2"></a><p class="title"><b>Example 5.4. Build script using the generic
build functions</b></p><div class="example-contents"><pre class="programlisting">
buildInputs="$perl" <a name="ex-hello-builder2-co-1"></a><img src="images/callouts/1.gif" alt="1" border="0">

source $stdenv/setup <a name="ex-hello-builder2-co-2"></a><img src="images/callouts/2.gif" alt="2" border="0">

genericBuild <a name="ex-hello-builder2-co-3"></a><img src="images/callouts/3.gif" alt="3" border="0"></pre></div></div><br class="example-break"><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-builder2-co-1"><img src="images/callouts/1.gif" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>The <code class="envar">buildInputs</code> variable tells
    <code class="filename">setup</code> to use the indicated packages as
    <span class="quote">&#8220;<span class="quote">inputs</span>&#8221;</span>.  This means that if a package provides a
    <code class="filename">bin</code> subdirectory, it's added to
    <code class="envar">PATH</code>; if it has a <code class="filename">include</code>
    subdirectory, it's added to GCC's header search path; and so
    on.<sup>[<a name="id488299" href="#ftn.id488299" class="footnote">6</a>]</sup>
    </p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-builder2-co-2"><img src="images/callouts/2.gif" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>The function <code class="function">genericBuild</code> is defined in
    the file <code class="literal">$stdenv/setup</code>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-hello-builder2-co-3"><img src="images/callouts/3.gif" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>The final step calls the shell function
    <code class="function">genericBuild</code>, which performs the steps that
    were done explicitly in <a class="xref" href="#ex-hello-builder" title="Example 5.2. Build script for GNU Hello (builder.sh)">Example 5.2, &#8220;Build script for GNU Hello
(<code class="filename">builder.sh</code>)&#8221;</a>.  The
    generic builder is smart enough to figure out whether to unpack
    the sources using <span class="command"><strong>gzip</strong></span>,
    <span class="command"><strong>bzip2</strong></span>, etc.  It can be customised in many ways;
    see <a class="xref" href="#sec-standard-environment" title="5.3. The standard environment">Section 5.3, &#8220;The standard environment&#8221;</a>.</p></td></tr></table></div><p>Discerning readers will note that the
<code class="envar">buildInputs</code> could just as well have been set in the Nix
expression, like this:

</p><pre class="programlisting">
  buildInputs = [perl];</pre><p>

The <code class="varname">perl</code> attribute can then be removed, and the
builder becomes even shorter:

</p><pre class="programlisting">
source $stdenv/setup
genericBuild</pre><p>

In fact, <code class="varname">mkDerivation</code> provides a default builder
that looks exactly like that, so it is actually possible to omit the
builder for Hello entirely.</p></div></div><div class="section" title="5.2. The Nix expression language"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id488220"></a>5.2. The Nix expression language</h2></div></div></div><p>The Nix expression language is a pure, lazy, functional
language.  Purity means that operations in the language don't have
side-effects (for instance, there is no variable assignment).
Laziness means that arguments to functions are evaluated only when
they are needed.  Functional means that functions are
<span class="quote">&#8220;<span class="quote">normal</span>&#8221;</span> values that can be passed around and manipulated
in interesting ways.  The language is not a full-featured, general
purpose language.  It's main job is to describe packages,
compositions of packages, and the variability within
packages.</p><p>This section presents the various features of the
language.</p><div class="section" title="5.2.1. Values"><div class="titlepage"><div><div><h3 class="title"><a name="ssec-values"></a>5.2.1. Values</h3></div></div></div><div class="simplesect" title="Simple values"><div class="titlepage"><div><div><h4 class="title"><a name="id488190"></a>Simple values</h4></div></div></div><p>Nix has the following basic data types:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Strings</em></span> can be written in three
    ways.</p><p>The most common way is to enclose the string between double
    quotes, e.g., <code class="literal">"foo bar"</code>.  Strings can span
    multiple lines.  The special characters <code class="literal">"</code> and
    <code class="literal">\</code> and the character sequence
    <code class="literal">${</code> must be escaped by prefixing them with a
    backslash (<code class="literal">\</code>).  Newlines, carriage returns and
    tabs can be written as <code class="literal">\n</code>,
    <code class="literal">\r</code> and <code class="literal">\t</code>,
    respectively.</p><p>You can include the result of an expression into a string by
    enclosing it in
    <code class="literal">${<em class="replaceable"><code>...</code></em>}</code>, a feature
    known as <span class="emphasis"><em>antiquotation</em></span>.  The enclosed
    expression must evaluate to something that can be coerced into a
    string (meaning that it must be a string, a path, or a
    derivation).  For instance, rather than writing

</p><pre class="programlisting">
"--with-freetype2-library=" + freetype + "/lib"</pre><p>

    (where <code class="varname">freetype</code> is a derivation), you can
    instead write the more natural

</p><pre class="programlisting">
"--with-freetype2-library=${freetype}/lib"</pre><p>

    The latter is automatically translated to the former.  A more
    complicated example (from the Nix expression for <a class="link" href="http://www.trolltech.com/products/qt" target="_top">Qt</a>):

</p><pre class="programlisting">
configureFlags = "
  -system-zlib -system-libpng -system-libjpeg
  ${if openglSupport then "-dlopen-opengl
    -L${mesa}/lib -I${mesa}/include
    -L${libXmu}/lib -I${libXmu}/include" else ""}
  ${if threadSupport then "-thread" else "-no-thread"}
";</pre><p>

    Note that Nix expressions and strings can be arbitrarily nested;
    in this case the outer string contains various antiquotations that
    themselves contain strings (e.g., <code class="literal">"-thread"</code>),
    some of which in turn contain expressions (e.g.,
    <code class="literal">${mesa}</code>).</p><p>The second way to write string literals is as an
    <span class="emphasis"><em>indented string</em></span>, which is enclosed between
    pairs of <span class="emphasis"><em>double single-quotes</em></span>, like so:

</p><pre class="programlisting">
''
  This is the first line.
  This is the second line.
    This is the third line.
''</pre><p>

    This kind of string literal intelligently strips indentation from
    the start of each line.  To be precise, it strips from each line a
    number of spaces equal to the minimal indentation of the string as
    a whole (disregarding the indentation of empty lines).  For
    instance, the first and second line are indented two space, while
    the third line is indented three spaces.  Thus, two spaces are
    stripped from each line, so the resulting string is

</p><pre class="programlisting">    
"This is the first line.\nThis is the second line.\n  This is the third line.\n"</pre><p>

    </p><p>Note that the whitespace and newline following the opening
    <code class="literal">''</code> is ignored if there is no non-whitespace
    text on the initial line.</p><p>Antiquotation
    (<code class="literal">${<em class="replaceable"><code>expr</code></em>}}</code>) is
    supported in indented strings.</p><p>Since <code class="literal">${</code> and <code class="literal">''</code> have
    special meaning in indented strings, you need a way to quote them.
    <code class="literal">${</code> can be escaped by prefixing it with
    <code class="literal">''</code>, i.e., <code class="literal">''${</code>.
    <code class="literal">''</code> can be escaped by prefixing it with
    <code class="literal">'</code>, i.e., <code class="literal">'''</code>.  Finally,
    linefeed, carriage-return and tab characters can be writted as
    <code class="literal">''\n</code>, <code class="literal">''\r</code>,
    <code class="literal">''\t</code>.</p><p>Indented strings are primarily useful in that they allow
    multi-line string literals to follow the indentation of the
    enclosing Nix expression, and that less escaping is typically
    necessary for strings representing languages such as shell scripts
    and configuration files because <code class="literal">''</code> is much less
    common than <code class="literal">"</code>.  Example:

</p><pre class="programlisting">
stdenv.mkDerivation {
  <em class="replaceable"><code>...</code></em>
  postInstall =
    ''
      mkdir $out/bin $out/etc
      cp foo $out/bin
      echo "Hello World" &gt; $out/etc/foo.conf
      ${if enableBar then "cp bar $out/bin" else ""}
    '';
  <em class="replaceable"><code>...</code></em>
}    
</pre><p>

    </p><p>Finally, as a convenience, <span class="emphasis"><em>URIs</em></span> as
    defined in appendix B of <a class="link" href="http://www.ietf.org/rfc/rfc2396.txt" target="_top">RFC 2396</a>
    can be written <span class="emphasis"><em>as is</em></span>, without quotes.  For
    instance, the string
    <code class="literal">"http://example.org/foo.tar.bz2"</code>
    can also be written as
    <code class="literal">http://example.org/foo.tar.bz2</code>.</p></li><li class="listitem"><p><span class="emphasis"><em>Integers</em></span>, e.g.,
  <code class="literal">123</code>.</p></li><li class="listitem"><p><span class="emphasis"><em>Paths</em></span>, e.g.,
  <code class="filename">/bin/sh</code> or <code class="filename">./builder.sh</code>.
  A path must contain at least one slash to be recognised as such; for
  instance, <code class="filename">builder.sh</code> is not a
  path<sup>[<a name="id487938" href="#ftn.id487938" class="footnote">7</a>]</sup>.  If the file name is
  relative, i.e., if it does not begin with a slash, it is made
  absolute at parse time relative to the directory of the Nix
  expression that contained it.  For instance, if a Nix expression in
  <code class="filename">/foo/bar/bla.nix</code> refers to
  <code class="filename">../xyzzy/fnord.nix</code>, the absolutised path is
  <code class="filename">/foo/xyzzy/fnord.nix</code>.</p></li><li class="listitem"><p><span class="emphasis"><em>Booleans</em></span> with values
  <code class="literal">true</code> and
  <code class="literal">false</code>.</p></li></ul></div><p>

</p></div><div class="simplesect" title="Lists"><div class="titlepage"><div><div><h4 class="title"><a name="id487888"></a>Lists</h4></div></div></div><p>Lists are formed by enclosing a whitespace-separated list of
values between square brackets.  For example,

</p><pre class="programlisting">
[ 123 ./foo.nix "abc" (f {x=y;}) ]</pre><p>

defines a list of four elements, the last being the result of a call
to the function <code class="varname">f</code>.  Note that function calls have
to be enclosed in parentheses.  If they had been omitted, e.g.,

</p><pre class="programlisting">
[ 123 ./foo.nix "abc" f {x=y;} ]</pre><p>

the result would be a list of five elements, the fourth one being a
function and the fifth being an attribute set.</p></div><div class="simplesect" title="Attribute sets"><div class="titlepage"><div><div><h4 class="title"><a name="id487867"></a>Attribute sets</h4></div></div></div><p>Attribute sets are really the core of the language, since
ultimately it's all about creating derivations, which are really just
sets of attributes to be passed to build scripts.</p><p>Attribute sets are just a list of name/value pairs enclosed in
curly brackets, where each value is an arbitrary expression terminated
by a semicolon.  For example:

</p><pre class="programlisting">
{ x = 123;
  text = "Hello";
  y = f { bla = 456; };
}</pre><p>

This defines an attribute set with attributes named
<code class="varname">x</code>, <code class="varname">test</code>, <code class="varname">y</code>.
The order of the attributes is irrelevant.  An attribute name may only
occur once.</p><p>Attributes can be selected from an attribute set using the
<code class="literal">.</code> operator.  For instance,

</p><pre class="programlisting">
{ a = "Foo"; b = "Bar"; }.a</pre><p>

evaluates to <code class="literal">"Foo"</code>.</p></div></div><div class="section" title="5.2.2. Language constructs"><div class="titlepage"><div><div><h3 class="title"><a name="id487820"></a>5.2.2. Language constructs</h3></div></div></div><div class="simplesect" title="Recursive attribute sets"><div class="titlepage"><div><div><h4 class="title"><a name="id487818"></a>Recursive attribute sets</h4></div></div></div><p>Recursive attribute sets are just normal attribute sets, but the
attributes can refer to each other.  For example,

</p><pre class="programlisting">
rec {
  x = y;
  y = 123;
}.x
</pre><p>

evaluates to <code class="literal">123</code>.  Note that without
<code class="literal">rec</code> the binding <code class="literal">x = y;</code> would
refer to the variable <code class="varname">y</code> in the surrounding scope,
if one exists, and would be invalid if no such variable exists.  That
is, in a normal (non-recursive) attribute set, attributes are not
added to the lexical scope; in a recursive set, they are.</p><p>Recursive attribute sets of course introduce the danger of
infinite recursion.  For example,

</p><pre class="programlisting">
rec {
  x = y;
  y = x;
}.x</pre><p>

does not terminate<sup>[<a name="id487775" href="#ftn.id487775" class="footnote">8</a>]</sup>.</p></div><div class="simplesect" title="Let-expressions"><div class="titlepage"><div><div><h4 class="title"><a name="id487768"></a>Let-expressions</h4></div></div></div><p>A let-expression allows you define local
variables for an expression.  For instance,

</p><pre class="programlisting">
let
  x = "foo";
  y = "bar";
in x + y</pre><p>

evaluates to <code class="literal">"foobar"</code>.

</p><div class="note" title="Note"><h3 class="title">Note</h3><p>There is also an obsolete form of let-expression,
<code class="literal">let { <em class="replaceable"><code>attrs</code></em> }</code>, which is
translated to <code class="literal">rec { <em class="replaceable"><code>attrs</code></em>
}.body</code>.  That is, the body of the let-expression is the
<code class="literal">body</code> attribute of the attribute set.</p></div></div><div class="simplesect" title="Inheriting attributes"><div class="titlepage"><div><div><h4 class="title"><a name="id484132"></a>Inheriting attributes</h4></div></div></div><p>When defining an attribute set it is often convenient to copy
variables from the surrounding lexical scope (e.g., when you want to
propagate attributes).  This can be shortened using the
<code class="literal">inherit</code> keyword.  For instance,

</p><pre class="programlisting">
let
  x = 123;
in 
  {
    inherit x;
    y = 456;
  }</pre><p>

evaluates to <code class="literal">{x = 123; y = 456;}</code>.  (Note that this
works because <code class="varname">x</code> is added to the lexical scope by
the <code class="literal">let</code> construct.)  It is also possible to inherit
attributes from another attribute set.  For instance, in this fragment
from <code class="filename">all-packages.nix</code>,

</p><pre class="programlisting">
  graphviz = (import ../tools/graphics/graphviz) {
    inherit fetchurl stdenv libpng libjpeg expat x11 yacc;
    inherit (xlibs) libXaw;
  };

  xlibs = {
    libX11 = ...;
    libXaw = ...;
    ...
  }

  libpng = ...;
  libjpg = ...;
  ...</pre><p>

the attribute set used in the function call to the function defined in
<code class="filename">../tools/graphics/graphviz</code> inherits a number of
variables from the surrounding scope (<code class="varname">fetchurl</code>
... <code class="varname">yacc</code>), but also inherits
<code class="varname">libXaw</code> (the X Athena Widgets) from the
<code class="varname">xlibs</code> (X11 client-side libraries) attribute
set.</p></div><div class="simplesect" title="Functions"><div class="titlepage"><div><div><h4 class="title"><a name="ss-functions"></a>Functions</h4></div></div></div><p>Functions have the following form:

</p><pre class="programlisting">
<em class="replaceable"><code>pattern</code></em>: <em class="replaceable"><code>body</code></em></pre><p>

The pattern specifies what the argument of the function must look
like, and binds variables in the body to (parts of) the
argument.  There are three kinds of patterns:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If a pattern is a single identifier, then the
  function matches any argument.  Example:

  </p><pre class="programlisting">
let negate = x: !x;
    concat = x: y: x + y;
in if negate true then concat "foo" "bar" else ""</pre><p>

  Note that <code class="function">concat</code> is a function that takes one
  argument and returns a function that takes another argument.  This
  allows partial parameterisation (i.e., only filling some of the
  arguments of a function); e.g.,

  </p><pre class="programlisting">
map (concat "foo") ["bar" "bla" "abc"]</pre><p>

  evaluates to <code class="literal">["foobar" "foobla"
  "fooabc"]</code>.</p></li><li class="listitem"><p>An <span class="emphasis"><em>attribute set pattern</em></span> of the
  form <code class="literal">{name1, name2, &#8230;, nameN}</code>
  matches an attribute set containing the listed attributes, and binds
  the values of those attributes to variables in the function body.
  For example, the function

</p><pre class="programlisting">
{x, y, z}: z + y + x</pre><p>

  can only be called with a set containing exactly the attributes
  <code class="varname">x</code>, <code class="varname">y</code> and
  <code class="varname">z</code>.  No other attributes are allowed.  If you want
  to allow additional arguments, you can use an ellipsis
  (<code class="literal">...</code>): 

</p><pre class="programlisting">
{x, y, z, ....}: z + y + x</pre><p>

  This works on any set that contains at least the three named
  attributes.</p><p>It is possible to provide <span class="emphasis"><em>default values</em></span>
  for attributes, in which case they are allowed to be missing.  A
  default value is specified by writing
  <code class="literal"><em class="replaceable"><code>name</code></em> ?
  <em class="replaceable"><code>e</code></em></code>, where
  <em class="replaceable"><code>e</code></em> is an arbitrary expression.  For example,

</p><pre class="programlisting">
{x, y ? "foo", z ? "bar"}: z + y + x</pre><p>

  specifies a function that only requires an attribute named
  <code class="varname">x</code>, but optionally accepts <code class="varname">y</code>
  and <code class="varname">z</code>.</p></li><li class="listitem"><p>An <code class="literal">@</code>-pattern requires that the
  argument matches with the patterns on the left- and right-hand side
  of the <code class="literal">@</code>-sign.  For example:

</p><pre class="programlisting">
args@{x, y, z, ...}: z + y + x + args.a</pre><p>

  Here <code class="varname">args</code> is bound to the entire argument, which
  is further matches against the pattern <code class="literal">{x, y, z,
  ...}</code>.</p></li></ul></div><p>Note that functions do not have names.  If you want to give them
a name, you can bind them to an attribute, e.g.,

</p><pre class="programlisting">
let concat = {x, y}: x + y;
in concat {x = "foo"; y = "bar";}</pre><p>

</p></div><div class="simplesect" title="Conditionals"><div class="titlepage"><div><div><h4 class="title"><a name="id490821"></a>Conditionals</h4></div></div></div><p>Conditionals look like this:

</p><pre class="programlisting">
if <em class="replaceable"><code>e1</code></em> then <em class="replaceable"><code>e2</code></em> else <em class="replaceable"><code>e3</code></em></pre><p>

where <em class="replaceable"><code>e1</code></em> is an expression that should
evaluate to a Boolean value (<code class="literal">true</code> or
<code class="literal">false</code>).</p></div><div class="simplesect" title="Assertions"><div class="titlepage"><div><div><h4 class="title"><a name="id490856"></a>Assertions</h4></div></div></div><p>Assertions are generally used to check that certain requirements
on or between features and dependencies hold.  They look like this:

</p><pre class="programlisting">
assert <em class="replaceable"><code>e1</code></em>; <em class="replaceable"><code>e2</code></em></pre><p>

where <em class="replaceable"><code>e1</code></em> is an expression that should
evaluate to a Boolean value.  If it evaluates to
<code class="literal">true</code>, <em class="replaceable"><code>e2</code></em> is returned;
otherwise expression evaluation is aborted and a backtrace is printed.</p><div class="example"><a name="ex-subversion-nix"></a><p class="title"><b>Example 5.5. Nix expression for Subversion</b></p><div class="example-contents"><pre class="programlisting">
{ localServer ? false
, httpServer ? false
, sslSupport ? false
, pythonBindings ? false
, javaSwigBindings ? false
, javahlBindings ? false
, stdenv, fetchurl
, openssl ? null, httpd ? null, db4 ? null, expat, swig ? null, j2sdk ? null
}:

assert localServer -&gt; db4 != null; <a name="ex-subversion-nix-co-1"></a><img src="images/callouts/1.gif" alt="1" border="0">
assert httpServer -&gt; httpd != null &amp;&amp; httpd.expat == expat; <a name="ex-subversion-nix-co-2"></a><img src="images/callouts/2.gif" alt="2" border="0">
assert sslSupport -&gt; openssl != null &amp;&amp; (httpServer -&gt; httpd.openssl == openssl); <a name="ex-subversion-nix-co-3"></a><img src="images/callouts/3.gif" alt="3" border="0">
assert pythonBindings -&gt; swig != null &amp;&amp; swig.pythonSupport;
assert javaSwigBindings -&gt; swig != null &amp;&amp; swig.javaSupport;
assert javahlBindings -&gt; j2sdk != null;

stdenv.mkDerivation {
  name = "subversion-1.1.1";
  ...
  openssl = if sslSupport then openssl else null; <a name="ex-subversion-nix-co-4"></a><img src="images/callouts/4.gif" alt="4" border="0">
  ...
}</pre></div></div><br class="example-break"><p><a class="xref" href="#ex-subversion-nix" title="Example 5.5. Nix expression for Subversion">Example 5.5, &#8220;Nix expression for Subversion&#8221;</a> show how assertions are
used in the Nix expression for Subversion.</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#ex-subversion-nix-co-1"><img src="images/callouts/1.gif" alt="1" border="0"></a> </p></td><td valign="top" align="left"><p>This assertion states that if Subversion is to have support
    for local repositories, then Berkeley DB is needed.  So if the
    Subversion function is called with the
    <code class="varname">localServer</code> argument set to
    <code class="literal">true</code> but the <code class="varname">db4</code> argument
    set to <code class="literal">null</code>, then the evaluation fails.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-subversion-nix-co-2"><img src="images/callouts/2.gif" alt="2" border="0"></a> </p></td><td valign="top" align="left"><p>This is a more subtle condition: if Subversion is built with
    Apache (<code class="literal">httpServer</code>) support, then the Expat
    library (an XML library) used by Subversion should be same as the
    one used by Apache.  This is because in this configuration
    Subversion code ends up being linked with Apache code, and if the
    Expat libraries do not match, a build- or runtime link error or
    incompatibility might occur.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-subversion-nix-co-3"><img src="images/callouts/3.gif" alt="3" border="0"></a> </p></td><td valign="top" align="left"><p>This assertion says that in order for Subversion to have SSL
    support (so that it can access <code class="literal">https</code> URLs), an
    OpenSSL library must be passed.  Additionally, it says that
    <span class="emphasis"><em>if</em></span> Apache support is enabled, then Apache's
    OpenSSL should match Subversion's.  (Note that if Apache support
    is not enabled, we don't care about Apache's OpenSSL.)</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex-subversion-nix-co-4"><img src="images/callouts/4.gif" alt="4" border="0"></a> </p></td><td valign="top" align="left"><p>The conditional here is not really related to assertions,
    but is worth pointing out: it ensures that if SSL support is
    disabled, then the Subversion derivation is not dependent on
    OpenSSL, even if a non-<code class="literal">null</code> value was passed.
    This prevents an unnecessary rebuild of Subversion if OpenSSL
    changes.</p></td></tr></table></div></div><div class="simplesect" title="With-expressions"><div class="titlepage"><div><div><h4 class="title"><a name="id491019"></a>With-expressions</h4></div></div></div><p>A <span class="emphasis"><em>with-expression</em></span>,

</p><pre class="programlisting">
with <em class="replaceable"><code>e1</code></em>; <em class="replaceable"><code>e2</code></em></pre><p>

introduces the attribute set <em class="replaceable"><code>e1</code></em> into the
lexical scope of the expression <em class="replaceable"><code>e2</code></em>.  For
instance,

</p><pre class="programlisting">
let as = {x = "foo"; y = "bar";};
in with as; x + y</pre><p>

evaluates to <code class="literal">"foobar"</code> since the
<code class="literal">with</code> adds the <code class="varname">x</code> and
<code class="varname">y</code> attributes of <code class="varname">as</code> to the
lexical scope in the expression <code class="literal">x + y</code>.  The most
common use of <code class="literal">with</code> is in conjunction with the
<code class="function">import</code> function.  E.g.,

</p><pre class="programlisting">
with (import ./definitions.nix); ...</pre><p>

makes all attributes defined in the file
<code class="filename">definitions.nix</code> available as if they were defined
locally in a <code class="literal">rec</code>-expression.</p></div><div class="simplesect" title="Comments"><div class="titlepage"><div><div><h4 class="title"><a name="id491097"></a>Comments</h4></div></div></div><p>Comments can be single-line, started with a <code class="literal">#</code>
character, or inline/multi-line, enclosed within <code class="literal">/*
... */</code>.</p></div></div><div class="section" title="5.2.3. Operators"><div class="titlepage"><div><div><h3 class="title"><a name="id491116"></a>5.2.3. Operators</h3></div></div></div><p><a class="xref" href="#table-operators" title="Table 5.1. Operators">Table 5.1, &#8220;Operators&#8221;</a> lists the operators in the
Nix expression language, in order of precedence (from strongest to
weakest binding).</p><div class="table"><a name="table-operators"></a><p class="title"><b>Table 5.1. Operators</b></p><div class="table-contents"><table summary="Operators" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Syntax</th><th>Associativity</th><th>Description</th></tr></thead><tbody><tr><td><em class="replaceable"><code>e</code></em> .
        <em class="replaceable"><code>id</code></em></td><td>none</td><td>Select attribute named <em class="replaceable"><code>id</code></em>
        from attribute set <em class="replaceable"><code>e</code></em>.  Abort
        evaluation if the attribute doesn&#8217;t exist.</td></tr><tr><td><em class="replaceable"><code>e1</code></em> <em class="replaceable"><code>e2</code></em></td><td>left</td><td>Call function <em class="replaceable"><code>e1</code></em> with
        argument <em class="replaceable"><code>e2</code></em>.</td></tr><tr><td><em class="replaceable"><code>e</code></em> ?
        <em class="replaceable"><code>id</code></em></td><td>none</td><td>Test whether attribute set <em class="replaceable"><code>e</code></em>
        contains an attribute named <em class="replaceable"><code>id</code></em>;
        return <code class="literal">true</code> or
        <code class="literal">false</code>.</td></tr><tr><td><em class="replaceable"><code>e1</code></em> ++ <em class="replaceable"><code>e2</code></em></td><td>right</td><td>List concatenation.</td></tr><tr><td><em class="replaceable"><code>e1</code></em> + <em class="replaceable"><code>e2</code></em></td><td>left</td><td>String or path concatenation.</td></tr><tr><td>! <em class="replaceable"><code>e</code></em></td><td>left</td><td>Boolean negation.</td></tr><tr><td><em class="replaceable"><code>e1</code></em> //
        <em class="replaceable"><code>e2</code></em></td><td>right</td><td>Return an attribute set consisting of the attributes in
        <em class="replaceable"><code>e1</code></em> and
        <em class="replaceable"><code>e2</code></em> (with the latter taking
        precedence over the former in case of equally named attributes).</td></tr><tr><td><em class="replaceable"><code>e1</code></em> ==
        <em class="replaceable"><code>e2</code></em></td><td>none</td><td>Equality.</td></tr><tr><td><em class="replaceable"><code>e1</code></em> !=
        <em class="replaceable"><code>e2</code></em></td><td>none</td><td>Inequality.</td></tr><tr><td><em class="replaceable"><code>e1</code></em> &amp;&amp;
        <em class="replaceable"><code>e2</code></em></td><td>left</td><td>Logical AND.</td></tr><tr><td><em class="replaceable"><code>e1</code></em> ||
        <em class="replaceable"><code>e2</code></em></td><td>left</td><td>Logical OR.</td></tr><tr><td><em class="replaceable"><code>e1</code></em> -&gt;
        <em class="replaceable"><code>e2</code></em></td><td>none</td><td>Logical implication (equivalent to
        <code class="literal">!<em class="replaceable"><code>e1</code></em> ||
        <em class="replaceable"><code>e2</code></em></code>).</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="5.2.4. Derivations"><div class="titlepage"><div><div><h3 class="title"><a name="ssec-derivation"></a>5.2.4. Derivations</h3></div></div></div><p>The most important built-in function is
<code class="function">derivation</code>, which is used to describe a
single derivation (a build action).  It takes as input an attribute
set, the attributes of which specify the inputs of the build.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a name="attr-system"></a>There must be an attribute named
  <code class="varname">system</code> whose value must be a string specifying a
  Nix platform identifier, such as <code class="literal">"i686-linux"</code> or
  <code class="literal">"powerpc-darwin"</code><sup>[<a name="id491489" href="#ftn.id491489" class="footnote">9</a>]</sup> The build
  can only be performed on a machine and operating system matching the
  platform identifier.  (Nix can automatically forward builds for
  other platforms by forwarding them to other machines; see <a class="xref" href="#sec-distributed-builds" title="6.2. Setting up distributed builds">Section 6.2, &#8220;Setting up distributed builds&#8221;</a>.)</p></li><li class="listitem"><p>There must be an attribute named
  <code class="varname">name</code> whose value must be a string.  This is used
  as a symbolic name for the package by <span class="command"><strong>nix-env</strong></span>,
  and it is appended to the hash in the output path of the
  derivation.</p></li><li class="listitem"><p>There must be an attribute named
  <code class="varname">builder</code> that identifies the program that is
  executed to perform the build.  It can be either a derivation or a
  source (a local file reference, e.g.,
  <code class="filename">./builder.sh</code>).</p></li><li class="listitem"><p>Every attribute is passed as an environment variable
  to the builder.  Attribute values are translated to environment
  variables as follows:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Strings, URIs, and integers are just passed
      verbatim.</p></li><li class="listitem"><p>A <span class="emphasis"><em>path</em></span> (e.g.,
      <code class="filename">../foo/sources.tar</code>) causes the referenced
      file to be copied to the store; its location in the store is put
      in the environment variable.  The idea is that all sources
      should reside in the Nix store, since all inputs to a derivation
      should reside in the Nix store.</p></li><li class="listitem"><p>A <span class="emphasis"><em>derivation</em></span> causes that
      derivation to be built prior to the present derivation; the
      output path is put in the environment
      variable.</p></li><li class="listitem"><p>Lists of the previous types are also allowed.
      They are simply concatenated, separated by
      spaces.</p></li><li class="listitem"><p><code class="literal">true</code> is passed as the string
      <code class="literal">1</code>, <code class="literal">false</code> and
      <code class="literal">null</code> are passed as an empty string.
      </p></li></ul></div><p>

  </p></li><li class="listitem"><p>The optional attribute <code class="varname">args</code>
  specifies command-line arguments to be passed to the builder.  It
  should be a list.</p></li></ul></div><p>(Note that <code class="function">mkDerivation</code> in the standard
environment is a wrapper around <code class="function">derivation</code> that
adds a default value for <code class="varname">system</code> and always uses
Bash as the builder, to which the supplied builder is passed as a
command-line argument.  See <a class="xref" href="#sec-standard-environment" title="5.3. The standard environment">Section 5.3, &#8220;The standard environment&#8221;</a>.)</p><p>The builder is executed as follows:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A temporary directory is created under the directory
  specified by <code class="envar">TMPDIR</code> (default
  <code class="filename">/tmp</code>) where the build will take place.  The
  current directory is changed to this directory.</p></li><li class="listitem"><p>The environment is cleared and set to the derivation
  attributes, as specified above.</p></li><li class="listitem"><p>In addition, the following variables are set:

  </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><code class="envar">NIX_BUILD_TOP</code> contains the path of
    the temporary directory for this build.</p></li><li class="listitem"><p>Also, <code class="envar">TMPDIR</code>,
    <code class="envar">TEMPDIR</code>, <code class="envar">TMP</code>, <code class="envar">TEMP</code>
    are set to point to the temporary directory.  This is to prevent
    the builder from accidentally writing temporary files anywhere
    else.  Doing so might cause interference by other
    processes.</p></li><li class="listitem"><p><code class="envar">PATH</code> is set to
    <code class="filename">/path-not-set</code> to prevent shells from
    initialising it to their built-in default value.</p></li><li class="listitem"><p><code class="envar">HOME</code> is set to
    <code class="filename">/homeless-shelter</code> to prevent programs from
    using <code class="filename">/etc/passwd</code> or the like to find the
    user's home directory, which could cause impurity.  Usually, when
    <code class="envar">HOME</code> is set, it is used as the location of the home
    directory, even if it points to a non-existent
    path.</p></li><li class="listitem"><p><code class="envar">NIX_STORE</code> is set to the path of the
    top-level Nix store directory (typically,
    <code class="filename">/nix/store</code>).</p></li><li class="listitem"><p><code class="envar">out</code> is set to point to the output
    path of the derivation, which is a subdirectory of the Nix store.
    The output path is a concatenation of the cryptographic hash of
    all build inputs, and the <code class="varname">name</code>
    attribute.</p></li></ul></div><p>

  </p></li><li class="listitem"><p>If the output path already exists, it is removed.
  Also, locks are acquired to prevent multiple Nix instances from
  performing the same build at the same time.</p></li><li class="listitem"><p>A log of the combined standard output and error is
  written to <code class="filename">/nix/var/log/nix</code>.</p></li><li class="listitem"><p>The builder is executed with the arguments specified
  by the attribute <code class="varname">args</code>.  If it exits with exit
  code 0, it is considered to have succeeded.</p></li><li class="listitem"><p>The temporary directory is removed (unless the
  <code class="option">-K</code> option was specified).</p></li><li class="listitem"><p>If the build was successful, Nix scans the output
  for references to the paths of the inputs.  These so-called
  <span class="emphasis"><em>retained dependencies</em></span> could be used when the
  output of the derivation is used (e.g., when it's executed or used
  as input to another derivation), so if we deploy the derivation, we
  should copy the retained dependencies as well.  The scan is
  performed by looking for the hash parts of file names of the
  inputs.</p></li><li class="listitem"><p>After the build, Nix sets the last-modified
  timestamp on all files in the build result to 1 (00:00:01 1/1/1970
  UTC), sets the group to the default group, and sets the mode of the
  file to 0444 or 0555 (i.e., read-only, with execute permission
  enabled if the file was originally executable).  Note that possible
  <code class="literal">setuid</code> and <code class="literal">setgid</code> bits are
  cleared.  Setuid and setgid programs are not currently supported by
  Nix.  This is because the Nix archives used in deployment have no
  concept of ownership information, and because it makes the build
  result dependent on the user performing the build.</p></li></ul></div><p>

</p><div class="section" title="5.2.4.1. Advanced attributes"><div class="titlepage"><div><div><h4 class="title"><a name="id491813"></a>5.2.4.1. Advanced attributes</h4></div></div></div><p>Derivations can declare some infrequently used optional
attributes.</p><div class="variablelist"><dl><dt><span class="term"><code class="varname">allowedReferences</code></span></dt><dd><p>The optional attribute
    <code class="varname">allowedReferences</code> specifies a list of legal
    references (dependencies) of the output of the builder.  For
    example,

</p><pre class="programlisting">
allowedReferences = [];
</pre><p>

    enforces that the output of a derivation cannot have any runtime
    dependencies on its inputs.  This is used in NixOS to check that
    generated files such as initial ramdisks for booting Linux don&#8217;t
    have accidental dependencies on other paths in the Nix
    store.</p></dd><dt><span class="term"><code class="varname">exportReferencesGraph</code></span></dt><dd><p>This attribute allows builders access to the
    references graph of their inputs.  The attribute is a list of
    inputs in the Nix store whose references graph the builder needs
    to know.  The value of this attribute should be a list of pairs
    <code class="literal">[<em class="replaceable"><code>name1</code></em>
    <em class="replaceable"><code>path1</code></em> <em class="replaceable"><code>name2</code></em>
    <em class="replaceable"><code>path2</code></em>
    <em class="replaceable"><code>...</code></em>]</code>.  The references graph
    of each <em class="replaceable"><code>pathN</code></em> will be stored in a text
    file <em class="replaceable"><code>nameN</code></em> in the temporary build
    directory.  The text files have the format used by
    <span class="command"><strong>nix-store --register-validity</strong></span> (with the deriver
    fields left empty).  For example, when the following derivation is
    built:

</p><pre class="programlisting">
derivation {
  ...
  exportReferencesGraph = ["libfoo-graph" libfoo];
};
</pre><p>

    the references graph of <code class="literal">libfoo</code> is placed in the
    file <code class="filename">libfoo-graph</code> in the temporary build
    directory.</p><p><code class="varname">exportReferencesGraph</code> is useful for
    builders that want to do something with the closure of a store
    path.  Examples include the builders in NixOS that generate the
    initial ramdisk for booting Linux (a <span class="command"><strong>cpio</strong></span>
    archive containing the closure of the boot script) and the
    ISO-9660 image for the installation CD (which is populated with a
    Nix store containing the closure of a bootable NixOS
    configuration).</p></dd><dt><a name="fixed-output-drvs"></a><span class="term"><code class="varname">outputHash</code>, </span><span class="term"><code class="varname">outputHashAlgo</code>, </span><span class="term"><code class="varname">outputHashMode</code></span></dt><dd><p>These attributes declare that the derivation is a
    so-called <span class="emphasis"><em>fixed-output derivation</em></span>, which
    means that a cryptographic hash of the output is already known in
    advance.  When the build of a fixed-output derivation finishes,
    Nix computes the cryptographic hash of the output and compares it
    to the hash declared with these attributes.  If there is a
    mismatch, the build fails.</p><p>The rationale for fixed-output derivations is derivations
    such as those produced by the <code class="function">fetchurl</code>
    function.  This function downloads a file from a given URL.  To
    ensure that the downloaded file has not been modified, the caller
    must also specify a cryptographic hash of the file.  For example,

</p><pre class="programlisting">
fetchurl {
  url = http://ftp.gnu.org/pub/gnu/hello/hello-2.1.1.tar.gz;
  md5 = "70c9ccf9fac07f762c24f2df2290784d";
}
</pre><p>

    It sometimes happens that the URL of the file changes, e.g.,
    because servers are reorganised or no longer available.  We then
    must update the call to <code class="function">fetchurl</code>, e.g.,

</p><pre class="programlisting">
fetchurl {
  url = ftp://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz;
  md5 = "70c9ccf9fac07f762c24f2df2290784d";
}
</pre><p>

    If a <code class="function">fetchurl</code> derivation was treated like a
    normal derivation, the output paths of the derivation and
    <span class="emphasis"><em>all derivations depending on it</em></span> would change.
    For instance, if we were to change the URL of the Glibc source
    distribution in Nixpkgs (a package on which almost all other
    packages depend) massive rebuilds would be needed.  This is
    unfortunate for a change which we know cannot have a real effect
    as it propagates upwards through the dependency graph.</p><p>For fixed-output derivations, on the other hand, the name of
    the output path only depends on the <code class="varname">outputHash*</code>
    and <code class="varname">name</code> attributes, while all other attributes
    are ignored for the purpose of computing the output path.  (The
    <code class="varname">name</code> attribute is included because it is part
    of the path.)</p><p>As an example, here is the (simplified) Nix expression for
    <code class="varname">fetchurl</code>:

</p><pre class="programlisting">
{stdenv, curl}: # The <span class="command"><strong>curl</strong></span> program is used for downloading.

{url, md5}:

stdenv.mkDerivation {
  name = baseNameOf (toString url);
  builder = ./builder.sh;
  buildInputs = [curl];

  # This is a fixed-output derivation; the output must be a regular
  # file with MD5 hash <code class="varname">md5</code>.
  outputHashMode = "flat";
  outputHashAlgo = "md5";
  outputHash = md5;
  
  inherit url;
}
</pre><p>

    </p><p>The <code class="varname">outputHashAlgo</code> attribute specifies
    the hash algorithm used to compute the hash.  It can currently be
    <code class="literal">"md5"</code>, <code class="literal">"sha1"</code> or
    <code class="literal">"sha256"</code>.</p><p>The <code class="varname">outputHashMode</code> attribute determines
    how the hash is computed.  It must be one of the following two
    values:

    </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">"flat"</code></span></dt><dd><p>The output must be a non-executable regular
        file.  If it isn&#8217;t, the build fails.  The hash is simply
        computed over the contents of that file (so it&#8217;s equal to what
        Unix commands like <span class="command"><strong>md5sum</strong></span> or
        <span class="command"><strong>sha1sum</strong></span> produce).</p><p>This is the default.</p></dd><dt><span class="term"><code class="literal">"recursive"</code></span></dt><dd><p>The hash is computed over the NAR archive dump
        of the output (i.e., the result of <a class="link" href="#refsec-nix-store-dump" title="Operation --dump"><span class="command"><strong>nix-store
        --dump</strong></span></a>).  In this case, the output can be
        anything, including a directory tree.</p></dd></dl></div><p>

    </p><p>The <code class="varname">outputHash</code> attribute, finally, must
    be a string containing the hash in either hexadecimal or base-32
    notation.  (See the <a class="link" href="#sec-nix-hash" title="nix-hash"><span class="command"><strong>nix-hash</strong></span> command</a>
    for information about converting to and from base-32
    notation.)</p></dd><dt><span class="term"><code class="varname">impureEnvVars</code></span></dt><dd><p>This attribute allows you to specify a list of
    environment variables that should be passed from the environment
    of the calling user to the builder.  Usually, the environment is
    cleared completely when the builder is executed, but with this
    attribute you can allow specific environment variables to be
    passed unmodified.  For example, <code class="function">fetchurl</code> in
    Nixpkgs has the line

</p><pre class="programlisting">
impureEnvVars = ["http_proxy" "https_proxy" <em class="replaceable"><code>...</code></em>];
</pre><p>

    to make it use the proxy server configuration specified by the
    user in the environment variables <code class="envar">http_proxy</code> and
    friends.</p><p>This attribute is only allowed in <a class="link" href="#fixed-output-drvs">fixed-output derivations</a>, where
    impurities such as these are okay since (the hash of) the output
    is known in advance.  It is ignored for all other
    derivations.</p></dd></dl></div></div></div><div class="section" title="5.2.5. Built-in functions"><div class="titlepage"><div><div><h3 class="title"><a name="ssec-builtins"></a>5.2.5. Built-in functions</h3></div></div></div><p>This section lists the functions and constants built into the
Nix expression evaluator.  (The built-in function
<code class="function">derivation</code> is discussed above.)  Some built-ins,
such as <code class="function">derivation</code>, are always in scope of every
Nix expression; you can just access them right away.  But to prevent
polluting the namespace too much, most built-ins are not in scope.
Instead, you can access them through the <code class="varname">builtins</code>
built-in value, which is an attribute set that contains all built-in
functions and values.  For instance, <code class="function">derivation</code>
is also available as <code class="function">builtins.derivation</code>.</p><div class="variablelist"><dl><dt><span class="term"><code class="function">abort</code> <em class="replaceable"><code>s</code></em></span></dt><dd><p>Abort Nix expression evaluation, print error
    message <em class="replaceable"><code>s</code></em>.</p></dd><dt><span class="term"><code class="function">builtins.add</code>
  <em class="replaceable"><code>e1</code></em> <em class="replaceable"><code>e2</code></em></span></dt><dd><p>Return the sum of the integers
    <em class="replaceable"><code>e1</code></em> and
    <em class="replaceable"><code>e2</code></em>.</p></dd><dt><span class="term"><code class="function">builtins.attrNames</code>
  <em class="replaceable"><code>attrs</code></em></span></dt><dd><p>Return the names of the attributes in the
    attribute set <em class="replaceable"><code>attrs</code></em> in a sorted list.
    For instance, <code class="literal">builtins.attrNames {y = 1; x =
    "foo";}</code> evaluates to <code class="literal">["x" "y"]</code>.
    There is no built-in function <code class="function">attrValues</code>, but
    you can easily define it yourself:

</p><pre class="programlisting">
attrValues = attrs: map (name: builtins.getAttr name attrs) (builtins.attrNames attrs);</pre><p>

    </p></dd><dt><span class="term"><code class="function">baseNameOf</code> <em class="replaceable"><code>s</code></em></span></dt><dd><p>Return the <span class="emphasis"><em>base name</em></span> of the
    string <em class="replaceable"><code>s</code></em>, that is, everything following
    the final slash in the string.  This is similar to the GNU
    <span class="command"><strong>basename</strong></span> command.</p></dd><dt><span class="term"><code class="varname">builtins</code></span></dt><dd><p>The attribute set <code class="varname">builtins</code>
    contains all the built-in functions and values.  You can use
    <code class="varname">builtins</code> to test for the availability of
    features in the Nix installation, e.g.,

</p><pre class="programlisting">
if builtins ? getEnv then builtins.getEnv "PATH" else ""</pre><p>

    This allows a Nix expression to fall back gracefully on older Nix
    installations that don&#8217;t have the desired built-in
    function.</p></dd><dt><span class="term"><code class="function">builtins.compareVersions</code>
  <em class="replaceable"><code>s1</code></em> <em class="replaceable"><code>s2</code></em></span></dt><dd><p>Compare two strings representing versions and
    return <code class="literal">-1</code> if version
    <em class="replaceable"><code>s1</code></em> is older than version
    <em class="replaceable"><code>s2</code></em>, <code class="literal">0</code> if they are
    the same, and <code class="literal">1</code> if
    <em class="replaceable"><code>s1</code></em> is newer than
    <em class="replaceable"><code>s2</code></em>.  The version comparison algorithm
    is the same as the one used by <a class="link" href="#ssec-version-comparisons" title="Versions"><span class="command"><strong>nix-env
    -u</strong></span></a>.</p></dd><dt><a name="builtin-currentSystem"></a><span class="term"><code class="varname">builtins.currentSystem</code></span></dt><dd><p>The built-in value <code class="varname">currentSystem</code>
    evaluates to the Nix platform identifier for the Nix installation
    on which the expression is being evaluated, such as
    <code class="literal">"i686-linux"</code> or
    <code class="literal">"powerpc-darwin"</code>.</p></dd><dt><span class="term"><code class="function">derivation</code>
  <em class="replaceable"><code>attrs</code></em></span></dt><dd><p><code class="function">derivation</code> is described in
    <a class="xref" href="#ssec-derivation" title="5.2.4. Derivations">Section 5.2.4, &#8220;Derivations&#8221;</a>.</p></dd><dt><span class="term"><code class="function">dirOf</code> <em class="replaceable"><code>s</code></em></span></dt><dd><p>Return the directory part of the string
    <em class="replaceable"><code>s</code></em>, that is, everything before the final
    slash in the string.  This is similar to the GNU
    <span class="command"><strong>dirname</strong></span> command.</p></dd><dt><span class="term"><code class="function">builtins.div</code>
  <em class="replaceable"><code>e1</code></em> <em class="replaceable"><code>e2</code></em></span></dt><dd><p>Return the quotient of the integers
    <em class="replaceable"><code>e1</code></em> and
    <em class="replaceable"><code>e2</code></em>.</p></dd><dt><span class="term"><code class="function">builtins.filterSource</code>
  <em class="replaceable"><code>e1</code></em> <em class="replaceable"><code>e2</code></em></span></dt><dd><p>This function allows you to copy sources into the Nix
      store while filtering certain files.  For instance, suppose that
      you want to use the directory <code class="filename">source-dir</code> as
      an input to a Nix expression, e.g.

</p><pre class="programlisting">
stdenv.mkDerivation {
  ...
  src = ./source-dir;
}
</pre><p>

      However, if <code class="filename">source-dir</code> is a Subversion
      working copy, then all those annoying <code class="filename">.svn</code>
      subdirectories will also be copied to the store.  Worse, the
      contents of those directories may change a lot, causing lots of
      spurious rebuilds.  With <code class="function">filterSource</code> you
      can filter out the <code class="filename">.svn</code> directories:

</p><pre class="programlisting">
  src = builtins.filterSource
    (path: type: type != "directory" || baseNameOf path != ".svn")
    ./source-dir;
</pre><p>

      </p><p>Thus, the first argument <em class="replaceable"><code>e1</code></em>
      must be a predicate function that is called for each regular
      file, directory or symlink in the source tree
      <em class="replaceable"><code>e2</code></em>.  If the function returns
      <code class="literal">true</code>, the file is copied to the Nix store,
      otherwise it is omitted.  The function is called with two
      arguments.  The first is the full path of the file.  The second
      is a string that identifies the type of the file, which is
      either <code class="literal">"regular"</code>,
      <code class="literal">"directory"</code>, <code class="literal">"symlink"</code> or
      <code class="literal">"unknown"</code> (for other kinds of files such as
      device nodes or fifos &#8212; but note that those cannot be copied to
      the Nix store, so if the predicate returns
      <code class="literal">true</code> for them, the copy will fail).</p></dd><dt><span class="term"><code class="function">builtins.getAttr</code>
  <em class="replaceable"><code>s</code></em> <em class="replaceable"><code>attrs</code></em></span></dt><dd><p><code class="function">getAttr</code> returns the attribute
    named <em class="replaceable"><code>s</code></em> from the attribute set
    <em class="replaceable"><code>attrs</code></em>.  Evaluation aborts if the
    attribute doesn&#8217;t exist.  This is a dynamic version of the
    <code class="literal">.</code> operator, since <em class="replaceable"><code>s</code></em>
    is an expression rather than an identifier.</p></dd><dt><span class="term"><code class="function">builtins.getEnv</code>
  <em class="replaceable"><code>s</code></em></span></dt><dd><p><code class="function">getEnv</code> returns the value of
    the environment variable <em class="replaceable"><code>s</code></em>, or an empty
    string if the variable doesn&#8217;t exist.  This function should be
    used with care, as it can introduce all sorts of nasty environment
    dependencies in your Nix expression.</p><p><code class="function">getEnv</code> is used in Nix Packages to
    locate the file <code class="filename">~/.nixpkgs/config.nix</code>, which
    contains user-local settings for Nix Packages.  (That is, it does
    a <code class="literal">getEnv "HOME"</code> to locate the user&#8217;s home
    directory.)</p></dd><dt><span class="term"><code class="function">builtins.hasAttr</code>
  <em class="replaceable"><code>s</code></em> <em class="replaceable"><code>attrs</code></em></span></dt><dd><p><code class="function">hasAttr</code> returns
    <code class="literal">true</code> if the attribute set
    <em class="replaceable"><code>attrs</code></em> has an attribute named
    <em class="replaceable"><code>s</code></em>, and <code class="literal">false</code>
    otherwise.  This is a dynamic version of the <code class="literal">?</code>
    operator, since <em class="replaceable"><code>s</code></em> is an expression
    rather than an identifier.</p></dd><dt><span class="term"><code class="function">builtins.head</code>
  <em class="replaceable"><code>list</code></em></span></dt><dd><p>Return the first element of a list; abort
    evaluation if the argument isn&#8217;t a list or is an empty list.  You
    can test whether a list is empty by comparing it with
    <code class="literal">[]</code>.</p></dd><dt><span class="term"><code class="function">import</code>
  <em class="replaceable"><code>path</code></em></span></dt><dd><p>Load, parse and return the Nix expression in the
    file <em class="replaceable"><code>path</code></em>.  Evaluation aborts if the
    file doesn&#8217;t exist or contains an incorrect Nix
    expression.  <code class="function">import</code> implements Nix&#8217;s module
    system: you can put any Nix expression (such as an attribute set
    or a function) in a separate file, and use it from Nix expressions
    in other files.</p><p>A Nix expression loaded by <code class="function">import</code> must
    not contain any <span class="emphasis"><em>free variables</em></span> (identifiers
    that are not defined in the Nix expression itself and are not
    built-in).  Therefore, it cannot refer to variables that are in
    scope at the call site.  For instance, if you have a calling
    expression
    
</p><pre class="programlisting">
rec {
  x = 123;
  y = import ./foo.nix;
}</pre><p>

    then the following <code class="filename">foo.nix</code> will give an
    error:

</p><pre class="programlisting">
x + 456</pre><p>

    since <code class="varname">x</code> is not in scope in
    <code class="filename">foo.nix</code>.  If you want <code class="varname">x</code>
    to be available in <code class="filename">foo.nix</code>, you should pass
    it as a function argument:

</p><pre class="programlisting">
rec {
  x = 123;
  y = import ./foo.nix x;
}</pre><p>

    and

</p><pre class="programlisting">
x: x + 456</pre><p>

    (The function argument doesn&#8217;t have to be called
    <code class="varname">x</code> in <code class="filename">foo.nix</code>; any name
    would work.)</p></dd><dt><span class="term"><code class="function">builtins.intersectAttrs</code>
  <em class="replaceable"><code>e1</code></em> <em class="replaceable"><code>e2</code></em></span></dt><dd><p>Return an attribute set consisting of the
    attributes in the set <em class="replaceable"><code>e2</code></em> that also
    exist in the set <em class="replaceable"><code>e1</code></em>.</p></dd><dt><span class="term"><code class="function">builtins.isAttrs</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return <code class="literal">true</code> if
    <em class="replaceable"><code>e</code></em> evaluates to an attribute set, and
    <code class="literal">false</code> otherwise.</p></dd><dt><span class="term"><code class="function">builtins.isList</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return <code class="literal">true</code> if
    <em class="replaceable"><code>e</code></em> evaluates to a list, and
    <code class="literal">false</code> otherwise.</p></dd><dt><span class="term"><code class="function">builtins.isFunction</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return <code class="literal">true</code> if
    <em class="replaceable"><code>e</code></em> evaluates to a function, and
    <code class="literal">false</code> otherwise.</p></dd><dt><span class="term"><code class="function">builtins.isString</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return <code class="literal">true</code> if
    <em class="replaceable"><code>e</code></em> evaluates to a string, and
    <code class="literal">false</code> otherwise.</p></dd><dt><span class="term"><code class="function">builtins.isInt</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return <code class="literal">true</code> if
    <em class="replaceable"><code>e</code></em> evaluates to a int, and
    <code class="literal">false</code> otherwise.</p></dd><dt><span class="term"><code class="function">builtins.isBool</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return <code class="literal">true</code> if
    <em class="replaceable"><code>e</code></em> evaluates to a bool, and
    <code class="literal">false</code> otherwise.</p></dd><dt><span class="term"><code class="function">isNull</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return <code class="literal">true</code> if
    <em class="replaceable"><code>e</code></em> evaluates to <code class="literal">null</code>,
    and <code class="literal">false</code> otherwise.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>This function is <span class="emphasis"><em>deprecated</em></span>;
    just write <code class="literal">e == null</code> instead.</p></div></dd><dt><span class="term"><code class="function">builtins.length</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return the length of the list
    <em class="replaceable"><code>e</code></em>.</p></dd><dt><span class="term"><code class="function">builtins.lessThan</code>
  <em class="replaceable"><code>e1</code></em> <em class="replaceable"><code>e2</code></em></span></dt><dd><p>Return <code class="literal">true</code> if the integer
    <em class="replaceable"><code>e1</code></em> is less than the integer
    <em class="replaceable"><code>e2</code></em>, and <code class="literal">false</code>
    otherwise.  Evaluation aborts if either
    <em class="replaceable"><code>e1</code></em> or <em class="replaceable"><code>e2</code></em>
    does not evaluate to an integer.</p></dd><dt><span class="term"><code class="function">builtins.listToAttrs</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Construct an attribute set from a list specifying
    the names and values of each attribute.  Each element of the list
    should be an attribute set consisting of a string-valued attribute
    <code class="varname">name</code> specifying the name of the attribute, and
    an attribute <code class="varname">value</code> specifying its value.
    Example:

</p><pre class="programlisting">
builtins.listToAttrs [
  {name = "foo"; value = 123;}
  {name = "bar"; value = 456;}
]
</pre><p>

    evaluates to

</p><pre class="programlisting">
{ foo = 123; bar = 456; }
</pre><p>

    </p></dd><dt><span class="term"><code class="function">map</code>
  <em class="replaceable"><code>f</code></em> <em class="replaceable"><code>list</code></em></span></dt><dd><p>Apply the function <em class="replaceable"><code>f</code></em> to
    each element in the list <em class="replaceable"><code>list</code></em>.  For
    example,

</p><pre class="programlisting">
map (x: "foo" + x) ["bar" "bla" "abc"]</pre><p>

    evaluates to <code class="literal">["foobar" "foobla"
    "fooabc"]</code>.</p></dd><dt><span class="term"><code class="function">builtins.mul</code>
  <em class="replaceable"><code>e1</code></em> <em class="replaceable"><code>e2</code></em></span></dt><dd><p>Return the product of the integers
    <em class="replaceable"><code>e1</code></em> and
    <em class="replaceable"><code>e2</code></em>.</p></dd><dt><span class="term"><code class="function">builtins.parseDrvName</code>
  <em class="replaceable"><code>s</code></em></span></dt><dd><p>Split the string <em class="replaceable"><code>s</code></em> into
    a package name and version.  The package name is everything up to
    but not including the first dash followed by a digit, and the
    version is everything following that dash.  The result is returned
    in an attribute set <code class="literal">{name, version}</code>.  Thus,
    <code class="literal">builtins.parseDrvName "nix-0.12pre12876"</code>
    returns <code class="literal">{name = "nix"; version =
    "0.12pre12876";}</code>.</p></dd><dt><span class="term"><code class="function">builtins.pathExists</code>
  <em class="replaceable"><code>path</code></em></span></dt><dd><p>Return <code class="literal">true</code> if the path
    <em class="replaceable"><code>path</code></em> exists, and
    <code class="literal">false</code> otherwise.  One application of this
    function is to conditionally include a Nix expression containing
    user configuration:

</p><pre class="programlisting">
let
  fileName = builtins.getEnv "CONFIG_FILE";
  config =
    if fileName != "" &amp;&amp; builtins.pathExists (builtins.toPath fileName)
    then import (builtins.toPath fileName)
    else { someSetting = false; }; <em class="lineannotation"><span class="lineannotation"># default configuration</span></em>
in config.someSetting</pre><p>

    (Note that <code class="envar">CONFIG_FILE</code> must be an absolute path for
    this to work.)</p></dd><dt><span class="term"><code class="function">builtins.readFile</code>
  <em class="replaceable"><code>path</code></em></span></dt><dd><p>Return the contents of the file
    <em class="replaceable"><code>path</code></em> as a string.</p></dd><dt><span class="term"><code class="function">removeAttrs</code>
  <em class="replaceable"><code>attrs</code></em> <em class="replaceable"><code>list</code></em></span></dt><dd><p>Remove the attributes listed in
    <em class="replaceable"><code>list</code></em> from the attribute set
    <em class="replaceable"><code>attrs</code></em>.  The attributes don&#8217;t have to
    exist in <em class="replaceable"><code>attrs</code></em>. For instance,

</p><pre class="screen">
removeAttrs { x = 1; y = 2; z = 3; } ["a" "x" "z"]</pre><p>

    evaluates to <code class="literal">{y = 2;}</code>.</p></dd><dt><span class="term"><code class="function">builtins.stringLength</code>
  <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return the length of the string
    <em class="replaceable"><code>e</code></em>.  If <em class="replaceable"><code>e</code></em> is
    not a string, evaluation is aborted.</p></dd><dt><span class="term"><code class="function">builtins.sub</code>
  <em class="replaceable"><code>e1</code></em> <em class="replaceable"><code>e2</code></em></span></dt><dd><p>Return the difference between the integers
    <em class="replaceable"><code>e1</code></em> and
    <em class="replaceable"><code>e2</code></em>.</p></dd><dt><span class="term"><code class="function">builtins.substring</code>
  <em class="replaceable"><code>start</code></em> <em class="replaceable"><code>len</code></em>
  <em class="replaceable"><code>s</code></em></span></dt><dd><p>Return the substring of
    <em class="replaceable"><code>s</code></em> from character position
    <em class="replaceable"><code>start</code></em> (zero-based) up to but not
    including <em class="replaceable"><code>start + len</code></em>.  If
    <em class="replaceable"><code>start</code></em> is greater than the length of the
    string, an empty string is returned, and if <em class="replaceable"><code>start +
    len</code></em> lies beyond the end of the string, only the
    substring up to the end of the string is returned.
    <em class="replaceable"><code>start</code></em> must be
    non-negative.</p></dd><dt><span class="term"><code class="function">builtins.tail</code>
  <em class="replaceable"><code>list</code></em></span></dt><dd><p>Return the second to last elements of a list;
    abort evaluation if the argument isn&#8217;t a list or is an empty
    list.</p></dd><dt><span class="term"><code class="function">throw</code>
  <em class="replaceable"><code>s</code></em></span></dt><dd><p>Throw an error message
    <em class="replaceable"><code>s</code></em>.  This usually aborts Nix expression
    evaluation, but in <span class="command"><strong>nix-env -qa</strong></span> and other
    commands that try to evaluate a set of derivations to get
    information about those derivations, a derivation that throws an
    error is silently skipped (which is not the case for
    <code class="function">abort</code>).</p></dd><dt><a name="builtin-toFile"></a><span class="term"><code class="function">builtins.toFile</code>
  <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>s</code></em></span></dt><dd><p>Store the string <em class="replaceable"><code>s</code></em> in a
    file in the Nix store and return its path.  The file has suffix
    <em class="replaceable"><code>name</code></em>.  This file can be used as an
    input to derivations.  One application is to write builders
    &#8220;inline&#8221;.  For instance, the following Nix expression combines
    <a class="xref" href="#ex-hello-nix" title="Example 5.1. Nix expression for GNU Hello (default.nix)">Example 5.1, &#8220;Nix expression for GNU Hello
(<code class="filename">default.nix</code>)&#8221;</a> and <a class="xref" href="#ex-hello-builder" title="Example 5.2. Build script for GNU Hello (builder.sh)">Example 5.2, &#8220;Build script for GNU Hello
(<code class="filename">builder.sh</code>)&#8221;</a> into one file:

</p><pre class="programlisting">
{stdenv, fetchurl, perl}:

stdenv.mkDerivation {
  name = "hello-2.1.1";
  
  builder = builtins.toFile "builder.sh" "
    source $stdenv/setup

    PATH=$perl/bin:$PATH

    tar xvfz $src
    cd hello-*
    ./configure --prefix=$out
    make
    make install
  ";

  src = fetchurl {
    url = http://nix.cs.uu.nl/dist/tarballs/hello-2.1.1.tar.gz;
    md5 = "70c9ccf9fac07f762c24f2df2290784d";
  };
  inherit perl;
}</pre><p>
  
    </p><p>It is even possible for one file to refer to another, e.g.,

</p><pre class="programlisting">
  builder = let
    configFile = builtins.toFile "foo.conf" "
      # This is some dummy configuration file.
      <em class="replaceable"><code>...</code></em>
    ";
  in builtins.toFile "builder.sh" "
    source $stdenv/setup
    <em class="replaceable"><code>...</code></em>
    cp ${configFile} $out/etc/foo.conf
  ";</pre><p>

    Note that <code class="literal">${configFile}</code> is an antiquotation
    (see <a class="xref" href="#ssec-values" title="5.2.1. Values">Section 5.2.1, &#8220;Values&#8221;</a>), so the result of the
    expression <code class="literal">configFile</code> (i.e., a path like
    <code class="filename">/nix/store/m7p7jfny445k...-foo.conf</code>) will be
    spliced into the resulting string.</p><p>It is however <span class="emphasis"><em>not</em></span> allowed to have files
    mutually referring to each other, like so:

</p><pre class="programlisting">
let
  foo = builtins.toFile "foo" "...${bar}...";
  bar = builtins.toFile "bar" "...${foo}...";
in foo</pre><p>

    This is not allowed because it would cause a cyclic dependency in
    the computation of the cryptographic hashes for
    <code class="varname">foo</code> and <code class="varname">bar</code>.</p></dd><dt><span class="term"><code class="function">builtins.toPath</code> <em class="replaceable"><code>s</code></em></span></dt><dd><p>Convert the string value
    <em class="replaceable"><code>s</code></em> into a path value.  The string
    <em class="replaceable"><code>s</code></em> must represent an absolute path
    (i.e., must start with <code class="literal">/</code>).  The path need not
    exist.  The resulting path is canonicalised, e.g.,
    <code class="literal">builtins.toPath "//foo/xyzzy/../bar/"</code> returns
    <code class="literal">/foo/bar</code>.</p></dd><dt><span class="term"><code class="function">toString</code> <em class="replaceable"><code>e</code></em></span></dt><dd><p>Convert the expression
    <em class="replaceable"><code>e</code></em> to a string.
    <em class="replaceable"><code>e</code></em> can be a string (in which case
    <code class="function">toString</code> is a no-op) or a path (e.g.,
    <code class="literal">toString /foo/bar</code> yields
    <code class="literal">"/foo/bar"</code>.</p></dd><dt><a name="builtin-toXML"></a><span class="term"><code class="function">builtins.toXML</code> <em class="replaceable"><code>e</code></em></span></dt><dd><p>Return a string containing an XML representation
    of <em class="replaceable"><code>e</code></em>.  The main application for
    <code class="function">toXML</code> is to communicate information with the
    builder in a more structured format than plain environment
    variables.</p><p><a class="xref" href="#ex-toxml" title="Example 5.6. Passing information to a builder using toXML">Example 5.6, &#8220;Passing information to a builder
    using <code class="function">toXML</code>&#8221;</a> shows an example where this is
    the case.  The builder is supposed to generate the configuration
    file for a <a class="link" href="http://jetty.mortbay.org/" target="_top">Jetty
    servlet container</a>.  A servlet container contains a number
    of servlets (<code class="filename">*.war</code> files) each exported under
    a specific URI prefix.  So the servlet configuration is a list of
    attribute sets containing the <code class="varname">path</code> and
    <code class="varname">war</code> of the servlet (<a class="xref" href="#ex-toxml-co-servlets"><img src="images/callouts/3.gif" alt="3" border="0"></a>).  This kind of information is
    difficult to communicate with the normal method of passing
    information through an environment variable, which just
    concatenates everything together into a string (which might just
    work in this case, but wouldn&#8217;t work if fields are optional or
    contain lists themselves).  Instead the Nix expression is
    converted to an XML representation with
    <code class="function">toXML</code>, which is unambiguous and can easily be
    processed with the appropriate tools.  For instance, in the
    example an XSLT stylesheet (<a class="xref" href="#ex-toxml-co-stylesheet"><img src="images/callouts/2.gif" alt="2" border="0"></a>) is applied to it (<a class="xref" href="#ex-toxml-co-apply"><img src="images/callouts/1.gif" alt="1" border="0"></a>) to
    generate the XML configuration file for the Jetty server.  The XML
    representation produced from <a class="xref" href="#ex-toxml-co-servlets"><img src="images/callouts/3.gif" alt="3" border="0"></a> by <code class="function">toXML</code> is shown in <a class="xref" href="#ex-toxml-result" title="Example 5.7. XML representation produced by toXML">Example 5.7, &#8220;XML representation produced by
    <code class="function">toXML</code>&#8221;</a>.</p><p>Note that <a class="xref" href="#ex-toxml" title="Example 5.6. Passing information to a builder using toXML">Example 5.6, &#8220;Passing information to a builder
    using <code class="function">toXML</code>&#8221;</a> uses the <code class="function"><a class="function" href="#builtin-toFile">toFile</a></code> built-in to write the
    builder and the stylesheet &#8220;inline&#8221; in the Nix expression.  The
    path of the stylesheet is spliced into the builder at
    <code class="literal">xsltproc ${stylesheet}
    <em class="replaceable"><code>...</code></em></code>.</p><div class="example"><a name="ex-toxml"></a><p class="title"><b>Example 5.6. Passing information to a builder
    using <code class="function">toXML</code></b></p><div class="example-contents"><pre class="programlisting">
{stdenv, fetchurl, libxslt, jira, uberwiki}:

stdenv.mkDerivation (rec {
  name = "web-server";

  buildInputs = [libxslt];
  
  builder = builtins.toFile "builder.sh" "
    source $stdenv/setup
    mkdir $out
    echo $servlets | xsltproc ${stylesheet} - &gt; $out/server-conf.xml <a name="ex-toxml-co-apply"></a><img src="images/callouts/1.gif" alt="1" border="0"> 
  ";

  stylesheet = builtins.toFile "stylesheet.xsl" <a name="ex-toxml-co-stylesheet"></a><img src="images/callouts/2.gif" alt="2" border="0"> 
   "&lt;?xml version='1.0' encoding='UTF-8'?&gt;
    &lt;xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'&gt;
      &lt;xsl:template match='/'&gt;
        &lt;Configure&gt;
          &lt;xsl:for-each select='/expr/list/attrs'&gt;
            &lt;Call name='addWebApplication'&gt;
              &lt;Arg&gt;&lt;xsl:value-of select=\"attr[@name = 'path']/string/@value\" /&gt;&lt;/Arg&gt;
              &lt;Arg&gt;&lt;xsl:value-of select=\"attr[@name = 'war']/path/@value\" /&gt;&lt;/Arg&gt;
            &lt;/Call&gt;
          &lt;/xsl:for-each&gt;
        &lt;/Configure&gt;
      &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  ";

  servlets = builtins.toXML [ <a name="ex-toxml-co-servlets"></a><img src="images/callouts/3.gif" alt="3" border="0"> 
    { path = "/bugtracker"; war = jira + "/lib/atlassian-jira.war"; }
    { path = "/wiki"; war = uberwiki + "/uberwiki.war"; }
  ];
})</pre></div></div><br class="example-break"><div class="example"><a name="ex-toxml-result"></a><p class="title"><b>Example 5.7. XML representation produced by
    <code class="function">toXML</code></b></p><div class="example-contents"><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;expr&gt;
  &lt;list&gt;
    &lt;attrs&gt;
      &lt;attr name="path"&gt;
        &lt;string value="/bugtracker" /&gt;
      &lt;/attr&gt;
      &lt;attr name="war"&gt;
        &lt;path value="/nix/store/d1jh9pasa7k2...-jira/lib/atlassian-jira.war" /&gt;
      &lt;/attr&gt;
    &lt;/attrs&gt;
    &lt;attrs&gt;
      &lt;attr name="path"&gt;
        &lt;string value="/wiki" /&gt;
      &lt;/attr&gt;
      &lt;attr name="war"&gt;
        &lt;path value="/nix/store/y6423b1yi4sx...-uberwiki/uberwiki.war" /&gt;
      &lt;/attr&gt;
    &lt;/attrs&gt;
  &lt;/list&gt;
&lt;/expr&gt;</pre></div></div><br class="example-break"></dd><dt><span class="term"><code class="function">builtins.trace</code>
  <em class="replaceable"><code>e1</code></em> <em class="replaceable"><code>e2</code></em></span></dt><dd><p>Evaluate <em class="replaceable"><code>e1</code></em> and print its
    abstract syntax representation on standard error.  Then return
    <em class="replaceable"><code>e2</code></em>.  This function is useful for
    debugging.</p></dd></dl></div></div></div><div class="section" title="5.3. The standard environment"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-standard-environment"></a>5.3. The standard environment</h2></div></div></div><p>The standard environment is used by passing it as an input
called <code class="envar">stdenv</code> to the derivation, and then doing

</p><pre class="programlisting">
source $stdenv/setup</pre><p>

at the top of the builder.</p><p>Apart from adding the aforementioned commands to the
<code class="envar">PATH</code>, <code class="filename">setup</code> also does the
following:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>All input packages specified in the
  <code class="envar">buildInputs</code> environment variable have their
  <code class="filename">/bin</code> subdirectory added to <code class="envar">PATH</code>,
  their <code class="filename">/include</code> subdirectory added to the C/C++
  header file search path, and their <code class="filename">/lib</code>
  subdirectory added to the linker search path.  This can be extended.
  For instance, when the <span class="command"><strong>pkgconfig</strong></span> package is
  used, the subdirectory <code class="filename">/lib/pkgconfig</code> of each
  input is added to the <code class="envar">PKG_CONFIG_PATH</code> environment
  variable.</p></li><li class="listitem"><p>The environment variable
  <code class="envar">NIX_CFLAGS_STRIP</code> is set so that the compiler strips
  debug information from object files.  This can be disabled by
  setting <code class="envar">NIX_STRIP_DEBUG</code> to
  <code class="literal">0</code>.</p></li></ul></div><p>

</p><p>The <code class="filename">setup</code> script also exports a function
called <code class="function">genericBuild</code> that knows how to build
typical Autoconf-style packages.  It can be customised to perform
builds for any type of package.  It is advisable to use
<code class="function">genericBuild</code> since it provides facilities that
are almost always useful such as unpacking of sources, patching of
sources, nested logging, etc.</p><p>The definitive, up-to-date documentation of the generic builder
is the source itself, which resides in
<code class="filename">pkgs/stdenv/generic/setup.sh</code>.</p><div class="section" title="5.3.1. Customising the generic builder"><div class="titlepage"><div><div><h3 class="title"><a name="id493997"></a>5.3.1. Customising the generic builder</h3></div></div></div><p>The operation of the generic builder can be modified in many
places by setting certain variables.  These <span class="emphasis"><em>hook
variables</em></span> are typically set to the name of some shell
function defined by you.  For instance, to perform some additional
steps after <span class="command"><strong>make install</strong></span> you would set the
<code class="varname">postInstall</code> variable:

</p><pre class="programlisting">
postInstall=myPostInstall

myPostInstall() {
    mkdir $out/share/extra
    cp extrafiles/* $out/share/extra
}</pre><p>

</p></div><div class="section" title="5.3.2. Debugging failed builds"><div class="titlepage"><div><div><h3 class="title"><a name="id494024"></a>5.3.2. Debugging failed builds</h3></div></div></div><p>At the beginning of each phase, the set of all shell variables
is written to the file <code class="filename">env-vars</code> at the top-level
build directory.  This is useful for debugging: it allows you to
recreate the environment in which a build was performed.  For
instance, if a build fails, then assuming you used the
<code class="option">-K</code> flag, you can go to the output directory and
<span class="quote">&#8220;<span class="quote">switch</span>&#8221;</span> to the environment of the builder:

</p><pre class="screen">
$ nix-build -K ./foo.nix
... fails, keeping build directory `/tmp/nix-1234-0'

$ cd /tmp/nix-1234-0

$ source env-vars

<em class="lineannotation"><span class="lineannotation">(edit some files...)</span></em>

$ make

<em class="lineannotation"><span class="lineannotation">(execution continues with the same GCC, make, etc.)</span></em></pre><p>

</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id489240" href="#id489240" class="para">4</a>] </sup>In fact, it can be written in any
  language, but typically it's a <span class="command"><strong>bash</strong></span> shell
  script.</p></div><div class="footnote"><p><sup>[<a name="ftn.id488809" href="#id488809" class="para">5</a>] </sup>Actually, it's initialised to
    <code class="filename">/path-not-set</code> to prevent Bash from setting it
    to a default value.</p></div><div class="footnote"><p><sup>[<a name="ftn.id488299" href="#id488299" class="para">6</a>] </sup>How does it work? <code class="filename">setup</code>
    tries to source the file
    <code class="filename"><em class="replaceable"><code>pkg</code></em>/nix-support/setup-hook</code>
    of all dependencies.  These &#8220;setup hooks&#8221; can then set up whatever
    environment variables they want; for instance, the setup hook for
    Perl sets the <code class="envar">PERL5LIB</code> environment variable to
    contain the <code class="filename">lib/site_perl</code> directories of all
    inputs.</p></div><div class="footnote"><p><sup>[<a name="ftn.id487938" href="#id487938" class="para">7</a>] </sup>It's parsed as an expression that selects the
  attribute <code class="varname">sh</code> from the variable
  <code class="varname">builder</code>.</p></div><div class="footnote"><p><sup>[<a name="ftn.id487775" href="#id487775" class="para">8</a>] </sup>Actually, Nix detects infinite
recursion in this case and aborts (<span class="quote">&#8220;<span class="quote">infinite recursion
encountered</span>&#8221;</span>).</p></div><div class="footnote"><p><sup>[<a name="ftn.id491489" href="#id491489" class="para">9</a>] </sup>To figure out
  your platform identifier, look at the line <span class="quote">&#8220;<span class="quote">Checking for the
  canonical Nix system name</span>&#8221;</span> in the output of Nix's
  <code class="filename">configure</code> script.</p></div></div></div><div class="chapter" title="Chapter 6. Setting up a Build Farm"><div class="titlepage"><div><div><h2 class="title"><a name="chap-build-farm"></a>Chapter 6. Setting up a Build Farm</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id483072">6.1. Overview</a></span></dt><dt><span class="section"><a href="#sec-distributed-builds">6.2. Setting up distributed builds</a></span></dt></dl></div><p>This chapter provides some sketchy information on how to set up
a Nix-based build farm.  Nix is particularly suited as a basis for a
build farm, since:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Nix supports distributed builds: a local Nix
  installation can forward Nix builds to other machines over the
  network.  This allows multiple builds to be performed in parallel
  (thus improving performance), but more in importantly, it allows Nix
  to perform multi-platform builds in a semi-transparent way.  For
  instance, if you perform a build for a
  <code class="literal">powerpc-darwin</code> on an
  <code class="literal">i686-linux</code> machine, Nix can automatically forward
  the build to a <code class="literal">powerpc-darwin</code> machine, if
  available.</p></li><li class="listitem"><p>The Nix expression language is ideal for describing
  build jobs, plus all their dependencies.  For instance, if your
  package has some dependency, you don't have to manually install it
  on all the machines in the build farm; they will be built
  automatically.</p></li><li class="listitem"><p>Proper release management requires that builds (if
  deployed) are traceable: it should be possible to figure out from
  exactly what sources they were built, in what configuration, etc.;
  and it should be possible to reproduce the build, if necessary.  Nix
  makes this possible since Nix's hashing scheme uniquely identifies
  builds, and Nix expressions are self-contained.</p></li><li class="listitem"><p>Nix will only rebuild things that have actually
  changed.  For instance, if the sources of a package haven't changed
  between runs of the build farm, the package won't be rebuilt (unless
  it was garbage-collected).  Also, dependencies typically don't
  change very often, so they only need to be built
  once.</p></li><li class="listitem"><p>The results of a Nix build farm can be made
  available through a channel, so successful builds can be deployed to
  users immediately.</p></li></ul></div><p>

</p><div class="section" title="6.1. Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id483072"></a>6.1. Overview</h2></div></div></div><p>TODO</p><p>The sources of the Nix build farm are at <a class="link" href="https://svn.nixos.org/repos/nix/release/trunk" target="_top">https://svn.nixos.org/repos/nix/release/trunk</a>.</p></div><div class="section" title="6.2. Setting up distributed builds"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-distributed-builds"></a>6.2. Setting up distributed builds</h2></div></div></div><p>You can enable distributed builds by setting the environment
variable <code class="envar">NIX_BUILD_HOOK</code> to point to a program that Nix
will call whenever it wants to build a derivation.  The build hook
(typically a shell or Perl script) can decline the build, in which Nix
will perform it in the usual way if possible, or it can accept it, in
which case it is responsible for somehow getting the inputs of the
build to another machine, doing the build there, and getting the
results back.  The details of the build hook protocol are described in
the documentation of the <a class="link" href="#envar-build-hook"><code class="envar">NIX_BUILD_HOOK</code>
variable</a>.</p><div class="example"><a name="ex-remote-systems"></a><p class="title"><b>Example 6.1. Remote machine configuration:
<code class="filename">remote-systems.conf</code></b></p><div class="example-contents"><pre class="programlisting">
nix@mcflurry.labs.cs.uu.nl  powerpc-darwin  /home/nix/.ssh/id_quarterpounder_auto  2
nix@scratchy.labs.cs.uu.nl  i686-linux      /home/nix/.ssh/id_scratchy_auto        1
</pre></div></div><br class="example-break"><p>An example build hook can be found in the Nix build farm
sources: <a class="link" href="https://svn.nixos.org/repos/nix/release/trunk/common/distributed/build-remote.pl" target="_top">https://svn.nixos.org/repos/nix/release/trunk/common/distributed/build-remote.pl</a>.  It should be suitable for most purposes, with maybe some minor
adjustments.  It uses <span class="command"><strong>ssh</strong></span> and
<span class="command"><strong>rsync</strong></span> to copy the build inputs and outputs and
perform the remote build.  You should define a list of available build
machines and set the environment variable
<code class="envar">REMOTE_SYSTEMS</code> to point to it.  An example
configuration is shown in <a class="xref" href="#ex-remote-systems" title="Example 6.1. Remote machine configuration: remote-systems.conf">Example 6.1, &#8220;Remote machine configuration:
<code class="filename">remote-systems.conf</code>&#8221;</a>.  Each
line in the file specifies a machine, with the following bits of
information:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The name of the remote machine, with optionally the
  user under which the remote build should be performed.  This is
  actually passed as an argument to <span class="command"><strong>ssh</strong></span>, so it can
  be an alias defined in your
  <code class="filename">~/.ssh/config</code>.</p></li><li class="listitem"><p>The Nix platform type identifier, such as
  <code class="literal">powerpc-darwin</code>.</p></li><li class="listitem"><p>The SSH private key to be used to log in to the
  remote machine.  Since builds should be non-interactive, this key
  should not have a passphrase!</p></li><li class="listitem"><p>The maximum <span class="quote">&#8220;<span class="quote">load</span>&#8221;</span> of the remote
  machine.  This is just the maximum number of jobs that
  <code class="filename">build-remote.pl</code> will execute in parallel on the
  machine.  Typically this should be equal to the number of
  CPUs.</p></li></ol></div><p>

You should also set up the environment variable
<code class="envar">CURRENT_LOAD</code> to point at a file that
<code class="filename">build-remote.pl</code> uses to remember how many jobs it
is currently executing remotely.  It doesn't look at the actual load
on the remote machine, so if you have multiple instances of Nix
running, they should use the same <code class="envar">CURRENT_LOAD</code>
file<sup>[<a name="id481321" href="#ftn.id481321" class="footnote">10</a>]</sup>.  Maybe in the future
<code class="filename">build-remote.pl</code> will look at the actual remote
load.  The load file should exist, so you should just create it as an
empty file initially.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id481321" href="#id481321" class="para">10</a>] </sup>Although there are probably some race conditions
in the script right now.</p></div></div></div><div class="appendix" title="Appendix A. Command Reference"><div class="titlepage"><div><div><h2 class="title"><a name="id481062"></a>Appendix A. Command Reference</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#sec-common-options">A.1. Common options</a></span></dt><dt><span class="section"><a href="#sec-common-env">A.2. Common environment variables</a></span></dt><dt><span class="section"><a href="#sec-conf-file">A.3. Nix configuration file</a></span></dt><dt><span class="section"><a href="#id481080">A.4. Main commands</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#sec-nix-env">nix-env</a></span><span class="refpurpose"> &#8212; manipulate or query Nix user environments</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-instantiate">nix-instantiate</a></span><span class="refpurpose"> &#8212; instantiate store derivations from Nix expressions</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-store">nix-store</a></span><span class="refpurpose"> &#8212; manipulate or query the Nix store</span></dt></dl></dd><dt><span class="section"><a href="#id481099">A.5. Utilities</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#sec-nix-build">nix-build</a></span><span class="refpurpose"> &#8212; build a Nix expression</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-channel">nix-channel</a></span><span class="refpurpose"> &#8212; manage Nix channels</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-collect-garbage">nix-collect-garbage</a></span><span class="refpurpose"> &#8212; delete unreachable store paths</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-copy-closure">nix-copy-closure</a></span><span class="refpurpose"> &#8212; copy a closure to or from a remote machine via SSH</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-hash">nix-hash</a></span><span class="refpurpose"> &#8212; compute the cryptographic hash of a path</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-install-package">nix-install-package</a></span><span class="refpurpose"> &#8212; install a Nix Package file</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-prefetch-url">nix-prefetch-url</a></span><span class="refpurpose"> &#8212; copy a file from a URL into the store and print its MD5 hash</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-pull">nix-pull</a></span><span class="refpurpose"> &#8212; pull substitutes from a network cache</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-push">nix-push</a></span><span class="refpurpose"> &#8212; push store paths onto a network cache</span></dt><dt><span class="refentrytitle"><a href="#sec-nix-worker">nix-worker</a></span><span class="refpurpose"> &#8212; Nix multi-user support daemon</span></dt></dl></dd></dl></div><div class="section" title="A.1. Common options"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-common-options"></a>A.1. Common options</h2></div></div></div><p>Most Nix commands accept the following command-line options:</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--help</code></span></dt><dd><p>Prints out a summary of the command syntax and
  exits.</p></dd><dt><span class="term"><code class="option">--version</code></span></dt><dd><p>Prints out the Nix version number on standard output
  and exits.</p></dd><dt><span class="term"><code class="option">--verbose</code>, </span><span class="term"><code class="option">-v</code></span></dt><dd><p>Increases the level of verbosity of diagnostic messages
  printed on standard error.  For each Nix operation, the information
  printed on standard output is well-defined; any diagnostic
  information is printed on standard error, never on standard
  output.</p><p>This option may be specified repeatedly.  Currently, the
  following verbosity levels exist:</p><div class="variablelist"><dl><dt><span class="term">0</span></dt><dd><p>&#8220;Errors only&#8221;: only print messages
    explaining why the Nix invocation failed.</p></dd><dt><span class="term">1</span></dt><dd><p>&#8220;Informational&#8221;: print
    <span class="emphasis"><em>useful</em></span> messages about what Nix is doing.
    This is the default.</p></dd><dt><span class="term">2</span></dt><dd><p>&#8220;Talkative&#8221;: print more informational
    messages.</p></dd><dt><span class="term">3</span></dt><dd><p>&#8220;Chatty&#8221;: print even more
    informational messages.</p></dd><dt><span class="term">4</span></dt><dd><p>&#8220;Debug&#8221;: print debug
    information.</p></dd><dt><span class="term">5</span></dt><dd><p>&#8220;Vomit&#8221;: print vast amounts of debug
    information.</p></dd></dl></div></dd><dt><span class="term"><code class="option">--no-build-output</code>, </span><span class="term"><code class="option">-Q</code></span></dt><dd><p>By default, output written by builders to standard
  output and standard error is echoed to the Nix command's standard
  error.  This option suppresses this behaviour.  Note that the
  builder's standard output and error are always written to a log file
  in
  <code class="filename"><em class="replaceable"><code>prefix</code></em>/nix/var/log/nix</code>.</p></dd><dt><a name="opt-max-jobs"></a><span class="term"><code class="option">--max-jobs</code>, </span><span class="term"><code class="option">-j</code></span></dt><dd><p>Sets the maximum number of build jobs that Nix will
  perform in parallel to the specified number.  The default is
  specified by the <a class="link" href="#conf-build-max-jobs"><code class="literal">build-max-jobs</code></a>
  configuration setting, which itself defaults to
  <code class="literal">1</code>.  A higher value is useful on SMP systems or to
  exploit I/O latency.</p></dd><dt><a name="opt-cores"></a><span class="term"><code class="option">--cores</code></span></dt><dd><p>Sets the value of the <code class="envar">NIX_BUILD_CORES</code>
  environment variable in the invocation of builders.  Builders can
  use this variable at their discretion to control the maximum amount
  of parallelism.  For instance, in Nixpkgs, if the derivation
  attribute <code class="varname">enableParallelBuilding</code> is set to
  <code class="literal">true</code>, the builder passes the
  <code class="option">-j<em class="replaceable"><code>N</code></em></code> flag to GNU Make.
  It defaults to the value of the <a class="link" href="#conf-build-cores"><code class="literal">build-cores</code></a>
  configuration setting, if set, or <code class="literal">1</code> otherwise.
  The value <code class="literal">0</code> means that the builder should use all
  available CPU cores in the system.</p></dd><dt><a name="opt-max-silent-time"></a><span class="term"><code class="option">--max-silent-time</code></span></dt><dd><p>Sets the maximum number of seconds that a builder
  can go without producing any data on standard output or standard
  error.  The default is specified by the <a class="link" href="#conf-build-max-silent-time"><code class="literal">build-max-silent-time</code></a>
  configuration setting.  <code class="literal">0</code> means no
  time-out.</p></dd><dt><span class="term"><code class="option">--keep-going</code>, </span><span class="term"><code class="option">-k</code></span></dt><dd><p>Keep going in case of failed builds, to the
  greatest extent possible.  That is, if building an input of some
  derivation fails, Nix will still build the other inputs, but not the
  derivation itself.  Without this option, Nix stops if any build
  fails (except for builds of substitutes), possibly killing builds in
  progress (in case of parallel or distributed builds).</p></dd><dt><span class="term"><code class="option">--keep-failed</code>, </span><span class="term"><code class="option">-K</code></span></dt><dd><p>Specifies that in case of a build failure, the
  temporary directory (usually in <code class="filename">/tmp</code>) in which
  the build takes place should not be deleted.  The path of the build
  directory is printed as an informational message.
    </p></dd><dt><span class="term"><code class="option">--fallback</code></span></dt><dd><p>Whenever Nix attempts to build a derivation for which
  substitutes are known for each output path, but realising the output
  paths through the substitutes fails, fall back on building the
  derivation.</p><p>The most common scenario in which this is useful is when we
  have registered substitutes in order to perform binary distribution
  from, say, a network repository.  If the repository is down, the
  realisation of the derivation will fail.  When this option is
  specified, Nix will build the derivation instead.  Thus,
  installation from binaries falls back on nstallation from source.
  This option is not the default since it is generally not desirable
  for a transient failure in obtaining the substitutes to lead to a
  full build from source (with the related consumption of
  resources).</p></dd><dt><span class="term"><code class="option">--readonly-mode</code></span></dt><dd><p>When this option is used, no attempt is made to open
  the Nix database.  Most Nix operations do need database access, so
  those operations will fail.</p></dd><dt><a name="opt-log-type"></a><span class="term"><code class="option">--log-type</code>
<em class="replaceable"><code>type</code></em></span></dt><dd><p>This option determines how the output written to standard
  error is formatted.  Nix&#8217;s diagnostic messages are typically
  <span class="emphasis"><em>nested</em></span>.  For instance, when tracing Nix
  expression evaluation (<span class="command"><strong>nix-env -vvvvv</strong></span>, messages
  from subexpressions are nested inside their parent expressions.  Nix
  builder output is also often nested.  For instance, the Nix Packages
  generic builder nests the various build tasks (unpack, configure,
  compile, etc.), and the GNU Make in <code class="literal">stdenv-linux</code>
  has been patched to provide nesting for recursive Make
  invocations.</p><p><em class="replaceable"><code>type</code></em> can be one of the
  following:

  </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">pretty</code></span></dt><dd><p>Pretty-print the output, indicating different
      nesting levels using spaces.  This is the
      default.</p></dd><dt><span class="term"><code class="literal">escapes</code></span></dt><dd><p>Indicate nesting using escape codes that can be
      interpreted by the <span class="command"><strong>nix-log2xml</strong></span> tool in the
      Nix source distribution.  The resulting XML file can be fed into
      the <span class="command"><strong>log2html.xsl</strong></span> stylesheet to create an HTML
      file that can be browsed interactively, using Javascript to
      expand and collapse parts of the output.</p></dd><dt><span class="term"><code class="literal">flat</code></span></dt><dd><p>Remove all nesting.</p></dd></dl></div><p>    
  
  </p></dd><dt><span class="term"><code class="option">--arg</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>value</code></em></span></dt><dd><p>This option is accepted by
  <span class="command"><strong>nix-env</strong></span>, <span class="command"><strong>nix-instantiate</strong></span> and
  <span class="command"><strong>nix-build</strong></span>.  When evaluating Nix expressions, the
  expression evaluator will automatically try to call functions that
  it encounters.  It can automatically call functions for which every
  argument has a <a class="link" href="#ss-functions" title="Functions">default value</a>
  (e.g., <code class="literal">{<em class="replaceable"><code>argName</code></em> ?
  <em class="replaceable"><code>defaultValue</code></em>}:
  <em class="replaceable"><code>...</code></em></code>).  With
  <code class="option">--arg</code>, you can also call functions that have
  arguments without a default value (or override a default value).
  That is, if the evaluator encounters a function with an argument
  named <em class="replaceable"><code>name</code></em>, it will call it with value
  <em class="replaceable"><code>value</code></em>.</p><p>For instance, the file
  <code class="literal">pkgs/top-level/all-packages.nix</code> in Nixpkgs is
  actually a function:

</p><pre class="programlisting">
{ # The system (e.g., `i686-linux') for which to build the packages.
  system ? builtins.currentSystem
  <em class="replaceable"><code>...</code></em>
}: <em class="replaceable"><code>...</code></em></pre><p>

  So if you call this Nix expression (e.g., when you do
  <code class="literal">nix-env -i <em class="replaceable"><code>pkgname</code></em></code>),
  the function will be called automatically using the value <a class="link" href="#builtin-currentSystem"><code class="literal">builtins.currentSystem</code></a>
  for the <code class="literal">system</code> argument.  You can override this
  using <code class="option">--arg</code>, e.g., <code class="literal">nix-env -i
  <em class="replaceable"><code>pkgname</code></em> --arg system
  \"i686-freebsd\"</code>.  (Note that since the argument is a Nix
  string literal, you have to escape the quotes.)</p></dd><dt><span class="term"><code class="option">--argstr</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>value</code></em></span></dt><dd><p>This option is like <code class="option">--arg</code>, only the
  value is not a Nix expression but a string.  So instead of
  <code class="literal">--arg system \"i686-linux\"</code> (the outer quotes are
  to keep the shell happy) you can say <code class="literal">--argstr system
  i686-linux</code>.</p></dd><dt><a name="opt-attr"></a><span class="term"><code class="option">--attr</code> / <code class="option">-A</code>
<em class="replaceable"><code>attrPath</code></em></span></dt><dd><p>In <span class="command"><strong>nix-env</strong></span>,
  <span class="command"><strong>nix-instantiate</strong></span> and <span class="command"><strong>nix-build</strong></span>,
  <code class="option">--attr</code> allows you to select an attribute from the
  top-level Nix expression being evaluated.  The <span class="emphasis"><em>attribute
  path</em></span> <em class="replaceable"><code>attrPath</code></em> is a sequence of
  attribute names separated by dots.  For instance, given a top-level
  Nix expression <em class="replaceable"><code>e</code></em>, the attribute path
  <code class="literal">xorg.xorgserver</code> would cause the expression
  <code class="literal"><em class="replaceable"><code>e</code></em>.xorg.xorgserver</code> to
  be used.  See <a class="link" href="#refsec-nix-env-install-examples" title="Examples"><span class="command"><strong>nix-env
  --install</strong></span></a> for some concrete examples.</p><p>In addition to attribute names, you can also specify array
  indices.  For instance, the attribute path
  <code class="literal">foo.3.bar</code> selects the <code class="literal">bar</code>
  attribute of the fourth element of the array in the
  <code class="literal">foo</code> attribute of the top-level
  expression.</p></dd><dt><span class="term"><code class="option">--show-trace</code></span></dt><dd><p>Causes Nix to print out a stack trace in case of Nix
  expression evaluation errors.</p></dd></dl></div></div><div class="section" title="A.2. Common environment variables"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-common-env"></a>A.2. Common environment variables</h2></div></div></div><p>Most Nix commands interpret the following environment variables:</p><div class="variablelist"><dl><dt><span class="term"><code class="envar">NIX_IGNORE_SYMLINK_STORE</code></span></dt><dd><p>Normally, the Nix store directory (typically
  <code class="filename">/nix/store</code>) is not allowed to contain any
  symlink components.  This is to prevent &#8220;impure&#8221; builds.  Builders
  sometimes &#8220;canonicalise&#8221; paths by resolving all symlink components.
  Thus, builds on different machines (with
  <code class="filename">/nix/store</code> resolving to different locations)
  could yield different results.  This is generally not a problem,
  except when builds are deployed to machines where
  <code class="filename">/nix/store</code> resolves differently.  If you are
  sure that you&#8217;re not going to do that, you can set
  <code class="envar">NIX_IGNORE_SYMLINK_STORE</code> to <code class="envar">1</code>.</p><p>Note that if you&#8217;re symlinking the Nix store so that you can
  put it on another file system than the root file system, on Linux
  you&#8217;re better off using <code class="literal">bind</code> mount points, e.g.,

  </p><pre class="screen">
$ mkdir /nix   
$ mount -o bind /mnt/otherdisk/nix /nix</pre><p>

  Consult the <span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span> manual page for details.</p></dd><dt><span class="term"><code class="envar">NIX_STORE_DIR</code></span></dt><dd><p>Overrides the location of the Nix store (default
  <code class="filename"><em class="replaceable"><code>prefix</code></em>/store</code>).</p></dd><dt><span class="term"><code class="envar">NIX_DATA_DIR</code></span></dt><dd><p>Overrides the location of the Nix static data
  directory (default
  <code class="filename"><em class="replaceable"><code>prefix</code></em>/share</code>).</p></dd><dt><span class="term"><code class="envar">NIX_LOG_DIR</code></span></dt><dd><p>Overrides the location of the Nix log directory
  (default <code class="filename"><em class="replaceable"><code>prefix</code></em>/log/nix</code>).</p></dd><dt><span class="term"><code class="envar">NIX_STATE_DIR</code></span></dt><dd><p>Overrides the location of the Nix state directory
  (default <code class="filename"><em class="replaceable"><code>prefix</code></em>/var/nix</code>).</p></dd><dt><span class="term"><code class="envar">NIX_DB_DIR</code></span></dt><dd><p>Overrides the location of the Nix database (default
  <code class="filename"><em class="replaceable"><code>$NIX_STATE_DIR</code></em>/db</code>, i.e.,
  <code class="filename"><em class="replaceable"><code>prefix</code></em>/var/nix/db</code>).</p></dd><dt><span class="term"><code class="envar">NIX_CONF_DIR</code></span></dt><dd><p>Overrides the location of the Nix configuration
  directory (default
  <code class="filename"><em class="replaceable"><code>prefix</code></em>/etc/nix</code>).</p></dd><dt><span class="term"><code class="envar">NIX_LOG_TYPE</code></span></dt><dd><p>Equivalent to the <a class="link" href="#opt-log-type"><code class="option">--log-type</code>
  option</a>.</p></dd><dt><span class="term"><code class="envar">TMPDIR</code></span></dt><dd><p>Use the specified directory to store temporary
  files.  In particular, this includes temporary build directories;
  these can take up substantial amounts of disk space.  The default is
  <code class="filename">/tmp</code>.</p></dd><dt><a name="envar-build-hook"></a><span class="term"><code class="envar">NIX_BUILD_HOOK</code></span></dt><dd><p>Specifies the location of the <span class="emphasis"><em>build hook</em></span>,
  which is a program (typically some script) that Nix will call
  whenever it wants to build a derivation.  This is used to implement
  distributed builds (see <a class="xref" href="#sec-distributed-builds" title="6.2. Setting up distributed builds">Section 6.2, &#8220;Setting up distributed builds&#8221;</a>).  The protocol by which the calling Nix process and the build
  hook communicate is as follows.</p><p>The build hook is called with the following command-line
  arguments:

  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A boolean value <code class="literal">0</code> or
    <code class="literal">1</code> specifying whether Nix can locally execute
    more builds, as per the <a class="link" href="#opt-max-jobs"><code class="option">--max-jobs</code> option</a>.
    The purpose of this argument is to allow the hook to not have to
    maintain bookkeeping for the local machine.</p></li><li class="listitem"><p>The Nix platform identifier for the local machine
    (e.g., <code class="literal">i686-linux</code>).</p></li><li class="listitem"><p>The Nix platform identifier for the derivation,
    i.e., its <a class="link" href="#attr-system"><code class="varname">system</code>
    attribute</a>.</p></li><li class="listitem"><p>The store path of the derivation.</p></li></ol></div><p>

  </p><p>On the basis of this information, and whatever persistent
  state the build hook keeps about other machines and their current
  load, it has to decide what to do with the build.  It should print
  out on standard error one of the following responses (terminated by
  a newline, <code class="literal">"\n"</code>):

  </p><div class="variablelist"><dl><dt><span class="term"><code class="literal"># decline</code></span></dt><dd><p>The build hook is not willing or able to perform
      the build; the calling Nix process should do the build itself,
      if possible.</p></dd><dt><span class="term"><code class="literal"># postpone</code></span></dt><dd><p>The build hook cannot perform the build now, but
      can do so in the future (e.g., because all available build slots
      on remote machines are in use).  The calling Nix process should
      postpone this build until at least one currently running build
      has terminated.</p></dd><dt><span class="term"><code class="literal"># accept</code></span></dt><dd><p>The build hook has accepted the
      build.</p></dd></dl></div><p>

  </p><p>After sending <code class="literal"># accept</code>, the hook should
  read one line from standard input, which will be the string
  <code class="literal">okay</code>.  It can then proceed with the build.
  Before sending <code class="literal">okay</code>, Nix will store in the hook&#8217;s
  current directory a number of text files that contain information
  about the derivation:

  </p><div class="variablelist"><dl><dt><span class="term"><code class="filename">inputs</code></span></dt><dd><p>The set of store paths that are inputs to the
      build process (one per line).  These have to be copied
      <span class="emphasis"><em>to</em></span> the remote machine (in addition to the
      store derivation itself).</p></dd><dt><span class="term"><code class="filename">outputs</code></span></dt><dd><p>The set of store paths that are outputs of the
      derivation (one per line).  These have to be copied
      <span class="emphasis"><em>from</em></span> the remote machine if the build
      succeeds.</p></dd><dt><span class="term"><code class="filename">references</code></span></dt><dd><p>The reference graph of the inputs, in the format
      accepted by the command <span class="command"><strong>nix-store
      --register-validity</strong></span>.  It is necessary to run this
      command on the remote machine after copying the inputs to inform
      Nix on the remote machine that the inputs are valid
      paths.</p></dd></dl></div><p>

  </p><p>The hook should copy the inputs to the remote machine,
  register the validity of the inputs, perform the remote build, and
  copy the outputs back to the local machine.  An exit code other than
  <code class="literal">0</code> indicates that the hook has failed.  An exit
  code equal to 100 means that the remote build failed (as opposed to,
  e.g., a network error).</p></dd><dt><a name="envar-remote"></a><span class="term"><code class="envar">NIX_REMOTE</code></span></dt><dd><p>This variable should be set to
  <code class="literal">daemon</code> if you want to use the Nix daemon to
  executed Nix operations, which is necessary in <a class="link" href="#ssec-multi-user" title="3.6.2. Multi-user mode">multi-user Nix installations</a>.
  Otherwise, it should be left unset.</p></dd><dt><a name="envar-other-stores"></a><span class="term"><code class="envar">NIX_OTHER_STORES</code></span></dt><dd><p>This variable contains the paths of remote Nix
  installations from whichs paths can be copied, separated by colons.
  See <a class="xref" href="#sec-sharing-packages" title="4.6. Sharing packages between machines">Section 4.6, &#8220;Sharing packages between machines&#8221;</a> for details.  Each path
  should be the <code class="filename">/nix</code> directory of a remote Nix
  installation (i.e., not the <code class="filename">/nix/store</code>
  directory).  The paths are subject to globbing, so you can set it so
  something like <code class="literal">/var/run/nix/remote-stores/*/nix</code>
  and mount multiple remote filesystems in
  <code class="literal">/var/run/nix/remote-stores</code>.</p><p>Note that if you&#8217;re building through the <a class="link" href="#sec-nix-worker" title="nix-worker">Nix daemon</a>, the only setting for
  this variable that matters is the one that the
  <span class="command"><strong>nix-worker</strong></span> process uses.  So if you want to
  change it, you have to restart the daemon.</p></dd></dl></div></div><div class="section" title="A.3. Nix configuration file"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-conf-file"></a>A.3. Nix configuration file</h2></div></div></div><p>A number of persistent settings of Nix are stored in the file
<code class="filename"><em class="replaceable"><code>prefix</code></em>/etc/nix/nix.conf</code>.
This file is a list of <code class="literal"><em class="replaceable"><code>name</code></em> =
<em class="replaceable"><code>value</code></em></code> pairs, one per line.
Comments start with a <code class="literal">#</code> character.  An example
configuration file is shown in <a class="xref" href="#ex-nix-conf" title="Example A.1. Nix configuration file">Example A.1, &#8220;Nix configuration file&#8221;</a>.</p><div class="example"><a name="ex-nix-conf"></a><p class="title"><b>Example A.1. Nix configuration file</b></p><div class="example-contents"><pre class="programlisting">
gc-keep-outputs = true       # Nice for developers
gc-keep-derivations = true   # Idem
env-keep-derivations = false
</pre></div></div><br class="example-break"><p>The following variables are currently available: 

</p><div class="variablelist"><dl><dt><a name="conf-gc-keep-outputs"></a><span class="term"><code class="literal">gc-keep-outputs</code></span></dt><dd><p>If <code class="literal">true</code>, the garbage collector
    will keep the outputs of non-garbage derivations.  If
    <code class="literal">false</code> (default), outputs will be deleted unless
    they are GC roots themselves (or reachable from other roots).</p><p>In general, outputs must be registered as roots separately.
    However, even if the output of a derivation is registered as a
    root, the collector will still delete store paths that are used
    only at build time (e.g., the C compiler, or source tarballs
    downloaded from the network).  To prevent it from doing so, set
    this option to <code class="literal">true</code>.</p></dd><dt><a name="conf-gc-keep-derivations"></a><span class="term"><code class="literal">gc-keep-derivations</code></span></dt><dd><p>If <code class="literal">true</code> (default), the garbage
    collector will keep the derivations from which non-garbage store
    paths were built.  If <code class="literal">false</code>, they will be
    deleted unless explicitly registered as a root (or reachable from
    other roots).</p><p>Keeping derivation around is useful for querying and
    traceability (e.g., it allows you to ask with what dependencies or
    options a store path was built), so by default this option is on.
    Turn it off to safe a bit of disk space (or a lot if
    <code class="literal">gc-keep-outputs</code> is also turned on).</p></dd><dt><span class="term"><code class="literal">env-keep-derivations</code></span></dt><dd><p>If <code class="literal">false</code> (default), derivations
    are not stored in Nix user environments.  That is, the derivation
    any build-time-only dependencies may be garbage-collected.</p><p>If <code class="literal">true</code>, when you add a Nix derivation to
    a user environment, the path of the derivation is stored in the
    user environment.  Thus, the derivation will not be
    garbage-collected until the user environment generation is deleted
    (<span class="command"><strong>nix-env --delete-generations</strong></span>).  To prevent
    build-time-only dependencies from being collected, you should also
    turn on <code class="literal">gc-keep-outputs</code>.</p><p>The difference between this option and
    <code class="literal">gc-keep-derivations</code> is that this one is
    &#8220;sticky&#8221;: it applies to any user environment created while this
    option was enabled, while <code class="literal">gc-keep-derivations</code>
    only applies at the moment the garbage collector is
    run.</p></dd><dt><a name="conf-build-max-jobs"></a><span class="term"><code class="literal">build-max-jobs</code></span></dt><dd><p>This option defines the maximum number of jobs
    that Nix will try to build in parallel.  The default is
    <code class="literal">1</code>.  You should generally set it to the number
    of CPUs in your system (e.g., <code class="literal">2</code> on a Athlon 64
    X2).  It can be overriden using the <code class="option"><a class="option" href="#opt-max-jobs">--max-jobs</a></code> (<code class="option">-j</code>)
    command line switch.</p></dd><dt><a name="conf-build-cores"></a><span class="term"><code class="literal">build-cores</code></span></dt><dd><p>Sets the value of the
    <code class="envar">NIX_BUILD_CORES</code> environment variable in the
    invocation of builders.  Builders can use this variable at their
    discretion to control the maximum amount of parallelism.  For
    instance, in Nixpkgs, if the derivation attribute
    <code class="varname">enableParallelBuilding</code> is set to
    <code class="literal">true</code>, the builder passes the
    <code class="option">-j<em class="replaceable"><code>N</code></em></code> flag to GNU Make.
    It can be overriden using the <code class="option"><a class="option" href="#opt-cores">--cores</a></code> command line switch and
    defaults to <code class="literal">1</code>.  The value <code class="literal">0</code>
    means that the builder should use all available CPU cores in the
    system.</p></dd><dt><a name="conf-build-max-silent-time"></a><span class="term"><code class="literal">build-max-silent-time</code></span></dt><dd><p>This option defines the maximum number of seconds that a
      builder can go without producing any data on standard output or
      standard error.  This is useful (for instance in a automated
      build system) to catch builds that are stuck in an infinite
      loop, or to catch remote builds that are hanging due to network
      problems.  It can be overriden using the <code class="option"><a class="option" href="#opt-max-silent-time">--max-silent-time</a></code> command
      line switch.</p><p>The value <code class="literal">0</code> means that there is no
      timeout.  This is also the default.</p></dd><dt><a name="conf-build-users-group"></a><span class="term"><code class="literal">build-users-group</code></span></dt><dd><p>This options specifies the Unix group containing
    the Nix build user accounts.  In multi-user Nix installations,
    builds should not be performed by the Nix account since that would
    allow users to arbitrarily modify the Nix store and database by
    supplying specially crafted builders; and they cannot be performed
    by the calling user since that would allow him/her to influence
    the build result.</p><p>Therefore, if this option is non-empty and specifies a valid
    group, builds will be performed under the user accounts that are a
    member of the group specified here (as listed in
    <code class="filename">/etc/group</code>).  Those user accounts should not
    be used for any other purpose!</p><p>Nix will never run two builds under the same user account at
    the same time.  This is to prevent an obvious security hole: a
    malicious user writing a Nix expression that modifies the build
    result of a legitimate Nix expression being built by another user.
    Therefore it is good to have as many Nix build user accounts as
    you can spare.  (Remember: uids are cheap.)</p><p>The build users should have permission to create files in
    the Nix store, but not delete them.  Therefore,
    <code class="filename">/nix/store</code> should be owned by the Nix
    account, its group should be the group specified here, and its
    mode should be <code class="literal">1775</code>.</p><p>If the build users group is empty, builds will be performed
    under the uid of the Nix process (that is, the uid of the caller
    if <code class="envar">NIX_REMOTE</code> is empty, the uid under which the Nix
    daemon runs if <code class="envar">NIX_REMOTE</code> is
    <code class="literal">daemon</code>, or the uid that owns the setuid
    <span class="command"><strong>nix-worker</strong></span> program if <code class="envar">NIX_REMOTE</code>
    is <code class="literal">slave</code>).  Obviously, this should not be used
    in multi-user settings with untrusted users.</p></dd><dt><span class="term"><code class="literal">build-use-chroot</code></span></dt><dd><p>If set to <code class="literal">true</code>, builds will be
    performed in a <span class="emphasis"><em>chroot environment</em></span>, i.e., the
    build will be isolated from the normal file system hierarchy and
    will only see the Nix store, the temporary build directory, and
    the directories configured with the <a class="link" href="#conf-build-chroot-dirs"><code class="literal">build-chroot-dirs</code>
    option</a> (such as <code class="filename">/proc</code> and
    <code class="filename">/dev</code>).  This is useful to prevent undeclared
    dependencies on files in directories such as
    <code class="filename">/usr/bin</code>.</p><p>The use of a chroot requires that Nix is run as root (but
    you can still use the <a class="link" href="#conf-build-users-group">&#8220;build users&#8221; feature</a> to
    perform builds under different users than root).  Currently,
    chroot builds only work on Linux because Nix uses &#8220;bind mounts&#8221; to
    make the Nix store and other directories available inside the
    chroot.</p></dd><dt><a name="conf-build-chroot-dirs"></a><span class="term"><code class="literal">build-chroot-dirs</code></span></dt><dd><p>When builds are performed in a chroot environment,
    Nix will mount (using <span class="command"><strong>mount --bind</strong></span> on Linux)
    some directories from the normal file system hierarchy inside the
    chroot.  These are the Nix store, the temporary build directory
    (usually
    <code class="filename">/tmp/nix-<em class="replaceable"><code>pid</code></em>-<em class="replaceable"><code>number</code></em></code>)
    and the directories listed here.  The default is <code class="literal">dev
    /proc</code>.  Files in <code class="filename">/dev</code> (such as
    <code class="filename">/dev/null</code>) are needed by many builds, and
    some files in <code class="filename">/proc</code> may also be needed
    occasionally.</p><p>The value used on NixOS is
    
</p><pre class="programlisting">
build-use-chroot = /dev /proc /bin</pre><p>

    to make the <code class="filename">/bin/sh</code> symlink available (which
    is still needed by many builders).</p></dd><dt><span class="term"><code class="literal">system</code></span></dt><dd><p>This option specifies the canonical Nix system
    name of the current installation, such as
    <code class="literal">i686-linux</code> or
    <code class="literal">powerpc-darwin</code>.  Nix can only build derivations
    whose <code class="literal">system</code> attribute equals the value
    specified here.  In general, it never makes sense to modify this
    value from its default, since you can use it to &#8216;lie&#8217; about the
    platform you are building on (e.g., perform a Mac OS build on a
    Linux machine; the result would obviously be wrong).  It only
    makes sense if the Nix binaries can run on multiple platforms,
    e.g., &#8216;universal binaries&#8217; that run on <code class="literal">powerpc-darwin</code> and
    <code class="literal">i686-darwin</code>.</p><p>It defaults to the canonical Nix system name detected by
    <code class="filename">configure</code> at build time.</p></dd><dt><span class="term"><code class="literal">fsync-metadata</code></span></dt><dd><p>If set to <code class="literal">true</code>, changes to the
    Nix store metadata (in <code class="filename">/nix/var/nix/db</code>) are
    synchronously flushed to disk.  This improves robustness in case
    of system crashes, but reduces performance.  The default is
    <code class="literal">false</code>.</p></dd></dl></div><p>

</p></div><div class="section" title="A.4. Main commands"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481080"></a>A.4. Main commands</h2></div></div></div><div class="refentry" title="nix-env"><a name="sec-nix-env"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-env &#8212; manipulate or query Nix user environments</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-env</code>  [<code class="option">--help</code>] [<code class="option">--version</code>] [<code class="option">--verbose</code>...] [<code class="option">-v</code>...] [<code class="option">--no-build-output</code>] [<code class="option">-Q</code>] [
  { <code class="option">--max-jobs</code>  |   <code class="option">-j</code> }
  <em class="replaceable"><code>number</code></em>
] [
  [<code class="option">--cores</code>]
  <em class="replaceable"><code>number</code></em>
] [
  [<code class="option">--max-silent-time</code>]
  <em class="replaceable"><code>number</code></em>
] [<code class="option">--keep-going</code>] [<code class="option">-k</code>] [<code class="option">--keep-failed</code>] [<code class="option">-K</code>] [<code class="option">--fallback</code>] [<code class="option">--readonly-mode</code>] [<code class="option">--log-type</code> <em class="replaceable"><code>type</code></em>] [<code class="option">--show-trace</code>]<br> [<code class="option">--arg</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>value</code></em>] [<code class="option">--argstr</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>value</code></em>] [
      { <code class="option">--file</code>  |   <code class="option">-f</code> }
      <em class="replaceable"><code>path</code></em>
    ] [
      { <code class="option">--profile</code>  |   <code class="option">-p</code> }
      <em class="replaceable"><code>path</code></em>
    ] [
       <code class="option">--system-filter</code> 
      <em class="replaceable"><code>system</code></em>
    ] [<code class="option">--dry-run</code>]  <em class="replaceable"><code>operation</code></em>  [<em class="replaceable"><code>options</code></em>...] [<em class="replaceable"><code>arguments</code></em>...]</p></div></div><div class="refsection" title="Description"><a name="id494140"></a><h2>Description</h2><p>The command <span class="command"><strong>nix-env</strong></span> is used to manipulate Nix
user environments.  User environments are sets of software packages
available to a user at some point in time.  In other words, they are a
synthesised view of the programs available in the Nix store.  There
may be many user environments: different users can have different
environments, and individual users can switch between different
environments.</p><p><span class="command"><strong>nix-env</strong></span> takes exactly one
<span class="emphasis"><em>operation</em></span> flag which indicates the subcommand to
be performed.  These are documented below.</p></div><div class="refsection" title="Common options"><a name="id494168"></a><h2>Common options</h2><p>This section lists the options that are common to all
operations.  These options are allowed for every subcommand, though
they may not always have an effect.  See also <a class="xref" href="#sec-common-options" title="A.1. Common options">Section A.1, &#8220;Common options&#8221;</a>.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--file</code>, </span><span class="term"><code class="option">-f</code></span></dt><dd><p>Specifies the Nix expression (designated below as
    the <span class="emphasis"><em>active Nix expression</em></span>) used by the
    <code class="option">--install</code>, <code class="option">--upgrade</code>, and
    <code class="option">--query --available</code> operations to obtain
    derivations.  The default is
    <code class="filename">~/.nix-defexpr</code>.</p></dd><dt><span class="term"><code class="option">--profile</code>, </span><span class="term"><code class="option">-p</code></span></dt><dd><p>Specifies the profile to be used by those
    operations that operate on a profile (designated below as the
    <span class="emphasis"><em>active profile</em></span>).  A profile is sequence of
    user environments called <span class="emphasis"><em>generations</em></span>, one of
    which is the <span class="emphasis"><em>current generation</em></span>.  The default
    profile is the target of the symbolic link
    <code class="filename">~/.nix-profile</code> (see below).</p></dd><dt><span class="term"><code class="option">--dry-run</code></span></dt><dd><p>For the <code class="option">--install</code>,
    <code class="option">--upgrade</code>, <code class="option">--uninstall</code>,
    <code class="option">--switch-generation</code> and
    <code class="option">--rollback</code> operations, this flag will cause
    <span class="command"><strong>nix-env</strong></span> to print what
    <span class="emphasis"><em>would</em></span> be done if this flag had not been
    specified, without actually doing it.</p><p><code class="option">--dry-run</code> also prints out which paths will
    be <a class="link" href="#gloss-substitute" title="substitute">substituted</a> (i.e.,
    downloaded) and which paths will be built from source (because no
    substitute is available).</p></dd><dt><span class="term"><code class="option">--system-filter</code> <em class="replaceable"><code>system</code></em></span></dt><dd><p>By default, operations such as <code class="option">--query
    --available</code> only include derivations matching the current
    platform.  This option allows you to use derivations for the
    specified platform <em class="replaceable"><code>system</code></em>.  The special
    value <code class="literal">*</code> causes derivations for any platform to
    be included.</p></dd></dl></div></div><div class="refsection" title="Files"><a name="id494331"></a><h2>Files</h2><div class="variablelist"><dl><dt><span class="term"><code class="filename">~/.nix-defexpr</code></span></dt><dd><p>A directory that contains the default Nix
    expressions used by the <code class="option">--install</code>,
    <code class="option">--upgrade</code>, and <code class="option">--query
    --available</code> operations to obtain derivations.  The
    <code class="option">--file</code> option may be used to override this
    default.</p><p>The Nix expressions in this directory are combined into a
    single attribute set, with each file as an attribute that has the
    name of the file.  Thus, if <code class="filename">~/.nix-defexpr</code>
    contains two files, <code class="filename">foo</code> and
    <code class="filename">bar</code>, then the default Nix expression will
    essentially be

</p><pre class="programlisting">
{
  foo = import ~/.nix-defexpr/foo;
  bar = import ~/.nix-defexpr/bar;
}</pre><p>

    </p><p>The command <span class="command"><strong>nix-channel</strong></span> places symlinks
    to the downloaded Nix expressions from each subscribed channel in
    this directory.</p></dd><dt><span class="term"><code class="filename">~/.nix-profile</code></span></dt><dd><p>A symbolic link to the user's current profile.  By
    default, this symlink points to
    <code class="filename"><em class="replaceable"><code>prefix</code></em>/var/nix/profiles/default</code>.
    The <code class="envar">PATH</code> environment variable should include
    <code class="filename">~/.nix-profile/bin</code> for the user environment
    to be visible to the user.</p></dd></dl></div></div><div class="refsection" title="Operation --install"><a name="rsec-nix-env-install"></a><h2>Operation <code class="option">--install</code></h2><div class="refsection" title="Synopsis"><a name="id494440"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>  { <code class="option">--install</code>  |   <code class="option">-i</code> } [
    { <code class="option">--prebuilt-only</code>  |   <code class="option">-b</code> }
  ] [
    { <code class="option">--attr</code>  |   <code class="option">-A</code> }
  ] [<code class="option">--from-expression</code>] [<code class="option">-E</code>] [<code class="option">--from-profile</code> <em class="replaceable"><code>path</code></em>] [ <code class="option">--preserve-installed</code>  |   <code class="option">-P</code> ]  <em class="replaceable"><code>args</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id494575"></a><h3>Description</h3><p>The install operation creates a new user environment, based on
the current generation of the active profile, to which a set of store
paths described by <em class="replaceable"><code>args</code></em> is added.  The
arguments <em class="replaceable"><code>args</code></em> map to store paths in a
number of possible ways:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>By default, <em class="replaceable"><code>args</code></em> is a set
  of derivation names denoting derivations in the active Nix
  expression.  These are realised, and the resulting output paths are
  installed.  Currently installed derivations with a name equal to the
  name of a derivation being added are removed unless the option
  <code class="option">--preserve-installed</code> is
  specified.</p><p>If there are multiple derivations matching a name in
  <em class="replaceable"><code>args</code></em> that have the same name (e.g.,
  <code class="literal">gcc-3.3.6</code> and <code class="literal">gcc-4.1.1</code>), then
  the derivation with the highest <span class="emphasis"><em>priority</em></span> is
  used.  A derivation can define a priority by declaring the
  <code class="varname">meta.priority</code> attribute.  This attribute should
  be a number, with a higher value denoting a lower priority.  The
  default priority is <code class="literal">0</code>.</p><p>If there are multiple matching derivations with the same
  priority, then the derivation with the highest version will be
  installed.</p><p>You can force the installation of multiple derivations with
  the same name by being specific about the versions.  For instance,
  <code class="literal">nix-env -i gcc-3.3.6 gcc-4.1.1</code> will install both
  version of GCC (and will probably cause a user environment
  conflict!).</p></li><li class="listitem"><p>If <a class="link" href="#opt-attr"><code class="option">--attr</code></a>
  (<code class="option">-A</code>) is specified, the arguments are
  <span class="emphasis"><em>attribute paths</em></span> that select attributes from the
  top-level Nix expression.  This is faster than using derivation
  names and unambiguous.  To find out the attribute paths of available
  packages, use <code class="literal">nix-env -qaA '*'</code>.</p></li><li class="listitem"><p>If <code class="option">--from-profile</code>
  <em class="replaceable"><code>path</code></em> is given,
  <em class="replaceable"><code>args</code></em> is a set of names denoting installed
  store paths in the profile <em class="replaceable"><code>path</code></em>.  This is
  an easy way to copy user environment elements from one profile to
  another.</p></li><li class="listitem"><p>If <code class="option">--from-expression</code> is given,
  <em class="replaceable"><code>args</code></em> are Nix <a class="link" href="#ss-functions" title="Functions">functions</a> that are called with the
  active Nix expression as their single argument.  The derivations
  returned by those function calls are installed.  This allows
  derivations to be specified in a unambiguous way, which is necessary
  if there are multiple derivations with the same
  name.</p></li><li class="listitem"><p>If <em class="replaceable"><code>args</code></em> are store
  derivations, then these are <a class="link" href="#rsec-nix-store-realise" title="Operation --realise">realised</a>, and the resulting
  output paths are installed.</p></li><li class="listitem"><p>If <em class="replaceable"><code>args</code></em> are store paths
  that are not store derivations, then these are <a class="link" href="#rsec-nix-store-realise" title="Operation --realise">realised</a> and
  installed.</p></li></ul></div><p>

</p></div><div class="refsection" title="Flags"><a name="id494750"></a><h3>Flags</h3><div class="variablelist"><dl><dt><span class="term"><code class="option">--prebuild-only</code> / <code class="option">-b</code></span></dt><dd><p>Use only derivations for which a substitute is
    registered, i.e., there is a pre-built binary available that can
    be downloaded in lieu of building the derivation.  Thus, no
    packages will be built from source.</p></dd><dt><span class="term"><code class="option">--preserve-installed</code>, </span><span class="term"><code class="option">-P</code></span></dt><dd><p>Do not remove derivations with a name matching one
    of the derivations being installed.  Usually, trying to have two
    versions of the same package installed in the same generation of a
    profile will lead to an error in building the generation, due to
    file name clashes between the two versions.  However, this is not
    the case for all packages.</p></dd></dl></div></div><div class="refsection" title="Examples"><a name="refsec-nix-env-install-examples"></a><h3>Examples</h3><p>To install a specific version of <span class="command"><strong>gcc</strong></span> from the
active Nix expression:

</p><pre class="screen">
$ nix-env --install gcc-3.3.2 
installing `gcc-3.3.2'
uninstalling `gcc-3.1'</pre><p>

Note the the previously installed version is removed, since
<code class="option">--preserve-installed</code> was not specified.</p><p>To install an arbitrary version:

</p><pre class="screen">
$ nix-env --install gcc
installing `gcc-3.3.2'</pre><p>

</p><p>To install using a specific attribute:

</p><pre class="screen">
$ nix-env -i -A gcc40mips
$ nix-env -i -A xorg.xorgserver</pre><p>

</p><p>To install all derivations in the Nix expression <code class="filename">foo.nix</code>:

</p><pre class="screen">
$ nix-env -f ~/foo.nix -i '*'</pre><p>

</p><p>To copy the store path with symbolic name <code class="literal">gcc</code>
from another profile:

</p><pre class="screen">
$ nix-env -i --from-profile /nix/var/nix/profiles/foo -i gcc</pre><p>

</p><p>To install a specific store derivation (typically created by
<span class="command"><strong>nix-instantiate</strong></span>):

</p><pre class="screen">
$ nix-env -i /nix/store/fibjb1bfbpm5mrsxc4mh2d8n37sxh91i-gcc-3.4.3.drv</pre><p>

</p><p>To install a specific output path:

</p><pre class="screen">
$ nix-env -i /nix/store/y3cgx0xj1p4iv9x0pnnmdhr8iyg741vk-gcc-3.4.3</pre><p>

</p><p>To install from a Nix expression specified on the command-line:

</p><pre class="screen">
$ nix-env -f ./foo.nix -i -E \
    'f: (f {system = "i686-linux";}).subversionWithJava'</pre><p>

I.e., this evaluates to <code class="literal">(f: (f {system =
"i686-linux";}).subversionWithJava) (import ./foo.nix)</code>, thus
selecting the <code class="literal">subversionWithJava</code> attribute from the
attribute set returned by calling the function defined in
<code class="filename">./foo.nix</code>.</p><p>A dry-run tells you which paths will be downloaded or built from
source:

</p><pre class="screen">
$ nix-env -f pkgs/top-level/all-packages.nix -i f-spot --dry-run
(dry run; not doing anything)
installing `f-spot-0.0.10'
the following derivations will be built:
  /nix/store/0g63jv9aagwbgci4nnzs2dkxqz84kdja-libgnomeprintui-2.12.1.tar.bz2.drv
  /nix/store/0gfarvxq6sannsdw8a1ir40j1ys2mqb4-ORBit2-2.14.2.tar.bz2.drv
  /nix/store/0i9gs5zc04668qiy60ga2rc16abkj7g8-sqlite-2.8.17.drv
  <em class="replaceable"><code>...</code></em>
the following paths will be substituted:
  /nix/store/8zbipvm4gp9jfqh9nnk1n3bary1a37gs-perl-XML-Parser-2.34
  /nix/store/b8a2bg7gnyvvvjjibp4axg9x1hzkw36c-mono-1.1.4
  <em class="replaceable"><code>...</code></em></pre><p>
  
</p></div></div><div class="refsection" title="Operation --upgrade"><a name="rsec-nix-env-upgrade"></a><h2>Operation <code class="option">--upgrade</code></h2><div class="refsection" title="Synopsis"><a name="id494936"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>  { <code class="option">--upgrade</code>  |   <code class="option">-u</code> } [
    { <code class="option">--prebuilt-only</code>  |   <code class="option">-b</code> }
  ] [
    { <code class="option">--attr</code>  |   <code class="option">-A</code> }
  ] [<code class="option">--from-expression</code>] [<code class="option">-E</code>] [<code class="option">--from-profile</code> <em class="replaceable"><code>path</code></em>] [ <code class="option">--lt</code>  |   <code class="option">--leq</code>  |   <code class="option">--eq</code>  |   <code class="option">--always</code> ]  <em class="replaceable"><code>args</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id495085"></a><h3>Description</h3><p>The upgrade operation creates a new user environment, based on
the current generation of the active profile, in which all store paths
are replaced for which there are newer versions in the set of paths
described by <em class="replaceable"><code>args</code></em>.  Paths for which there
are no newer versions are left untouched; this is not an error.  It is
also not an error if an element of <em class="replaceable"><code>args</code></em>
matches no installed derivations.</p><p>For a description of how <em class="replaceable"><code>args</code></em> is
mapped to a set of store paths, see <a class="link" href="#rsec-nix-env-install" title="Operation --install"><code class="option">--install</code></a>.  If
<em class="replaceable"><code>args</code></em> describes multiple store paths with
the same symbolic name, only the one with the highest version is
installed.</p></div><div class="refsection" title="Flags"><a name="id495125"></a><h3>Flags</h3><div class="variablelist"><dl><dt><span class="term"><code class="option">--lt</code></span></dt><dd><p>Only upgrade a derivation to newer versions.  This
    is the default.</p></dd><dt><span class="term"><code class="option">--leq</code></span></dt><dd><p>In addition to upgrading to newer versions, also
    &#8220;upgrade&#8221; to derivations that have the same version.  Version are
    not a unique identification of a derivation, so there may be many
    derivations that have the same version.  This flag may be useful
    to force &#8220;synchronisation&#8221; between the installed and available
    derivations.</p></dd><dt><span class="term"><code class="option">--eq</code></span></dt><dd><p><span class="emphasis"><em>Only</em></span> &#8220;upgrade&#8221; to derivations
    that have the same version.  This may not seem very useful, but it
    actually is, e.g., when there is a new release of Nixpkgs and you
    want to replace installed applications with the same versions
    built against newer dependencies (to reduce the number of
    dependencies floating around on your system).</p></dd><dt><span class="term"><code class="option">--always</code></span></dt><dd><p>In addition to upgrading to newer versions, also
    &#8220;upgrade&#8221; to derivations that have the same or a lower version.
    I.e., derivations may actually be downgraded depending on what is
    available in the active Nix expression.</p></dd></dl></div><p>For the other flags, see <code class="option"><a class="option" href="#rsec-nix-env-install" title="Operation --install">--install</a></code>.</p></div><div class="refsection" title="Examples"><a name="id495203"></a><h3>Examples</h3><pre class="screen">
$ nix-env --upgrade gcc
upgrading `gcc-3.3.1' to `gcc-3.4'

$ nix-env -u gcc-3.3.2 --always <em class="lineannotation"><span class="lineannotation">(switch to a specific version)</span></em>
upgrading `gcc-3.4' to `gcc-3.3.2'

$ nix-env --upgrade pan
<em class="lineannotation"><span class="lineannotation">(no upgrades available, so nothing happens)</span></em>

$ nix-env -u '*' <em class="lineannotation"><span class="lineannotation">(try to upgrade everything)</span></em>
upgrading `hello-2.1.2' to `hello-2.1.3'
upgrading `mozilla-1.2' to `mozilla-1.4'</pre></div><div class="refsection" title="Versions"><a name="ssec-version-comparisons"></a><h3>Versions</h3><p>The upgrade operation determines whether a derivation
<code class="varname">y</code> is an upgrade of a derivation
<code class="varname">x</code> by looking at their respective
<code class="literal">name</code> attributes.  The names (e.g.,
<code class="literal">gcc-3.3.1</code> are split into two parts: the package
name (<code class="literal">gcc</code>), and the version
(<code class="literal">3.3.1</code>).  The version part starts after the first
dash not following by a letter.  <code class="varname">x</code> is considered an
upgrade of <code class="varname">y</code> if their package names match, and the
version of <code class="varname">y</code> is higher that that of
<code class="varname">x</code>.</p><p>The versions are compared by splitting them into contiguous
components of numbers and letters.  E.g., <code class="literal">3.3.1pre5</code>
is split into <code class="literal">[3, 3, 1, "pre", 5]</code>.  These lists are
then compared lexicographically (from left to right).  Corresponding
components <code class="varname">a</code> and <code class="varname">b</code> are compared
as follows.  If they are both numbers, integer comparison is used.  If
<code class="varname">a</code> is an empty string and <code class="varname">b</code> is a
number, <code class="varname">a</code> is considered less than
<code class="varname">b</code>.  The special string component
<code class="literal">pre</code> (for <span class="emphasis"><em>pre-release</em></span>) is
considered to be less than other components.  String components are
considered less than number components.  Otherwise, they are compared
lexicographically (i.e., using case-sensitive string comparison).</p><p>This is illustrated by the following examples:

</p><pre class="screen">
1.0 &lt; 2.3
2.1 &lt; 2.3
2.3 = 2.3
2.5 &gt; 2.3
3.1 &gt; 2.3
2.3.1 &gt; 2.3
2.3.1 &gt; 2.3a
2.3pre1 &lt; 2.3
2.3pre3 &lt; 2.3pre12
2.3a &lt; 2.3c
2.3pre1 &lt; 2.3c
2.3pre1 &lt; 2.3q</pre><p>
        
</p></div></div><div class="refsection" title="Operation --uninstall"><a name="id495336"></a><h2>Operation <code class="option">--uninstall</code></h2><div class="refsection" title="Synopsis"><a name="id495344"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>  { <code class="option">--uninstall</code>  |   <code class="option">-e</code> }  <em class="replaceable"><code>drvnames</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id495387"></a><h3>Description</h3><p>The uninstall operation creates a new user environment, based on
the current generation of the active profile, from which the store
paths designated by the symbolic names
<em class="replaceable"><code>names</code></em> are removed.</p></div><div class="refsection" title="Examples"><a name="id495402"></a><h3>Examples</h3><pre class="screen">
$ nix-env --uninstall gcc
$ nix-env -e '*' <em class="lineannotation"><span class="lineannotation">(remove everything)</span></em></pre></div></div><div class="refsection" title="Operation --set-flag"><a name="rsec-nix-env-set-flag"></a><h2>Operation <code class="option">--set-flag</code></h2><div class="refsection" title="Synopsis"><a name="id495429"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>   <code class="option">--set-flag</code>   <em class="replaceable"><code>name</code></em>   <em class="replaceable"><code>value</code></em>   <em class="replaceable"><code>drvnames</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id495473"></a><h3>Description</h3><p>The <code class="option">--set-flag</code> operation allows meta attributes
of installed packages to be modified.  There are several attributes
that can be usefully modified, because they affect the behaviour of
<span class="command"><strong>nix-env</strong></span> or the user environment build
script:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="varname">priority</code> can be changed to
  resolve filename clashes.  The user environment build script uses
  the <code class="varname">meta.priority</code> attribute of derivations to
  resolve filename collisions between packages.  Lower priority values
  denote a higher priority.  For instance, the GCC wrapper package and
  the Binutils package in Nixpkgs both have a file
  <code class="filename">bin/ld</code>, so previously if you tried to install
  both you would get a collision.  Now, on the other hand, the GCC
  wrapper declares a higher priority than Binutils, so the former&#8217;s
  <code class="filename">bin/ld</code> is symlinked in the user
  environment.</p></li><li class="listitem"><p><code class="varname">keep</code> can be set to
  <code class="literal">true</code> to prevent the package from being upgraded
  or replaced.  This is useful if you want to hang on to an older
  version of a package.</p></li><li class="listitem"><p><code class="varname">active</code> can be set to
  <code class="literal">false</code> to &#8220;disable&#8221; the package.  That is, no
  symlinks will be generated to the files of the package, but it
  remains part of the profile (so it won&#8217;t be garbage-collected).  It
  can be set back to <code class="literal">true</code> to re-enable the
  package.</p></li></ul></div><p>

</p></div><div class="refsection" title="Examples"><a name="id495546"></a><h3>Examples</h3><p>To prevent the currently installed Firefox from being upgraded:

</p><pre class="screen">
$ nix-env --set-flag keep true firefox</pre><p>

After this, <span class="command"><strong>nix-env -u</strong></span> will ignore Firefox.</p><p>To disable the currently installed Firefox, then install a new
Firefox while the old remains part of the profile:

</p><pre class="screen">
$ nix-env -q \*
firefox-2.0.0.9 <em class="lineannotation"><span class="lineannotation">(the current one)</span></em>

$ nix-env --preserve-installed -i firefox-2.0.0.11
installing `firefox-2.0.0.11'
building path(s) `/nix/store/myy0y59q3ig70dgq37jqwg1j0rsapzsl-user-environment'
Collission between `/nix/store/<em class="replaceable"><code>...</code></em>-firefox-2.0.0.11/bin/firefox'
  and `/nix/store/<em class="replaceable"><code>...</code></em>-firefox-2.0.0.9/bin/firefox'.
<em class="lineannotation"><span class="lineannotation">(i.e., can&#8217;t have two active at the same time)</span></em>

$ nix-env --set-flag active false firefox
setting flag on `firefox-2.0.0.9'

$ nix-env --preserve-installed -i firefox-2.0.0.11
installing `firefox-2.0.0.11'

$ nix-env -q \*
firefox-2.0.0.11 <em class="lineannotation"><span class="lineannotation">(the enabled one)</span></em>
firefox-2.0.0.9 <em class="lineannotation"><span class="lineannotation">(the disabled one)</span></em></pre><p>

</p><p>To make files from <code class="literal">binutils</code> take precedence
over files from <code class="literal">gcc</code>:

</p><pre class="screen">
$ nix-env --set-flag priority 5 binutils
$ nix-env --set-flag priority 10 gcc</pre><p>

</p></div></div><div class="refsection" title="Operation --query"><a name="id495617"></a><h2>Operation <code class="option">--query</code></h2><div class="refsection" title="Synopsis"><a name="id495624"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>  { <code class="option">--query</code>  |   <code class="option">-q</code> } [ <code class="option">--installed</code>  |   <code class="option">--available</code>  |   <code class="option">-a</code> ]<br> [
    { <code class="option">--status</code>  |   <code class="option">-s</code> }
  ] [
    { <code class="option">--attr-path</code>  |   <code class="option">-P</code> }
  ] [<code class="option">--no-name</code>] [
    { <code class="option">--compare-versions</code>  |   <code class="option">-c</code> }
  ] [<code class="option">--system</code>] [<code class="option">--drv-path</code>] [<code class="option">--out-path</code>] [<code class="option">--description</code>] [<code class="option">--meta</code>]<br> [<code class="option">--xml</code>] [
    { <code class="option">--prebuilt-only</code>  |   <code class="option">-b</code> }
  ] [
    { <code class="option">--attr</code>  |   <code class="option">-A</code> }
    <em class="replaceable"><code>attribute-path</code></em>
  ]<br>  <em class="replaceable"><code>names</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id495859"></a><h3>Description</h3><p>The query operation displays information about either the store
paths that are installed in the current generation of the active
profile (<code class="option">--installed</code>), or the derivations that are
available for installation in the active Nix expression
(<code class="option">--available</code>).  It only prints information about
derivations whose symbolic name matches one of
<em class="replaceable"><code>names</code></em>.  The wildcard <code class="literal">*</code>
shows all derivations.</p><p>The derivations are sorted by their <code class="literal">name</code>
attributes.</p></div><div class="refsection" title="Source selection"><a name="id495893"></a><h3>Source selection</h3><p>The following flags specify the set of things on which the query
operates.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--installed</code></span></dt><dd><p>The query operates on the store paths that are
    installed in the current generation of the active profile.  This
    is the default.</p></dd><dt><span class="term"><code class="option">--available</code>, </span><span class="term"><code class="option">-a</code></span></dt><dd><p>The query operates on the derivations that are
    available in the active Nix expression.</p></dd></dl></div></div><div class="refsection" title="Queries"><a name="id495938"></a><h3>Queries</h3><p>The following flags specify what information to display about
the selected derivations.  Multiple flags may be specified, in which
case the information is shown in the order given here.  Note that the
name of the derivation is shown unless <code class="option">--no-name</code> is
specified.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--xml</code></span></dt><dd><p>Print the result in an XML representation suitable
    for automatic processing by other tools.  The root element is
    called <code class="literal">items</code>, which contains a
    <code class="literal">item</code> element for each available or installed
    derivation.  The fields discussed below are all stored in
    attributes of the <code class="literal">item</code>
    elements.</p></dd><dt><span class="term"><code class="option">--prebuild-only</code> / <code class="option">-b</code></span></dt><dd><p>Show only derivations for which a substitute is
    registered, i.e., there is a pre-built binary available that can
    be downloaded in lieu of building the derivation.  Thus, this
    shows all packages that probably can be installed
    quickly.</p></dd><dt><span class="term"><code class="option">--status</code>, </span><span class="term"><code class="option">-s</code></span></dt><dd><p>Print the <span class="emphasis"><em>status</em></span> of the
    derivation.  The status consists of three characters.  The first
    is <code class="literal">I</code> or <code class="literal">-</code>, indicating
    whether the derivation is currently installed in the current
    generation of the active profile.  This is by definition the case
    for <code class="option">--installed</code>, but not for
    <code class="option">--available</code>.  The second is <code class="literal">P</code>
    or <code class="literal">-</code>, indicating whether the derivation is
    present on the system.  This indicates whether installation of an
    available derivation will require the derivation to be built.  The
    third is <code class="literal">S</code> or <code class="literal">-</code>, indicating
    whether a substitute is available for the
    derivation.</p></dd><dt><span class="term"><code class="option">--attr-path</code>, </span><span class="term"><code class="option">-P</code></span></dt><dd><p>Print the <span class="emphasis"><em>attribute path</em></span> of
    the derivation, which can be used to unambiguously select it using
    the <a class="link" href="#opt-attr"><code class="option">--attr</code> option</a>
    available in commands that install derivations like
    <code class="literal">nix-env --install</code>.</p></dd><dt><span class="term"><code class="option">--no-name</code></span></dt><dd><p>Suppress printing of the <code class="literal">name</code>
    attribute of each derivation.</p></dd><dt><span class="term"><code class="option">--compare-versions</code> /
  <code class="option">-c</code></span></dt><dd><p>Compare installed versions to available versions,
    or vice versa (if <code class="option">--available</code> is given).  This is
    useful for quickly seeing whether upgrades for installed
    packages are available in a Nix expression.  A column is added
    with the following meaning:

    </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">&lt;</code> <em class="replaceable"><code>version</code></em></span></dt><dd><p>A newer version of the package is available
        or installed.</p></dd><dt><span class="term"><code class="literal">=</code> <em class="replaceable"><code>version</code></em></span></dt><dd><p>At most the same version of the package is
        available or installed.</p></dd><dt><span class="term"><code class="literal">&gt;</code> <em class="replaceable"><code>version</code></em></span></dt><dd><p>Only older versions of the package are
        available or installed.</p></dd><dt><span class="term"><code class="literal">- ?</code></span></dt><dd><p>No version of the package is available or
        installed.</p></dd></dl></div><p>

    </p></dd><dt><span class="term"><code class="option">--system</code></span></dt><dd><p>Print the <code class="literal">system</code> attribute of
    the derivation.</p></dd><dt><span class="term"><code class="option">--drv-path</code></span></dt><dd><p>Print the path of the store
    derivation.</p></dd><dt><span class="term"><code class="option">--out-path</code></span></dt><dd><p>Print the output path of the
    derivation.</p></dd><dt><span class="term"><code class="option">--description</code></span></dt><dd><p>Print a short (one-line) description of the
    derivation, if available.  The description is taken from the
    <code class="literal">meta.description</code> attribute of the
    derivation.</p></dd><dt><span class="term"><code class="option">--meta</code></span></dt><dd><p>Print all of the meta-attributes of the
    derivation.  This option is only available with
    <code class="option">--xml</code>.</p></dd></dl></div></div><div class="refsection" title="Examples"><a name="id496266"></a><h3>Examples</h3><pre class="screen">
$ nix-env -q '*' <em class="lineannotation"><span class="lineannotation">(show installed derivations)</span></em>
bison-1.875c
docbook-xml-4.2
firefox-1.0.4
MPlayer-1.0pre7
ORBit2-2.8.3
...

$ nix-env -qa '*' <em class="lineannotation"><span class="lineannotation">(show available derivations)</span></em>
firefox-1.0.7
GConf-2.4.0.1
MPlayer-1.0pre7
ORBit2-2.8.3
...

$ nix-env -qas '*' <em class="lineannotation"><span class="lineannotation">(show status of available derivations)</span></em>
-P- firefox-1.0.7   <em class="lineannotation"><span class="lineannotation">(not installed but present)</span></em>
--S GConf-2.4.0.1   <em class="lineannotation"><span class="lineannotation">(not present, but there is a substitute for fast installation)</span></em>
--S MPlayer-1.0pre3 <em class="lineannotation"><span class="lineannotation">(i.e., this is not the installed MPlayer, even though the version is the same!)</span></em>
IP- ORBit2-2.8.3    <em class="lineannotation"><span class="lineannotation">(installed and by definition present)</span></em>
...

<em class="lineannotation"><span class="lineannotation">(show available derivations in the Nix expression foo.nix)</span></em>
$ nix-env -f ./foo.nix -qa '*' 
foo-1.2.3

$ nix-env -qc '*' <em class="lineannotation"><span class="lineannotation">(compare installed versions to what&#8217;s available)</span></em>
<em class="replaceable"><code>...</code></em>
acrobat-reader-7.0 - ?      <em class="lineannotation"><span class="lineannotation">(package is not available at all)</span></em>
autoconf-2.59      = 2.59   <em class="lineannotation"><span class="lineannotation">(same version)</span></em>
firefox-1.0.4      &lt; 1.0.7  <em class="lineannotation"><span class="lineannotation">(a more recent version is available)</span></em>
<em class="replaceable"><code>...</code></em>

<em class="lineannotation"><span class="lineannotation">(show info about a specific package, in XML)</span></em>
$ nix-env -qa --xml --description firefox 
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;items&gt;
  &lt;item attrPath="0.0.firefoxWrapper"
    description="Mozilla Firefox - the browser, reloaded (with various plugins)"
    name="firefox-1.5.0.7" system="i686-linux" /&gt;
&lt;/items&gt;</pre></div></div><div class="refsection" title="Operation --switch-profile"><a name="id496349"></a><h2>Operation <code class="option">--switch-profile</code></h2><div class="refsection" title="Synopsis"><a name="id496356"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>  { <code class="option">--switch-profile</code>  |   <code class="option">-S</code> } {<em class="replaceable"><code>path</code></em>}</p></div></div><div class="refsection" title="Description"><a name="id496397"></a><h3>Description</h3><p>This operation makes <em class="replaceable"><code>path</code></em> the current
profile for the user.  That is, the symlink
<code class="filename">~/.nix-profile</code> is made to point to
<em class="replaceable"><code>path</code></em>.</p></div><div class="refsection" title="Examples"><a name="id496418"></a><h3>Examples</h3><pre class="screen">
$ nix-env -S ~/my-profile</pre></div></div><div class="refsection" title="Operation --list-generations"><a name="id496433"></a><h2>Operation <code class="option">--list-generations</code></h2><div class="refsection" title="Synopsis"><a name="id496440"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>   <code class="option">--list-generations</code> </p></div></div><div class="refsection" title="Description"><a name="id496461"></a><h3>Description</h3><p>This operation print a list of all the currently existing
generations for the active profile.  These may be switched to using
the <code class="option">--switch-generation</code> operation.  It also prints
the creation date of the generation, and indicates the current
generation.</p></div><div class="refsection" title="Examples"><a name="id496476"></a><h3>Examples</h3><pre class="screen">
$ nix-env --list-generations
  95   2004-02-06 11:48:24
  96   2004-02-06 11:49:01
  97   2004-02-06 16:22:45
  98   2004-02-06 16:24:33   (current)</pre></div></div><div class="refsection" title="Operation --delete-generations"><a name="id496491"></a><h2>Operation <code class="option">--delete-generations</code></h2><div class="refsection" title="Synopsis"><a name="id496498"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>   <code class="option">--delete-generations</code>   <em class="replaceable"><code>generations</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id496528"></a><h3>Description</h3><p>This operation deletes the specified generations of the current
profile.  The generations can be a list of generation numbers, or the
special value <code class="literal">old</code> to delete all non-current
generations.  Periodically deleting old generations is important to
make garbage collection effective.</p></div><div class="refsection" title="Examples"><a name="id496544"></a><h3>Examples</h3><pre class="screen">
$ nix-env --delete-generations 3 4 8

$ nix-env -p other_profile --delete-generations old</pre></div></div><div class="refsection" title="Operation --switch-generation"><a name="id496559"></a><h2>Operation <code class="option">--switch-generation</code></h2><div class="refsection" title="Synopsis"><a name="id496566"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>  { <code class="option">--switch-generation</code>  |   <code class="option">-G</code> } {<em class="replaceable"><code>generation</code></em>}</p></div></div><div class="refsection" title="Description"><a name="id496607"></a><h3>Description</h3><p>This operation makes generation number
<em class="replaceable"><code>generation</code></em> the current generation of the
active profile.  That is, if the
<code class="filename"><em class="replaceable"><code>profile</code></em></code> is the path to
the active profile, then the symlink
<code class="filename"><em class="replaceable"><code>profile</code></em></code> is made to
point to
<code class="filename"><em class="replaceable"><code>profile</code></em>-<em class="replaceable"><code>generation</code></em>-link</code>,
which is in turn a symlink to the actual user environment in the Nix
store.</p><p>Switching will fail if the specified generation does not exist.</p></div><div class="refsection" title="Examples"><a name="id496645"></a><h3>Examples</h3><pre class="screen">
$ nix-env -G 42
switching from generation 50 to 42</pre></div></div><div class="refsection" title="Operation --rollback"><a name="id496660"></a><h2>Operation <code class="option">--rollback</code></h2><div class="refsection" title="Synopsis"><a name="id496667"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-env</code>   <code class="option">--rollback</code> </p></div></div><div class="refsection" title="Description"><a name="id496688"></a><h3>Description</h3><p>This operation switches to the &#8220;previous&#8221; generation of the
active profile, that is, the highest numbered generation lower than
the current generation, if it exists.  It is just a convenience
wrapper around <code class="option">--list-generations</code> and
<code class="option">--switch-generation</code>.</p></div><div class="refsection" title="Examples"><a name="id496707"></a><h3>Examples</h3><pre class="screen">
$ nix-env --rollback
switching from generation 92 to 91

$ nix-env --rolback
error: no generation older than the current (91) exists</pre></div></div></div><div class="refentry" title="nix-instantiate"><div class="refentry.separator"><hr></div><a name="sec-nix-instantiate"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-instantiate &#8212; instantiate store derivations from Nix expressions</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-instantiate</code>  [<code class="option">--help</code>] [<code class="option">--version</code>] [<code class="option">--verbose</code>...] [<code class="option">-v</code>...] [<code class="option">--no-build-output</code>] [<code class="option">-Q</code>] [
  { <code class="option">--max-jobs</code>  |   <code class="option">-j</code> }
  <em class="replaceable"><code>number</code></em>
] [
  [<code class="option">--cores</code>]
  <em class="replaceable"><code>number</code></em>
] [
  [<code class="option">--max-silent-time</code>]
  <em class="replaceable"><code>number</code></em>
] [<code class="option">--keep-going</code>] [<code class="option">-k</code>] [<code class="option">--keep-failed</code>] [<code class="option">-K</code>] [<code class="option">--fallback</code>] [<code class="option">--readonly-mode</code>] [<code class="option">--log-type</code> <em class="replaceable"><code>type</code></em>] [<code class="option">--show-trace</code>]<br> [<code class="option">--arg</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>value</code></em>] [
      { <code class="option">--attr</code>  |   <code class="option">-A</code> }
      <em class="replaceable"><code>attrPath</code></em>
    ] [<code class="option">--add-root</code> <em class="replaceable"><code>path</code></em>] [<code class="option">--indirect</code>] [
      { <code class="option">--parse-only</code>  |   
          <code class="option">--eval-only</code>
           [<code class="option">--strict</code>]
         }
       [<code class="option">--xml</code>]
    ]  <em class="replaceable"><code>files</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id490437"></a><h2>Description</h2><p>The command <span class="command"><strong>nix-instantiate</strong></span> generates <a class="link" href="#gloss-derivation" title="derivation">store derivations</a> from (high-level)
Nix expressions.  It loads and evaluates the Nix expressions in each
of <em class="replaceable"><code>files</code></em>.  Each top-level expression should
evaluate to a derivation, a list of derivations, or a set of
derivations.  The paths of the resulting store derivations are printed
on standard output.</p><p>If <em class="replaceable"><code>files</code></em> is the character
<code class="literal">-</code>, then a Nix expression will be read from standard
input.</p><p>Most users and developers don&#8217;t need to use this command
(<span class="command"><strong>nix-env</strong></span> and <span class="command"><strong>nix-build</strong></span> perform
store derivation instantiation from Nix expressions automatically).
It is most commonly used for implementing new deployment
policies.</p><p>See also <a class="xref" href="#sec-common-options" title="A.1. Common options">Section A.1, &#8220;Common options&#8221;</a> for a list of
common options.</p></div><div class="refsection" title="Options"><a name="id489516"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">--add-root</code> <em class="replaceable"><code>path</code></em>, </span><span class="term"><code class="option">--indirect</code></span></dt><dd><p>See the <a class="link" href="#opt-add-root">corresponding
    options</a> in <span class="command"><strong>nix-store</strong></span>.</p></dd><dt><span class="term"><code class="option">--parse-only</code></span></dt><dd><p>Just parse the input files, and print their
    abstract syntax trees on standard output in ATerm
    format.</p></dd><dt><span class="term"><code class="option">--eval-only</code></span></dt><dd><p>Just parse and evaluate the input files, and print
    the resulting values on standard output.  No instantiation of
    store derivations takes place.</p></dd><dt><span class="term"><code class="option">--xml</code></span></dt><dd><p>When used with <code class="option">--parse-only</code> and
    <code class="option">--eval-only</code>, print the resulting expression as an
    XML representation of the abstract syntax tree rather than as an
    ATerm.  The schema is the same as that used by the <a class="link" href="#builtin-toXML"><code class="function">toXML</code>
    built-in</a>.</p></dd><dt><span class="term"><code class="option">--strict</code></span></dt><dd><p>When used with <code class="option">--eval-only</code>,
    recursively evaluate list elements and attributes.  Normally, such
    sub-expressions are left unevaluated (since the Nix expression
    language is lazy).</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>This option can cause non-termination, because lazy
    data structures can be infinitely large.</p></div></dd></dl></div></div><div class="refsection" title="Examples"><a name="id487492"></a><h2>Examples</h2><p>Instantiating store derivations from a Nix expression, and
building them using <span class="command"><strong>nix-store</strong></span>:

</p><pre class="screen">
$ nix-instantiate test.nix <em class="lineannotation"><span class="lineannotation">(instantiate)</span></em>
/nix/store/cigxbmvy6dzix98dxxh9b6shg7ar5bvs-perl-BerkeleyDB-0.26.drv

$ nix-store -r $(nix-instantiate test.nix) <em class="lineannotation"><span class="lineannotation">(build)</span></em>
<em class="replaceable"><code>...</code></em>
/nix/store/qhqk4n8ci095g3sdp93x7rgwyh9rdvgk-perl-BerkeleyDB-0.26 <em class="lineannotation"><span class="lineannotation">(output path)</span></em>

$ ls -l /nix/store/qhqk4n8ci095g3sdp93x7rgwyh9rdvgk-perl-BerkeleyDB-0.26
dr-xr-xr-x    2 eelco    users        4096 1970-01-01 01:00 lib
...</pre><p>

</p><p>Parsing and evaluating Nix expressions:

</p><pre class="screen">
$ echo '"foo" + "bar"' | nix-instantiate --parse-only -
OpPlus(Str("foo"),Str("bar"))

$ echo '"foo" + "bar"' | nix-instantiate --eval-only -
Str("foobar")

$ echo '"foo" + "bar"' | nix-instantiate --eval-only --xml -
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;expr&gt;
  &lt;string value="foobar" /&gt;
&lt;/expr&gt;</pre><p>

</p><p>The difference between non-strict and strict evaluation:

</p><pre class="screen">
$ echo 'rec { x = "foo"; y = x; }' | nix-instantiate --eval-only --xml -
<em class="replaceable"><code>...</code></em>
    &lt;attr name="x"&gt;
      &lt;string value="foo" /&gt;
    &lt;/attr&gt;
    &lt;attr name="y"&gt;
      &lt;unevaluated /&gt;
    &lt;/attr&gt;
<em class="replaceable"><code>...</code></em></pre><p>

Note that <code class="varname">y</code> is left unevaluated (the XML
representation doesn&#8217;t attempt to show non-normal forms).

</p><pre class="screen">
$ echo 'rec { x = "foo"; y = x; }' | nix-instantiate --eval-only --xml --strict -
<em class="replaceable"><code>...</code></em>
    &lt;attr name="x"&gt;
      &lt;string value="foo" /&gt;
    &lt;/attr&gt;
    &lt;attr name="y"&gt;
      &lt;string value="foo" /&gt;
    &lt;/attr&gt;
<em class="replaceable"><code>...</code></em></pre><p>

</p></div></div><div class="refentry" title="nix-store"><div class="refentry.separator"><hr></div><a name="sec-nix-store"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-store &#8212; manipulate or query the Nix store</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-store</code>  [<code class="option">--help</code>] [<code class="option">--version</code>] [<code class="option">--verbose</code>...] [<code class="option">-v</code>...] [<code class="option">--no-build-output</code>] [<code class="option">-Q</code>] [
  { <code class="option">--max-jobs</code>  |   <code class="option">-j</code> }
  <em class="replaceable"><code>number</code></em>
] [
  [<code class="option">--cores</code>]
  <em class="replaceable"><code>number</code></em>
] [
  [<code class="option">--max-silent-time</code>]
  <em class="replaceable"><code>number</code></em>
] [<code class="option">--keep-going</code>] [<code class="option">-k</code>] [<code class="option">--keep-failed</code>] [<code class="option">-K</code>] [<code class="option">--fallback</code>] [<code class="option">--readonly-mode</code>] [<code class="option">--log-type</code> <em class="replaceable"><code>type</code></em>] [<code class="option">--show-trace</code>]<br> [<code class="option">--add-root</code> <em class="replaceable"><code>path</code></em>] [<code class="option">--indirect</code>]  <em class="replaceable"><code>operation</code></em>  [<em class="replaceable"><code>options</code></em>...] [<em class="replaceable"><code>arguments</code></em>...]</p></div></div><div class="refsection" title="Description"><a name="id487259"></a><h2>Description</h2><p>The command <span class="command"><strong>nix-store</strong></span> performs primitive
operations on the Nix store.  You generally do not need to run this
command manually.</p><p><span class="command"><strong>nix-store</strong></span> takes exactly one
<span class="emphasis"><em>operation</em></span> flag which indicates the subcommand to
be performed.  These are documented below.</p></div><div class="refsection" title="Common options"><a name="id487286"></a><h2>Common options</h2><p>This section lists the options that are common to all
operations.  These options are allowed for every subcommand, though
they may not always have an effect.  See also <a class="xref" href="#sec-common-options" title="A.1. Common options">Section A.1, &#8220;Common options&#8221;</a> for a list of common options.</p><div class="variablelist"><dl><dt><a name="opt-add-root"></a><span class="term"><code class="option">--add-root</code> <em class="replaceable"><code>path</code></em></span></dt><dd><p>Causes the result of a realisation
    (<code class="option">--realise</code> and <code class="option">--force-realise</code>)
    to be registered as a root of the garbage collector (see <a class="xref" href="#ssec-gc-roots" title="4.3.1. Garbage collector roots">Section 4.3.1, &#8220;Garbage collector roots&#8221;</a>).  The root is stored in
    <em class="replaceable"><code>path</code></em>, which must be inside a directory
    that is scanned for roots by the garbage collector (i.e.,
    typically in a subdirectory of
    <code class="filename">/nix/var/nix/gcroots/</code>)
    <span class="emphasis"><em>unless</em></span> the <code class="option">--indirect</code> flag
    is used.</p><p>If there are multiple results, then multiple symlinks will
    be created by sequentially numbering symlinks beyond the first one
    (e.g., <code class="filename">foo</code>, <code class="filename">foo-2</code>,
    <code class="filename">foo-3</code>, and so on).</p></dd><dt><span class="term"><code class="option">--indirect</code></span></dt><dd><p>In conjunction with <code class="option">--add-root</code>, this option
    allows roots to be stored <span class="emphasis"><em>outside</em></span> of the GC
    roots directory.  This is useful for commands such as
    <span class="command"><strong>nix-build</strong></span> that place a symlink to the build
    result in the current directory; such a build result should not be
    garbage-collected unless the symlink is removed.</p><p>The <code class="option">--indirect</code> flag causes a uniquely named
    symlink to <em class="replaceable"><code>path</code></em> to be stored in
    <code class="filename">/nix/var/nix/gcroots/auto/</code>.  For instance,

    </p><pre class="screen">
$ nix-store --add-root /home/eelco/bla/result --indirect -r <em class="replaceable"><code>...</code></em>

$ ls -l /nix/var/nix/gcroots/auto
lrwxrwxrwx    1 ... 2005-03-13 21:10 dn54lcypm8f8... -&gt; /home/eelco/bla/result

$ ls -l /home/eelco/bla/result
lrwxrwxrwx    1 ... 2005-03-13 21:10 /home/eelco/bla/result -&gt; /nix/store/1r11343n6qd4...-f-spot-0.0.10</pre><p>

    Thus, when <code class="filename">/home/eelco/bla/result</code> is removed,
    the GC root in the <code class="filename">auto</code> directory becomes a
    dangling symlink and will be ignored by the collector.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Note that it is not possible to move or rename
    indirect GC roots, since the symlink in the
    <code class="filename">auto</code> directory will still point to the old
    location.</p></div></dd></dl></div></div><div class="refsection" title="Operation --realise"><a name="rsec-nix-store-realise"></a><h2>Operation <code class="option">--realise</code></h2><div class="refsection" title="Synopsis"><a name="id497152"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>  { <code class="option">--realise</code>  |   <code class="option">-r</code> }  <em class="replaceable"><code>paths</code></em>...  [<code class="option">--dry-run</code>]</p></div></div><div class="refsection" title="Description"><a name="id497200"></a><h3>Description</h3><p>The operation <code class="option">--realise</code> essentially &#8220;builds&#8221;
the specified store paths.  Realisation is a somewhat overloaded term:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If the store path is a
  <span class="emphasis"><em>derivation</em></span>, realisation ensures that the output
  paths of the derivation are <a class="link" href="#gloss-validity" title="validity">valid</a> (i.e., the output path and its
  closure exist in the file system).  This can be done in several
  ways.  First, it is possible that the outputs are already valid, in
  which case we are done immediately.  Otherwise, there may be <a class="link" href="#gloss-substitute" title="substitute">substitutes</a> that produce the
  outputs (e.g., by downloading them).  Finally, the outputs can be
  produced by performing the build action described by the
  derivation.</p></li><li class="listitem"><p>If the store path is not a derivation, realisation
  ensures that the specified path is valid (i.e., it and its closure
  exist in the file system).  If the path is already valid, we are
  done immediately.  Otherwise, the path and any missing paths in its
  closure may be produced through substitutes.  If there are no
  (succesful) subsitutes, realisation fails.</p></li></ul></div><p>

</p><p>The output path of each derivation is printed on standard
output.  (For non-derivations argument, the argument itself is
printed.)</p><p>If the <code class="option">--dry-run</code> option is used, then
<span class="command"><strong>nix-store</strong></span> will print on standard error a
description of what packages would be built or downloaded, and then
quit.</p></div><div class="refsection" title="Examples"><a name="id497264"></a><h3>Examples</h3><p>This operation is typically used to build store derivations
produced by <a class="link" href="#sec-nix-instantiate" title="nix-instantiate"><span class="command"><strong>nix-instantiate</strong></span></a>:
    
</p><pre class="screen">
$ nix-store -r $(nix-instantiate ./test.nix)
/nix/store/31axcgrlbfsxzmfff1gyj1bf62hvkby2-aterm-2.3.1</pre><p>

This is essentially what <a class="link" href="#sec-nix-build" title="nix-build"><span class="command"><strong>nix-build</strong></span></a> does.</p></div></div><div class="refsection" title="Operation --gc"><a name="rsec-nix-store-gc"></a><h2>Operation <code class="option">--gc</code></h2><div class="refsection" title="Synopsis"><a name="id497307"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--gc</code>  [ <code class="option">--print-roots</code>  |   <code class="option">--print-live</code>  |   <code class="option">--print-dead</code>  |   <code class="option">--delete</code> ] [<code class="option">--max-freed</code> <em class="replaceable"><code>bytes</code></em>] [<code class="option">--max-links</code> <em class="replaceable"><code>nrlinks</code></em>]</p></div></div><div class="refsection" title="Description"><a name="id497377"></a><h3>Description</h3><p>Without additional flags, the operation <code class="option">--gc</code>
performs a garbage collection on the Nix store.  That is, all paths in
the Nix store not reachable via file system references from a set of
&#8220;roots&#8221;, are deleted.</p><p>The following suboperations may be specified:</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--print-roots</code></span></dt><dd><p>This operation prints on standard output the set
    of roots used by the garbage collector.  What constitutes a root
    is described in <a class="xref" href="#ssec-gc-roots" title="4.3.1. Garbage collector roots">Section 4.3.1, &#8220;Garbage collector roots&#8221;</a>.</p></dd><dt><span class="term"><code class="option">--print-live</code></span></dt><dd><p>This operation prints on standard output the set
    of &#8220;live&#8221; store paths, which are all the store paths reachable
    from the roots.  Live paths should never be deleted, since that
    would break consistency &#8212; it would become possible that
    applications are installed that reference things that are no
    longer present in the store.</p></dd><dt><span class="term"><code class="option">--print-dead</code></span></dt><dd><p>This operation prints out on standard output the
    set of &#8220;dead&#8221; store paths, which is just the opposite of the set
    of live paths: any path in the store that is not live (with
    respect to the roots) is dead.</p></dd><dt><span class="term"><code class="option">--delete</code></span></dt><dd><p>This operation performs an actual garbage
    collection.  All dead paths are removed from the
    store.  This is the default.</p></dd></dl></div><p>By default, all unreachable paths are deleted.  The following
options control what gets deleted and in what order:

</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--max-freed</code> <em class="replaceable"><code>bytes</code></em></span></dt><dd><p>Keep deleting paths until at least
    <em class="replaceable"><code>bytes</code></em> bytes have been
    deleted, then stop.</p></dd><dt><span class="term"><code class="option">--max-links</code> <em class="replaceable"><code>nrlinks</code></em></span></dt><dd><p>Keep deleting paths until the hard link count on
    <code class="filename">/nix/store</code> is less than
    <em class="replaceable"><code>nrlinks</code></em>, then stop.  This is useful for
    very large Nix stores on filesystems with a 32000 subdirectories
    limit (like <code class="literal">ext3</code>).</p></dd></dl></div><p>

</p><p>The behaviour of the collector is also influenced by the <a class="link" href="#conf-gc-keep-outputs"><code class="literal">gc-keep-outputs</code></a>
and <a class="link" href="#conf-gc-keep-derivations"><code class="literal">gc-keep-derivations</code></a>
variables in the Nix configuration file.</p><p>With <code class="option">--delete</code>, the collector prints the total
number of freed bytes when it finishes (or when it is interrupted).
With <code class="option">--print-dead</code>, it prints the number of bytes that
would be freed.</p></div><div class="refsection" title="Examples"><a name="id497546"></a><h3>Examples</h3><p>To delete all unreachable paths, just do:
    
</p><pre class="screen">
$ nix-store --gc
deleting `/nix/store/kq82idx6g0nyzsp2s14gfsc38npai7lf-cairo-1.0.4.tar.gz.drv'
<em class="replaceable"><code>...</code></em>
8825586 bytes freed (8.42 MiB)</pre><p>

</p><p>To delete at least 100 MiBs of unreachable paths:

</p><pre class="screen">
$ nix-store --gc --max-freed $((100 * 1024 * 1024))</pre><p>

</p></div></div><div class="refsection" title="Operation --delete"><a name="id497577"></a><h2>Operation <code class="option">--delete</code></h2><div class="refsection" title="Synopsis"><a name="id497584"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--delete</code>  [<code class="option">--ignore-liveness</code>]  <em class="replaceable"><code>paths</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id497619"></a><h3>Description</h3><p>The operation <code class="option">--delete</code> deletes the store paths
<em class="replaceable"><code>paths</code></em> from the Nix store, but only if it is
safe to do so; that is, when the path is not reachable from a root of
the garbage collector.  This means that you can only delete paths that
would also be deleted by <code class="literal">nix-store --gc</code>.  Thus,
<code class="literal">--delete</code> is a more targeted version of
<code class="literal">--gc</code>.</p><p>With the option <code class="option">--ignore-liveness</code>, reachability
from the roots is ignored.  However, the path still won&#8217;t be deleted
if there are other paths in the store that refer to it (i.e., depend
on it).</p></div><div class="refsection" title="Example"><a name="id497656"></a><h3>Example</h3><pre class="screen">
$ nix-store --delete /nix/store/zq0h41l75vlb4z45kzgjjmsjxvcv1qk7-mesa-6.4
0 bytes freed (0.00 MiB)
error: cannot delete path `/nix/store/zq0h41l75vlb4z45kzgjjmsjxvcv1qk7-mesa-6.4' since it is still alive</pre></div></div><div class="refsection" title="Operation --query"><a name="refsec-nix-store-query"></a><h2>Operation <code class="option">--query</code></h2><div class="refsection" title="Synopsis"><a name="id497683"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>  { <code class="option">--query</code>  |   <code class="option">-q</code> } { <code class="option">--outputs</code>  |   <code class="option">--requisites</code>  |   <code class="option">-R</code>  |   <code class="option">--references</code>  |   <code class="option">--referrers</code>  |   <code class="option">--referrers-closure</code>  |   <code class="option">--deriver</code>  |   <code class="option">--deriver</code>  |   <code class="option">--graph</code>  |   <code class="option">--tree</code>  |   <code class="option">--binding</code> <em class="replaceable"><code>name</code></em>  |   <code class="option">--hash</code>  |   <code class="option">--roots</code> } [<code class="option">--use-output</code>] [<code class="option">-u</code>] [<code class="option">--force-realise</code>] [<code class="option">-f</code>]  <em class="replaceable"><code>paths</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id497846"></a><h3>Description</h3><p>The operation <code class="option">--query</code> displays various bits of
information about the store paths .  The queries are described below.  At
most one query can be specified.  The default query is
<code class="option">--outputs</code>.</p><p>The paths <em class="replaceable"><code>paths</code></em> may also be symlinks
from outside of the Nix store, to the Nix store.  In that case, the
query is applied to the target of the symlink.</p></div><div class="refsection" title="Common query options"><a name="id497874"></a><h3>Common query options</h3><div class="variablelist"><dl><dt><span class="term"><code class="option">--use-output</code>, </span><span class="term"><code class="option">-u</code></span></dt><dd><p>For each argument to the query that is a store
    derivation, apply the query to the output path of the derivation
    instead.</p></dd><dt><span class="term"><code class="option">--force-realise</code>, </span><span class="term"><code class="option">-f</code></span></dt><dd><p>Realise each argument to the query first (see
    <a class="link" href="#rsec-nix-store-realise" title="Operation --realise"><span class="command"><strong>nix-store
    --realise</strong></span></a>).</p></dd></dl></div></div><div class="refsection" title="Queries"><a name="nixref-queries"></a><h3>Queries</h3><div class="variablelist"><dl><dt><span class="term"><code class="option">--outputs</code></span></dt><dd><p>Prints out the <a class="link" href="#gloss-output-path" title="output path">output paths</a> of the store
    derivations <em class="replaceable"><code>paths</code></em>.  These are the paths
    that will be produced when the derivation is
    built.</p></dd><dt><span class="term"><code class="option">--requisites</code>, </span><span class="term"><code class="option">-R</code></span></dt><dd><p>Prints out the <a class="link" href="#gloss-closure" title="closure">closure</a> of the store path
    <em class="replaceable"><code>paths</code></em>.</p><p>This query has one option:</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--include-outputs</code></span></dt><dd><p>Also include the output path of store
        derivations, and their closures.</p></dd></dl></div><p>This query can be used to implement various kinds of
    deployment.  A <span class="emphasis"><em>source deployment</em></span> is obtained
    by distributing the closure of a store derivation.  A
    <span class="emphasis"><em>binary deployment</em></span> is obtained by distributing
    the closure of an output path.  A <span class="emphasis"><em>cache
    deployment</em></span> (combined source/binary deployment,
    including binaries of build-time-only dependencies) is obtained by
    distributing the closure of a store derivation and specifying the
    option <code class="option">--include-outputs</code>.</p></dd><dt><span class="term"><code class="option">--references</code></span></dt><dd><p>Prints the set of <a class="link" href="#gloss-reference" title="reference">references</a> of the store paths
    <em class="replaceable"><code>paths</code></em>, that is, their immediate
    dependencies.  (For <span class="emphasis"><em>all</em></span> dependencies, use
    <code class="option">--requisites</code>.)</p></dd><dt><span class="term"><code class="option">--referrers</code></span></dt><dd><p>Prints the set of <span class="emphasis"><em>referrers</em></span> of
    the store paths <em class="replaceable"><code>paths</code></em>, that is, the
    store paths currently existing in the Nix store that refer to one
    of <em class="replaceable"><code>paths</code></em>.  Note that contrary to the
    references, the set of referrers is not constant; it can change as
    store paths are added or removed.</p></dd><dt><span class="term"><code class="option">--referrers-closure</code></span></dt><dd><p>Prints the closure of the set of store paths
    <em class="replaceable"><code>paths</code></em> under the referrers relation; that
    is, all store paths that directly or indirectly refer to one of
    <em class="replaceable"><code>paths</code></em>.  These are all the path currently
    in the Nix store that are dependent on
    <em class="replaceable"><code>paths</code></em>.</p></dd><dt><span class="term"><code class="option">--deriver</code></span></dt><dd><p>Prints the <a class="link" href="#gloss-deriver" title="deriver">deriver</a> of the store paths
    <em class="replaceable"><code>paths</code></em>.  If the path has no deriver
    (e.g., if it is a source file), or if the deriver is not known
    (e.g., in the case of a binary-only deployment), the string
    <code class="literal">unknown-deriver</code> is printed.</p></dd><dt><span class="term"><code class="option">--graph</code></span></dt><dd><p>Prints the references graph of the store paths
    <em class="replaceable"><code>paths</code></em> in the format of the
    <span class="command"><strong>dot</strong></span> tool of AT&amp;T's <a class="link" href="http://www.graphviz.org/" target="_top">Graphviz package</a>.
    This can be used to visualise dependency graphs.  To obtain a
    build-time dependency graph, apply this to a store derivation.  To
    obtain a runtime dependency graph, apply it to an output
    path.</p></dd><dt><span class="term"><code class="option">--tree</code></span></dt><dd><p>Prints the references graph of the store paths
    <em class="replaceable"><code>paths</code></em> as a nested ASCII tree.
    References are ordered by descending closure size; this tends to
    flatten the tree, making it more readable.  The query only
    recurses into a store path when it is first encountered; this
    prevents a blowup of the tree representation of the
    graph.</p></dd><dt><span class="term"><code class="option">--binding</code> <em class="replaceable"><code>name</code></em></span></dt><dd><p>Prints the value of the attribute
    <em class="replaceable"><code>name</code></em> (i.e., environment variable) of
    the store derivations <em class="replaceable"><code>paths</code></em>.  It is an
    error for a derivation to not have the specified
    attribute.</p></dd><dt><span class="term"><code class="option">--hash</code></span></dt><dd><p>Prints the SHA-256 hash of the contents of the
    store paths <em class="replaceable"><code>paths</code></em>.  Since the hash is
    stored in the Nix database, this is a fast
    operation.</p></dd><dt><span class="term"><code class="option">--roots</code></span></dt><dd><p>Prints the garbage collector roots that point,
    directly or indirectly, at the store paths
    <em class="replaceable"><code>paths</code></em>.</p></dd></dl></div></div><div class="refsection" title="Examples"><a name="id498240"></a><h3>Examples</h3><p>Print the closure (runtime dependencies) of the
<span class="command"><strong>svn</strong></span> program in the current user environment:
    
</p><pre class="screen">
$ nix-store -qR $(which svn)
/nix/store/5mbglq5ldqld8sj57273aljwkfvj22mc-subversion-1.1.4
/nix/store/9lz9yc6zgmc0vlqmn2ipcpkjlmbi51vv-glibc-2.3.4
<em class="replaceable"><code>...</code></em></pre><p>

</p><p>Print the build-time dependencies of <span class="command"><strong>svn</strong></span>:

</p><pre class="screen">
$ nix-store -qR $(nix-store -qd $(which svn))
/nix/store/02iizgn86m42q905rddvg4ja975bk2i4-grep-2.5.1.tar.bz2.drv
/nix/store/07a2bzxmzwz5hp58nf03pahrv2ygwgs3-gcc-wrapper.sh
/nix/store/0ma7c9wsbaxahwwl04gbw3fcd806ski4-glibc-2.3.4.drv
<em class="replaceable"><code>... lots of other paths ...</code></em></pre><p>

The difference with the previous example is that we ask the closure of
the derivation (<code class="option">-qd</code>), not the closure of the output
path that contains <span class="command"><strong>svn</strong></span>.</p><p>Show the build-time dependencies as a tree:

</p><pre class="screen">
$ nix-store -q --tree $(nix-store -qd $(which svn))
/nix/store/7i5082kfb6yjbqdbiwdhhza0am2xvh6c-subversion-1.1.4.drv
+---/nix/store/d8afh10z72n8l1cr5w42366abiblgn54-builder.sh
+---/nix/store/fmzxmpjx2lh849ph0l36snfj9zdibw67-bash-3.0.drv
|   +---/nix/store/570hmhmx3v57605cqg9yfvvyh0nnb8k8-bash
|   +---/nix/store/p3srsbd8dx44v2pg6nbnszab5mcwx03v-builder.sh
<em class="replaceable"><code>...</code></em></pre><p>

</p><p>Show all paths that depend on the same OpenSSL library as
<span class="command"><strong>svn</strong></span>:

</p><pre class="screen">
$ nix-store -q --referrers $(nix-store -q --binding openssl $(nix-store -qd $(which svn)))
/nix/store/23ny9l9wixx21632y2wi4p585qhva1q8-sylpheed-1.0.0
/nix/store/5mbglq5ldqld8sj57273aljwkfvj22mc-subversion-1.1.4
/nix/store/dpmvp969yhdqs7lm2r1a3gng7pyq6vy4-subversion-1.1.3
/nix/store/l51240xqsgg8a7yrbqdx1rfzyv6l26fx-lynx-2.8.5</pre><p>

</p><p>Show all paths that directly or indirectly depend on the Glibc
(C library) used by <span class="command"><strong>svn</strong></span>:

</p><pre class="screen">
$ nix-store -q --referrers-closure $(ldd $(which svn) | grep /libc.so | awk '{print $3}')
/nix/store/034a6h4vpz9kds5r6kzb9lhh81mscw43-libgnomeprintui-2.8.2
/nix/store/15l3yi0d45prm7a82pcrknxdh6nzmxza-gawk-3.1.4
<em class="replaceable"><code>...</code></em></pre><p>

Note that <span class="command"><strong>ldd</strong></span> is a command that prints out the
dynamic libraries used by an ELF executable.</p><p>Make a picture of the runtime dependency graph of the current
user environment:

</p><pre class="screen">
$ nix-store -q --graph ~/.nix-profile | dot -Tps &gt; graph.ps
$ gv graph.ps</pre><p>

</p><p>Show every garbage collector root that points to a store path
that depends on <span class="command"><strong>svn</strong></span>:

</p><pre class="screen">
$ nix-store -q --roots $(which svn)
/nix/var/nix/profiles/default-81-link
/nix/var/nix/profiles/default-82-link
/nix/var/nix/profiles/per-user/eelco/profile-97-link
</pre><p>

</p></div></div><div class="refsection" title="Operation --verify"><a name="refsec-nix-store-verify"></a><h2>Operation <code class="option">--verify</code></h2><div class="refsection" title="Synopsis"><a name="id498378"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--verify</code>  [<code class="option">--check-contents</code>]</p></div></div><div class="refsection" title="Description"><a name="id498405"></a><h3>Description</h3><p>The operation <code class="option">--verify</code> verifies the internal
consistency of the Nix database, and the consistency between the Nix
database and the Nix store.  Any inconsistencies encountered are
automatically repaired.  Inconsistencies are generally the result of
the Nix store or database being modified by non-Nix tools, or of bugs
in Nix itself.</p><p>There is one option:

</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--check-contents</code></span></dt><dd><p>Checks that the contents of every valid store path
    has not been altered by computing a SHA-256 hash of the contents
    and comparing it with the hash stored in the Nix database at build
    time.  Paths that have been modified are printed out.  For large
    stores, <code class="option">--check-contents</code> is obviously quite
    slow.</p></dd></dl></div><p>

</p></div></div><div class="refsection" title="Operation --dump"><a name="refsec-nix-store-dump"></a><h2>Operation <code class="option">--dump</code></h2><div class="refsection" title="Synopsis"><a name="id498461"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--dump</code>   <em class="replaceable"><code>path</code></em> </p></div></div><div class="refsection" title="Description"><a name="id498490"></a><h3>Description</h3><p>The operation <code class="option">--dump</code> produces a NAR (Nix
ARchive) file containing the contents of the file system tree rooted
at <em class="replaceable"><code>path</code></em>.  The archive is written to
standard output.</p><p>A NAR archive is like a TAR or Zip archive, but it contains only
the information that Nix considers important.  For instance,
timestamps are elided because all files in the Nix store have their
timestamp set to 0 anyway.  Likewise, all permissions are left out
except for the execute bit, because all files in the Nix store have
644 or 755 permission.</p><p>Also, a NAR archive is <span class="emphasis"><em>canonical</em></span>, meaning
that &#8220;equal&#8221; paths always produce the same NAR archive.  For instance,
directory entries are always sorted so that the actual on-disk order
doesn&#8217;t influence the result.  This means that the cryptographic hash
of a NAR dump of a path is usable as a fingerprint of the contents of
the path.  Indeed, the hashes of store paths stored in Nix&#8217;s database
(see <a class="link" href="#refsec-nix-store-query" title="Operation --query"><code class="literal">nix-store -q
--hash</code></a>) are SHA-256 hashes of the NAR dump of each
store path.</p><p>NAR archives support filenames of unlimited length and 64-bit
file sizes.  They can contain regular files, directories, and symbolic
links, but not other types of files (such as device nodes).</p><p>A Nix archive can be unpacked using <code class="literal">nix-store
--restore</code>.</p></div></div><div class="refsection" title="Operation --restore"><a name="id498550"></a><h2>Operation <code class="option">--restore</code></h2><div class="refsection" title="Synopsis"><a name="id498557"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--restore</code>   <em class="replaceable"><code>path</code></em> </p></div></div><div class="refsection" title="Description"><a name="id498586"></a><h3>Description</h3><p>The operation <code class="option">--restore</code> unpacks a NAR archive
to <em class="replaceable"><code>path</code></em>, which must not already exist.  The
archive is read from standard input.</p></div></div><div class="refsection" title="Operation --export"><a name="refsec-nix-store-export"></a><h2>Operation <code class="option">--export</code></h2><div class="refsection" title="Synopsis"><a name="id498619"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--export</code>   <em class="replaceable"><code>paths</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id498650"></a><h3>Description</h3><p>The operation <code class="option">--export</code> writes a serialisation
of the specified store paths to standard output in a format that can
be imported into another Nix store with <span class="command"><strong><a class="command" href="#refsec-nix-store-import" title="Operation --import">nix-store --import</a></strong></span>.  This
is like <span class="command"><strong><a class="command" href="#refsec-nix-store-dump" title="Operation --dump">nix-store
--dump</a></strong></span>, except that the NAR archive produced by that command
doesn&#8217;t contain the necessary meta-information to allow it to be
imported into another Nix store (namely, the set of references of the
path).</p><p>This command does not produce a <span class="emphasis"><em>closure</em></span> of
the specified paths, so if a store path references other store paths
that are missing in the target Nix store, the import will fail.  To
copy a whole closure, do something like

</p><pre class="screen">
$ nix-store --export $(nix-store -qR <em class="replaceable"><code>paths</code></em>) &gt; out</pre><p>

</p><p>For an example of how <code class="option">--export</code> and
<code class="option">--import</code> can be used, see the source of the <span class="command"><strong><a class="command" href="#sec-nix-copy-closure" title="nix-copy-closure">nix-copy-closure</a></strong></span>
command.</p></div></div><div class="refsection" title="Operation --import"><a name="refsec-nix-store-import"></a><h2>Operation <code class="option">--import</code></h2><div class="refsection" title="Synopsis"><a name="id498727"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--import</code> </p></div></div><div class="refsection" title="Description"><a name="id498749"></a><h3>Description</h3><p>The operation <code class="option">--export</code> reads a serialisation of
a set of store paths produced by <span class="command"><strong><a class="command" href="#refsec-nix-store-export" title="Operation --export">nix-store --import</a></strong></span> from
standard input and adds those store paths to the Nix store.  Paths
that already exist in the Nix store are ignored.  If a path refers to
another path that doesn&#8217;t exist in the Nix store, the import
fails.</p></div></div><div class="refsection" title="Operation --optimise"><a name="id498775"></a><h2>Operation <code class="option">--optimise</code></h2><div class="refsection" title="Synopsis"><a name="id498782"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--optimise</code> </p></div></div><div class="refsection" title="Description"><a name="id498804"></a><h3>Description</h3><p>The operation <code class="option">--optimise</code> reduces Nix store disk
space usage by finding identical files in the store and hard-linking
them to each other.  It typically reduces the size of the store by
something like 25-35%.  Only regular files and symlinks are
hard-linked in this manner.  Files are considered identical when they
have the same NAR archive serialisation: that is, regular files must
have the same contents and permission (executable or non-executable),
and symlinks must have the same contents.</p><p>After completion, or when the command is interrupted, a report
on the achieved savings is printed on standard error.</p><p>Use <code class="option">-vv</code> or <code class="option">-vvv</code> to get some
progress indication.</p></div><div class="refsection" title="Example"><a name="id498837"></a><h3>Example</h3><pre class="screen">
$ nix-store --optimise
hashing files in `/nix/store/qhqx7l2f1kmwihc9bnxs7rc159hsxnf3-gcc-4.1.1'
<em class="replaceable"><code>...</code></em>
541838819 bytes (516.74 MiB) freed by hard-linking 54143 files;
there are 114486 files with equal contents out of 215894 files in total
</pre></div></div><div class="refsection" title="Operation --read-log"><a name="id498857"></a><h2>Operation <code class="option">--read-log</code></h2><div class="refsection" title="Synopsis"><a name="id498864"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>  { <code class="option">--read-log</code>  |   <code class="option">-l</code> }  <em class="replaceable"><code>paths</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id498909"></a><h3>Description</h3><p>The operation <code class="option">--read-log</code> prints the build log
of the specified store paths on standard output.  The build log is
whatever the builder of a derivation wrote to standard output and
standard error.  If a store path is not a derivation, the deriver of
the store path is used.</p><p>Build logs are kept in
<code class="filename">/nix/var/log/nix/drvs</code>.  However, there is no
guarantee that a build log is available for any particular store
path.  For instance, if the path was downloaded as a pre-built binary
through a substitute, then the log is unavailable.</p></div><div class="refsection" title="Example"><a name="id498933"></a><h3>Example</h3><pre class="screen">
$ nix-store -l $(which ktorrent)
building /nix/store/dhc73pvzpnzxhdgpimsd9sw39di66ph1-ktorrent-2.2.1
unpacking sources
unpacking source archive /nix/store/p8n1jpqs27mgkjw07pb5269717nzf5f8-ktorrent-2.2.1.tar.gz
ktorrent-2.2.1/
ktorrent-2.2.1/NEWS
<em class="replaceable"><code>...</code></em>
</pre></div></div><div class="refsection" title="Operation --dump-db"><a name="id498953"></a><h2>Operation <code class="option">--dump-db</code></h2><div class="refsection" title="Synopsis"><a name="id498960"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--dump-db</code> </p></div></div><div class="refsection" title="Description"><a name="id498982"></a><h3>Description</h3><p>The operation <code class="option">--dump-db</code> writes a dump of the
Nix database to standard output.  It can be loaded into an empty Nix
store using <code class="option">--load-db</code>.  This is useful for making
backups and when migrating to different database schemas.</p></div></div><div class="refsection" title="Operation --dump-db"><a name="id499005"></a><h2>Operation <code class="option">--dump-db</code></h2><div class="refsection" title="Synopsis"><a name="id499012"></a><h3>Synopsis</h3><div class="cmdsynopsis"><p><code class="command">nix-store</code>   <code class="option">--load-db</code> </p></div></div><div class="refsection" title="Description"><a name="id499034"></a><h3>Description</h3><p>The operation <code class="option">--load-db</code> reads a dump of the Nix
database created by <code class="option">--dump-db</code> from standard input and
loads it into the Nix database.</p></div></div></div></div><div class="section" title="A.5. Utilities"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id481099"></a>A.5. Utilities</h2></div></div></div><div class="refentry" title="nix-build"><a name="sec-nix-build"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-build &#8212; build a Nix expression</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-build</code>  [<code class="option">--help</code>] [<code class="option">--version</code>] [<code class="option">--verbose</code>...] [<code class="option">-v</code>...] [<code class="option">--no-build-output</code>] [<code class="option">-Q</code>] [
  { <code class="option">--max-jobs</code>  |   <code class="option">-j</code> }
  <em class="replaceable"><code>number</code></em>
] [
  [<code class="option">--cores</code>]
  <em class="replaceable"><code>number</code></em>
] [
  [<code class="option">--max-silent-time</code>]
  <em class="replaceable"><code>number</code></em>
] [<code class="option">--keep-going</code>] [<code class="option">-k</code>] [<code class="option">--keep-failed</code>] [<code class="option">-K</code>] [<code class="option">--fallback</code>] [<code class="option">--readonly-mode</code>] [<code class="option">--log-type</code> <em class="replaceable"><code>type</code></em>] [<code class="option">--show-trace</code>]<br> [<code class="option">--arg</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>value</code></em>] [<code class="option">--argstr</code> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>value</code></em>] [
      { <code class="option">--attr</code>  |   <code class="option">-A</code> }
      <em class="replaceable"><code>attrPath</code></em>
    ] [<code class="option">--add-drv-link</code>] [<code class="option">--drv-link </code><em class="replaceable"><code>drvlink</code></em>] [<code class="option">--no-out-link</code>] [
      { <code class="option">--out-link</code>  |   <code class="option">-o</code> }
      <em class="replaceable"><code>outlink</code></em>
    ]  <em class="replaceable"><code>paths</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id489912"></a><h2>Description</h2><p>The <span class="command"><strong>nix-build</strong></span> command builds the derivations
described by the Nix expressions in <em class="replaceable"><code>paths</code></em>.
If the build succeeds, it places a symlink to the result in the
current directory.  The symlink is called <code class="filename">result</code>.
If there are multiple Nix expressions, or the Nix expressions evaluate
to multiple derivations, multiple sequentially numbered symlinks are
created (<code class="filename">result</code>, <code class="filename">result-2</code>,
and so on).</p><p>If no <em class="replaceable"><code>paths</code></em> are specified, then
<span class="command"><strong>nix-build</strong></span> will use <code class="filename">default.nix</code>
in the current directory, if it exists.</p><p><span class="command"><strong>nix-build</strong></span> is essentially a wrapper around
<a class="link" href="#sec-nix-instantiate" title="nix-instantiate"><span class="command"><strong>nix-instantiate</strong></span></a>
(to translate a high-level Nix expression to a low-level store
derivation) and <a class="link" href="#rsec-nix-store-realise" title="Operation --realise"><span class="command"><strong>nix-store
--realise</strong></span></a> (to build the store derivation).</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>The result of the build is automatically registered as
a root of the Nix garbage collector.  This root disappears
automatically when the <code class="filename">result</code> symlink is deleted
or renamed.  So don&#8217;t rename the symlink.</p></div></div><div class="refsection" title="Options"><a name="id496724"></a><h2>Options</h2><p>See also <a class="xref" href="#sec-common-options" title="A.1. Common options">Section A.1, &#8220;Common options&#8221;</a>.  All options not
listed here are passed to <span class="command"><strong>nix-store --realise</strong></span>,
except for <code class="option">--arg</code> and <code class="option">--attr</code> /
<code class="option">-A</code> which are passed to
<span class="command"><strong>nix-instantiate</strong></span>.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--add-drv-link</code></span></dt><dd><p>Add a symlink in the current directory to the
    store derivation produced by <span class="command"><strong>nix-instantiate</strong></span>.
    The symlink is called <code class="filename">derivation</code> (which is
    numbered in the case of multiple derivations).  The derivation is
    a root of the garbage collector until the symlink is deleted or
    renamed.</p></dd><dt><span class="term"><code class="option">--drv-link</code> <em class="replaceable"><code>drvlink</code></em></span></dt><dd><p>Change the name of the symlink to the derivation
    created when <code class="option">--add-drv-link</code> is used from
    <code class="filename">derivation</code> to
    <em class="replaceable"><code>drvlink</code></em>.</p></dd><dt><span class="term"><code class="option">--no-out-link</code></span></dt><dd><p>Do not create a symlink to the output path.  Note
    that as a result the output does not become a root of the garbage
    collector, and so might be deleted by <span class="command"><strong>nix-store
    --gc</strong></span>.</p></dd><dt><a name="opt-out-link"></a><span class="term"><code class="option">--out-link</code> /
  <code class="option">-o</code> <em class="replaceable"><code>outlink</code></em></span></dt><dd><p>Change the name of the symlink to the output path
    created unless <code class="option">--no-out-link</code> is used from
    <code class="filename">result</code> to
    <em class="replaceable"><code>outlink</code></em>.</p></dd></dl></div></div><div class="refsection" title="Examples"><a name="id489630"></a><h2>Examples</h2><pre class="screen">
$ nix-build pkgs/top-level/all-packages.nix -A firefox
store derivation is /nix/store/qybprl8sz2lc...-firefox-1.5.0.7.drv
/nix/store/d18hyl92g30l...-firefox-1.5.0.7

$ ls -l result
lrwxrwxrwx  <em class="replaceable"><code>...</code></em>  result -&gt; /nix/store/d18hyl92g30l...-firefox-1.5.0.7

$ ls ./result/bin/
firefox  firefox-config</pre></div></div><div class="refentry" title="nix-channel"><div class="refentry.separator"><hr></div><a name="sec-nix-channel"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-channel &#8212; manage Nix channels</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-channel</code>  { <code class="option">--add</code> <em class="replaceable"><code>url</code></em>  |   <code class="option">--remove</code> <em class="replaceable"><code>url</code></em>  |   <code class="option">--list</code>  |   <code class="option">--update</code> }</p></div></div><div class="refsection" title="Description"><a name="id482367"></a><h2>Description</h2><p>A Nix channel is mechanism that allows you to automatically stay
up-to-date with a set of pre-built Nix expressions.  A Nix channel is
just a URL that points to a place that contains a set of Nix
expressions, as well as a <span class="command"><strong>nix-push</strong></span> manifest.  See
also <a class="xref" href="#sec-channels" title="4.4. Channels">Section 4.4, &#8220;Channels&#8221;</a>.</p><p>This command has the following operations:

</p><div class="variablelist"><dl><dt><span class="term"><code class="option">--add</code> <em class="replaceable"><code>url</code></em></span></dt><dd><p>Adds <em class="replaceable"><code>url</code></em> to the list of
    subscribed channels.</p></dd><dt><span class="term"><code class="option">--remove</code> <em class="replaceable"><code>url</code></em></span></dt><dd><p>Removes <em class="replaceable"><code>url</code></em> from the
    list of subscribed channels.</p></dd><dt><span class="term"><code class="option">--list</code></span></dt><dd><p>Prints the URLs of all subscribed channels on
    standard output.</p></dd><dt><span class="term"><code class="option">--update</code></span></dt><dd><p>Downloads the Nix expressions of all subscribed
    channels, makes them the default for <span class="command"><strong>nix-env</strong></span>
    operations (by symlinking them in the directory
    <code class="filename">~/.nix-defexpr</code>), and performs a
    <span class="command"><strong>nix-pull</strong></span> on the manifests of all channels to
    make pre-built binaries available.</p></dd></dl></div><p>

</p><p>Note that <code class="option">--add</code> and <code class="option">--remove</code>
do not automatically perform an update.</p><p>The list of subscribed channels is stored in
<code class="filename">~/.nix-channels</code>.</p><p>A channel consists of two elements: a bzipped Tar archive
containing the Nix expressions, and a manifest created by
<span class="command"><strong>nix-push</strong></span>.  These must be stored under
<code class="literal"><em class="replaceable"><code>url</code></em>/nixexprs.tar.bz2</code> and
<code class="literal"><em class="replaceable"><code>url</code></em>/MANIFEST</code>,
respectively.</p></div></div><div class="refentry" title="nix-collect-garbage"><div class="refentry.separator"><hr></div><a name="sec-nix-collect-garbage"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-collect-garbage &#8212; delete unreachable store paths</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-collect-garbage</code>  [<code class="option">--delete-old</code>] [<code class="option">-d</code>] [ <code class="option">--print-roots</code>  |   <code class="option">--print-live</code>  |   <code class="option">--print-dead</code>  |   <code class="option">--delete</code> ]</p></div></div><div class="refsection" title="Description"><a name="id489676"></a><h2>Description</h2><p>The command <span class="command"><strong>nix-collect-garbage</strong></span> is mostly an
alias of <a class="link" href="#rsec-nix-store-gc" title="Operation --gc"><span class="command"><strong>nix-store
--gc</strong></span></a>, that is, it deletes all unreachable paths in
the Nix store to clean up your system.  However, it provides an
additional option <code class="option">-d</code> (<code class="option">--delete-old</code>)
that deletes all old generations of all profiles in
<code class="filename">/nix/var/nix/profiles</code> by invoking
<code class="literal">nix-env --delete-generations old</code> on all profiles.
Of course, this makes rollbacks to previous configurations
impossible.</p></div><div class="refsection" title="Example"><a name="id486252"></a><h2>Example</h2><p>To delete from the Nix store everything that is not used by the
current generations of each profile, do

</p><pre class="screen">
$ nix-collect-garbage -d</pre><p>

</p></div></div><div class="refentry" title="nix-copy-closure"><div class="refentry.separator"><hr></div><a name="sec-nix-copy-closure"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-copy-closure &#8212; copy a closure to or from a remote machine via SSH</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-copy-closure</code>  [ <code class="option">--to</code>  |   <code class="option">--from</code> ] [<code class="option">--sign</code>] [<code class="option">--gzip</code>]  
      [<em class="replaceable"><code>user@</code></em>]<em class="replaceable"><code>machine</code></em>
       <em class="replaceable"><code>paths</code></em> </p></div></div><div class="refsection" title="Description"><a name="id486178"></a><h2>Description</h2><p><span class="command"><strong>nix-copy-closure</strong></span> gives you an easy and
efficient way to exchange software between machines.  Given one or
more Nix store paths <em class="replaceable"><code>paths</code></em> on the local
machine, <span class="command"><strong>nix-copy-closure</strong></span> computes the closure of
those paths (i.e. all their dependencies in the Nix store), and copies
all paths in the closure to the remote machine via the
<span class="command"><strong>ssh</strong></span> (Secure Shell) command.  With the
<code class="option">--from</code>, the direction is reversed:
the closure of <em class="replaceable"><code>paths</code></em> on a remote machine is
copied to the Nix store on the local machine.</p><p>This command is efficient because it only sends the store paths
that are missing on the target machine.</p><p>Since <span class="command"><strong>nix-copy-closure</strong></span> calls
<span class="command"><strong>ssh</strong></span>, you may be asked to type in the appropriate
password or passphrase.  In fact, you may be asked
<span class="emphasis"><em>twice</em></span> because <span class="command"><strong>nix-copy-closure</strong></span>
currently connects twice to the remote machine, first to get the set
of paths missing on the target machine, and second to send the dump of
those paths.  If this bothers you, use
<span class="command"><strong>ssh-agent</strong></span>.</p><div class="refsection" title="Options"><a name="id489762"></a><h3>Options</h3><div class="variablelist"><dl><dt><span class="term"><code class="option">--to</code></span></dt><dd><p>Copy the closure of
    <em class="replaceable"><code>paths</code></em> from the local Nix store to the
    Nix store on <em class="replaceable"><code>machine</code></em>.  This is the
    default.</p></dd><dt><span class="term"><code class="option">--from</code></span></dt><dd><p>Copy the closure of
    <em class="replaceable"><code>paths</code></em> from the Nix store on
    <em class="replaceable"><code>machine</code></em> to the local Nix
    store.</p></dd><dt><span class="term"><code class="option">--sign</code></span></dt><dd><p>Let the sending machine cryptographically sign the
    dump of each path with the key in
    <code class="filename">/nix/etc/nix/signing-key.sec</code>.  If the user on
    the target machine does not have direct access to the Nix store
    (i.e., if the target machine has a multi-user Nix installation),
    then the target machine will check the dump against
    <code class="filename">/nix/etc/nix/signing-key.pub</code> before unpacking
    it in its Nix store.  This allows secure sharing of store paths
    between untrusted users on two machines, provided that there is a
    trust relation between the Nix installations on both machines
    (namely, they have matching public/secret keys).</p></dd><dt><span class="term"><code class="option">--gzip</code></span></dt><dd><p>Compress the dump of each path with
    <span class="command"><strong>gzip</strong></span> before sending it.</p></dd></dl></div></div><div class="refsection" title="Environment variables"><a name="id486377"></a><h3>Environment variables</h3><div class="variablelist"><dl><dt><span class="term"><code class="envar">NIX_SSHOPTS</code></span></dt><dd><p>Additional options to be passed to
    <span class="command"><strong>ssh</strong></span> on the command line.</p></dd></dl></div></div><div class="refsection" title="Examples"><a name="id486403"></a><h3>Examples</h3><p>Copy Firefox with all its dependencies to a remote machine:

</p><pre class="screen">
$ nix-copy-closure --to alice@itchy.labs $(type -tP firefox)</pre><p>

</p><p>Copy Subversion from a remote machine and then install it into a
user environment:

</p><pre class="screen">
$ nix-copy-closure --from alice@itchy.labs \
    /nix/store/0dj0503hjxy5mbwlafv1rsbdiyx1gkdy-subversion-1.4.4
$ nix-env -i /nix/store/0dj0503hjxy5mbwlafv1rsbdiyx1gkdy-subversion-1.4.4
</pre><p>

</p></div></div></div><div class="refentry" title="nix-hash"><div class="refentry.separator"><hr></div><a name="sec-nix-hash"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-hash &#8212; compute the cryptographic hash of a path</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-hash</code>  [<code class="option">--flat</code>] [<code class="option">--base32</code>] [<code class="option">--truncate</code>] [<code class="option">--type</code> <em class="replaceable"><code>hashAlgo</code></em>]  <em class="replaceable"><code>path</code></em>... </p></div><div class="cmdsynopsis"><p><code class="command">nix-hash</code>   <code class="option">--to-base16</code>   <em class="replaceable"><code>hash</code></em>... </p></div><div class="cmdsynopsis"><p><code class="command">nix-hash</code>   <code class="option">--to-base32</code>   <em class="replaceable"><code>hash</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id490243"></a><h2>Description</h2><p>The command <span class="command"><strong>nix-hash</strong></span> computes the
cryptographic hash of the contents of each
<em class="replaceable"><code>path</code></em> and prints it on standard output.  By
default, it computes an MD5 hash, but other hash algorithms are
available as well.  The hash is printed in hexadecimal.</p><p>The hash is computed over a <span class="emphasis"><em>serialisation</em></span>
of each path: a dump of the file system tree rooted at the path.  This
allows directories and symlinks to be hashed as well as regular files.
The dump is in the <span class="emphasis"><em>NAR format</em></span> produced by <a class="link" href="#refsec-nix-store-dump" title="Operation --dump"><span class="command"><strong>nix-store</strong></span>
<code class="option">--dump</code></a>.  Thus, <code class="literal">nix-hash
<em class="replaceable"><code>path</code></em></code> yields the same
cryptographic hash as <code class="literal">nix-store --dump
<em class="replaceable"><code>path</code></em> | md5sum</code>.</p></div><div class="refsection" title="Options"><a name="id490298"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">--flat</code></span></dt><dd><p>Print the cryptographic hash of the contents of
    each regular file <em class="replaceable"><code>path</code></em>.  That is, do
    not compute the hash over the dump of
    <em class="replaceable"><code>path</code></em>.  The result is identical to that
    produced by the GNU commands <span class="command"><strong>md5sum</strong></span> and
    <span class="command"><strong>sha1sum</strong></span>.</p></dd><dt><span class="term"><code class="option">--base32</code></span></dt><dd><p>Print the hash in a base-32 representation rather
    than hexadecimal.  This base-32 representation is more compact and
    can be used in Nix expressions (such as in calls to
    <code class="function">fetchurl</code>).</p></dd><dt><span class="term"><code class="option">--truncate</code></span></dt><dd><p>Truncate hashes longer than 160 bits (such as
    SHA-256) to 160 bits.</p></dd><dt><span class="term"><code class="option">--type</code> <em class="replaceable"><code>hashAlgo</code></em></span></dt><dd><p>Specify a cryptographic hash, which can be one of
    <code class="literal">md5</code>, <code class="literal">sha1</code>, and
    <code class="literal">sha256</code>.</p></dd><dt><span class="term"><code class="option">--to-base16</code></span></dt><dd><p>Don&#8217;t hash anything, but convert the base-32 hash
    representation <em class="replaceable"><code>hash</code></em> to
    hexadecimal.</p></dd><dt><span class="term"><code class="option">--to-base32</code></span></dt><dd><p>Don&#8217;t hash anything, but convert the hexadecimal
    hash representation <em class="replaceable"><code>hash</code></em> to
    base-32.</p></dd></dl></div></div><div class="refsection" title="Examples"><a name="id487131"></a><h2>Examples</h2><p>Computing hashes:

</p><pre class="screen">
$ mkdir test
$ echo "hello" &gt; test/world

$ nix-hash test/ <em class="lineannotation"><span class="lineannotation">(MD5 hash; default)</span></em>
8179d3caeff1869b5ba1744e5a245c04

$ nix-store --dump test/ | md5sum <em class="lineannotation"><span class="lineannotation">(for comparison)</span></em>
8179d3caeff1869b5ba1744e5a245c04  -

$ nix-hash --type sha1 test/
e4fd8ba5f7bbeaea5ace89fe10255536cd60dab6

$ nix-hash --type sha1 --base32 test/
nvd61k9nalji1zl9rrdfmsmvyyjqpzg4

$ nix-hash --type sha256 --flat test/
error: reading file `test/': Is a directory

$ nix-hash --type sha256 --flat test/world
5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03</pre><p>

</p><p>Converting between hexadecimal and base-32:

</p><pre class="screen">
$ nix-hash --type sha1 --to-base32 e4fd8ba5f7bbeaea5ace89fe10255536cd60dab6
nvd61k9nalji1zl9rrdfmsmvyyjqpzg4

$ nix-hash --type sha1 --to-base16 nvd61k9nalji1zl9rrdfmsmvyyjqpzg4
e4fd8ba5f7bbeaea5ace89fe10255536cd60dab6</pre><p>

</p></div></div><div class="refentry" title="nix-install-package"><div class="refentry.separator"><hr></div><a name="sec-nix-install-package"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-install-package &#8212; install a Nix Package file</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-install-package</code>  [<code class="option">--non-interactive</code>] [
      { <code class="option">--profile</code>  |   <code class="option">-p</code> }
      <em class="replaceable"><code>path</code></em>
    ]<br> {{
        <code class="option">--url</code>
          <em class="replaceable"><code>url</code></em> 
      } |  {
         <em class="replaceable"><code>file</code></em> 
      }}</p></div></div><div class="refsection" title="Description"><a name="id496922"></a><h2>Description</h2><p>The command <span class="command"><strong>nix-install-package</strong></span> interactively
installs a Nix Package file (<code class="filename">*.nixpkg</code>), which is
a small file that contains a store path to be installed along with the
URL of a <a class="link" href="#sec-nix-push" title="nix-push"><span class="command"><strong>nix-push</strong></span>
manifest</a>.  The Nix Package file is either
<em class="replaceable"><code>file</code></em>, or automatically downloaded from
<em class="replaceable"><code>url</code></em> if the <code class="option">--url</code> switch is
used.</p><p><span class="command"><strong>nix-install-package</strong></span> is used in <a class="link" href="#sec-one-click" title="4.5. One-click installs">one-click installs</a> to download and
install pre-built binary packages with all necessary dependencies.
<span class="command"><strong>nix-install-package</strong></span> is intended to be associated
with the MIME type <code class="literal">application/nix-package</code> in a web
browser so that it is invoked automatically when you click on
<code class="filename">*.nixpkg</code> files.  When invoked, it restarts itself
in a terminal window (since otherwise it would be invisible when run
from a browser), asks the user to confirm whether to install the
package, and if so downloads and installs the package into the user&#8217;s
current profile.</p><p>To obtain a window, <span class="command"><strong>nix-install-package</strong></span> tries
to restart itself with <span class="command"><strong>xterm</strong></span>,
<span class="command"><strong>konsole</strong></span> and
<span class="command"><strong>gnome-terminal</strong></span>.</p></div><div class="refsection" title="Options"><a name="id489338"></a><h2>Options</h2><div class="variablelist"><dl><dt><span class="term"><code class="option">--non-interactive</code></span></dt><dd><p>Do not open a new terminal window and do not ask
    for confirmation.</p></dd><dt><span class="term"><code class="option">--profile</code>, </span><span class="term"><code class="option">-p</code></span></dt><dd><p>Install the package into the specified profile
    rather than the user&#8217;s current profile.</p></dd></dl></div></div><div class="refsection" title="Examples"><a name="id489377"></a><h2>Examples</h2><p>To install <code class="filename">subversion-1.4.0.nixpkg</code> into the
user&#8217;s current profile, without any prompting:

</p><pre class="screen">
$ nix-install-package --non-interactive subversion-1.4.0.nixpkg</pre><p>

</p><p>To install the same package from some URL into a different
profile:

</p><pre class="screen">
$ nix-install-package --non-interactive -p /nix/var/nix/profiles/eelco \
    --url http://nix.cs.uu.nl/dist/nix/nixpkgs-0.10pre6622/pkgs/subversion-1.4.0-i686-linux.nixpkg</pre><p>

</p></div><div class="refsection" title="Format of nixpkg files"><a name="id489404"></a><h2>Format of <code class="literal">nixpkg</code> files</h2><p>A Nix Package file consists of a single line with the following
format:

</p><pre class="screen">
NIXPKG1 <em class="replaceable"><code>manifestURL</code></em> <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>system</code></em> <em class="replaceable"><code>drvPath</code></em> <em class="replaceable"><code>outPath</code></em></pre><p>

The elemens are as follows:

</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">NIXPKG1</code></span></dt><dd><p>The version of the Nix Package
    file.</p></dd><dt><span class="term"><em class="replaceable"><code>manifestURL</code></em></span></dt><dd><p>The manifest to be pulled by
    <span class="command"><strong>nix-pull</strong></span>.  The manifest must contain
    <em class="replaceable"><code>outPath</code></em>.</p></dd><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>The symbolic name and version of the
    package.</p></dd><dt><span class="term"><em class="replaceable"><code>system</code></em></span></dt><dd><p>The platform identifier of the platform for which
    this binary package is intended.</p></dd><dt><span class="term"><em class="replaceable"><code>drvPath</code></em></span></dt><dd><p>The path in the Nix store of the derivation from
    which <em class="replaceable"><code>outPath</code></em> was built.  Not currently
    used.</p></dd><dt><span class="term"><em class="replaceable"><code>outPath</code></em></span></dt><dd><p>The path in the Nix store of the package.  After
    <span class="command"><strong>nix-install-package</strong></span> has obtained the manifest
    from <em class="replaceable"><code>manifestURL</code></em>, it performs a
    <code class="literal">nix-env -i</code> <em class="replaceable"><code>outPath</code></em>
    to install the binary package.</p></dd></dl></div><p>
  
</p><p>An example follows:

</p><pre class="screen">
NIXPKG1 http://.../nixpkgs-0.10pre6622/MANIFEST subversion-1.4.0 i686-darwin \
  /nix/store/4kh60jkp...-subversion-1.4.0.drv \
  /nix/store/nkw7wpgb...-subversion-1.4.0</pre><p>

(The line breaks (<code class="literal">\</code>) are for presentation purposes
and not part of the actual file.)

</p></div></div><div class="refentry" title="nix-prefetch-url"><div class="refentry.separator"><hr></div><a name="sec-nix-prefetch-url"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-prefetch-url &#8212; copy a file from a URL into the store and print its MD5 hash</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-prefetch-url</code>   <em class="replaceable"><code>url</code></em>  [<em class="replaceable"><code>hash</code></em>]</p></div></div><div class="refsection" title="Description"><a name="id486228"></a><h2>Description</h2><p>The command <span class="command"><strong>nix-prefetch-url</strong></span> downloads the
file referenced by the URL <em class="replaceable"><code>url</code></em>, prints its
cryptographic hash, and copies it into the Nix store.  The file name
in the store is
<code class="filename"><em class="replaceable"><code>hash</code></em>-<em class="replaceable"><code>baseName</code></em></code>,
where <em class="replaceable"><code>baseName</code></em> is everything following the
final slash in <em class="replaceable"><code>url</code></em>.</p><p>This command is just a convenience for Nix expression writers.
Often a Nix expression fetches some source distribution from the
network using the <code class="literal">fetchurl</code> expression contained in
Nixpkgs.  However, <code class="literal">fetchurl</code> requires a
cryptographic hash.  If you don't know the hash, you would have to
download the file first, and then <code class="literal">fetchurl</code> would
download it again when you build your Nix expression.  Since
<code class="literal">fetchurl</code> uses the same name for the downloaded file
as <span class="command"><strong>nix-prefetch-url</strong></span>, the redundant download can be
avoided.</p><p>The environment variable <code class="envar">NIX_HASH_ALGO</code> specifies
which hash algorithm to use.  It can be either <code class="literal">md5</code>,
<code class="literal">sha1</code>, or <code class="literal">sha256</code>.  The default is
<code class="literal">sha256</code>.</p><p>If <em class="replaceable"><code>hash</code></em> is specified, then a download
is not performed if the Nix store already contains a file with the
same hash and base name.  Otherwise, the file is downloaded, and an
error if signaled if the actual hash of the file does not match the
specified hash.</p><p>This command prints the hash on standard output.  Additionally,
if the environment variable <code class="envar">PRINT_PATH</code> is set, the path
of the downloaded file in the Nix store is also printed.</p></div><div class="refsection" title="Examples"><a name="id486471"></a><h2>Examples</h2><pre class="screen">
$ nix-prefetch-url ftp://ftp.nluug.nl/pub/gnu/make/make-3.80.tar.bz2
0bbd1df101bc0294d440471e50feca71

$ PRINT_PATH=1 nix-prefetch-url ftp://ftp.nluug.nl/pub/gnu/make/make-3.80.tar.bz2
0bbd1df101bc0294d440471e50feca71
/nix/store/wvyz8ifdn7wyz1p3pqyn0ra45ka2l492-make-3.80.tar.bz2</pre></div></div><div class="refentry" title="nix-pull"><div class="refentry.separator"><hr></div><a name="sec-nix-pull"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-pull &#8212; pull substitutes from a network cache</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-pull</code>   <em class="replaceable"><code>url</code></em> </p></div></div><div class="refsection" title="Description"><a name="id490322"></a><h2>Description</h2><p>The command <span class="command"><strong>nix-pull</strong></span> obtains a list of
pre-built store paths from the URL <em class="replaceable"><code>url</code></em>, and
for each of these store paths, registers a substitute derivation that
downloads and unpacks it into the Nix store.  This is used to speed up
installations: if you attempt to install something that has already
been built and stored into the network cache, Nix can transparently
re-use the pre-built store paths.</p><p>The file at <em class="replaceable"><code>url</code></em> must be compatible
with the files created by <em class="replaceable"><code>nix-push</code></em>.</p></div><div class="refsection" title="Examples"><a name="id499071"></a><h2>Examples</h2><pre class="screen">
$ nix-pull http://nix.cs.uu.nl/dist/nix/nixpkgs-0.5pre753/MANIFEST</pre></div></div><div class="refentry" title="nix-push"><div class="refentry.separator"><hr></div><a name="sec-nix-push"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-push &#8212; push store paths onto a network cache</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-push</code>  {{
         <em class="replaceable"><code>archivesPutURL</code></em> 
          <em class="replaceable"><code>archivesGetURL</code></em> 
          <em class="replaceable"><code>manifestPutURL</code></em> 
      } |  {
         <code class="option">--copy</code> 
          <em class="replaceable"><code>archivesDir</code></em> 
          <em class="replaceable"><code>manifestFile</code></em> 
      }}  <em class="replaceable"><code>paths</code></em>... </p></div></div><div class="refsection" title="Description"><a name="id499328"></a><h2>Description</h2><p>The command <span class="command"><strong>nix-push</strong></span> builds a set of store
paths (if necessary), and then packages and uploads all store paths in
the resulting closures to a server.  A network cache thus populated
can subsequently be used to speed up software deployment on other
machines using the <span class="command"><strong>nix-pull</strong></span> command.</p><p><span class="command"><strong>nix-push</strong></span> performs the following actions.
      
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Each path in <em class="replaceable"><code>paths</code></em> is
  realised (using <a class="link" href="#rsec-nix-store-realise" title="Operation --realise"><code class="literal">nix-store
  --realise</code></a>).</p></li><li class="listitem"><p>All paths in the closure of the store expressions
  stored in <em class="replaceable"><code>paths</code></em> are determined (using
  <code class="literal">nix-store --query --requisites
  --include-outputs</code>).  It should be noted that since the
  <code class="option">--include-outputs</code> flag is used, you get a combined
  source/binary distribution.</p></li><li class="listitem"><p>All store paths determined in the previous step are
  packaged and compressed into a <span class="command"><strong>bzip</strong></span>ped NAR
  archive (extension <code class="filename">.nar.bz2</code>).</p></li><li class="listitem"><p>A <span class="emphasis"><em>manifest</em></span> is created that
  contains information on the store paths, their eventual URLs in the
  cache, and cryptographic hashes of the contents of the NAR
  archives.</p></li><li class="listitem"><p>Each store path is uploaded to the remote directory
  specified by <em class="replaceable"><code>archivesPutURL</code></em>.  HTTP PUT
  requests are used to do this.  However, before a file
  <code class="varname">x</code> is uploaded to
  <code class="literal"><em class="replaceable"><code>archivesPutURL</code></em>/</code><code class="varname">x</code>,
  <span class="command"><strong>nix-push</strong></span> first determines whether this upload is
  unnecessary by issuing a HTTP HEAD request on
  <code class="literal"><em class="replaceable"><code>archivesGetURL</code></em>/</code><code class="varname">x</code>.
  This allows a cache to be shared between many partially overlapping
  <span class="command"><strong>nix-push</strong></span> invocations.  (We use two URLs because
  the upload URL typically refers to a CGI script, while the download
  URL just refers to a file system directory on the
  server.)</p></li><li class="listitem"><p>The manifest is uploaded using an HTTP PUT request
  to <em class="replaceable"><code>manifestPutURL</code></em>.  The corresponding
  URL to download the manifest can then be used by
  <span class="command"><strong>nix-pull</strong></span>.</p></li></ol></div><p>

</p></div><div class="refsection" title="Examples"><a name="id499465"></a><h2>Examples</h2><p>To upload files there typically is some CGI script on the server
side.  This script should be be protected with a password.  The
following example uploads the store paths resulting from building the
Nix expressions in <code class="filename">foo.nix</code>, passing appropriate
authentication information:
    
</p><pre class="screen">
$ nix-push \
    http://foo@bar:server.domain/cgi-bin/upload.pl/cache \
    http://server.domain/cache \
    http://foo@bar:server.domain/cgi-bin/upload.pl/MANIFEST \
    $(nix-instantiate foo.nix)</pre><p>

This will push both sources and binaries (and any build-time
dependencies used in the build, such as compilers).</p><p>If we just want to push binaries, not sources and build-time
dependencies, we can do:
      
</p><pre class="screen">
$ nix-push <em class="replaceable"><code>urls</code></em> $(nix-store -r $(nix-instantiate foo.nix))</pre><p>
    
</p></div></div><div class="refentry" title="nix-worker"><div class="refentry.separator"><hr></div><a name="sec-nix-worker"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>nix-worker &#8212; Nix multi-user support daemon</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">nix-worker</code>   <code class="option">--daemon</code> </p></div></div><div class="refsection" title="Description"><a name="id499772"></a><h2>Description</h2><p>The Nix daemon is necessary in multi-user Nix installations.  It
performs build actions and other operations on the Nix store on behalf
of unprivileged users.</p></div></div></div></div><div class="appendix" title="Appendix B. Troubleshooting"><div class="titlepage"><div><div><h2 class="title"><a name="id480632"></a>Appendix B. Troubleshooting</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id499788">B.1. Collisions in <span class="command"><strong>nix-env</strong></span></a></span></dt><dt><span class="section"><a href="#id499847">B.2. <span class="quote">&#8220;<span class="quote">Too many links</span>&#8221;</span> error in the Nix
store</a></span></dt></dl></div><p>This section provides solutions for some common problems.  See
the <a class="link" href="http://bugs.strategoxt.org/browse/NIX" target="_top">Nix
bug tracker</a> for a list of currently known issues.</p><div class="section" title="B.1. Collisions in nix-env"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id499788"></a>B.1. Collisions in <span class="command"><strong>nix-env</strong></span></h2></div></div></div><p>Symptom: when installing or upgrading, you get an error message such as

</p><pre class="screen">
$ nix-env -i docbook-xml
...
adding /nix/store/s5hyxgm62gk2...-docbook-xml-4.2
collission between `/nix/store/s5hyxgm62gk2...-docbook-xml-4.2/xml/dtd/docbook/calstblx.dtd'
  and `/nix/store/06h377hr4b33...-docbook-xml-4.3/xml/dtd/docbook/calstblx.dtd'
  at /nix/store/...-builder.pl line 62.</pre><p>

</p><p>The cause is that two installed packages in the user environment
have overlapping filenames (e.g.,
<code class="filename">xml/dtd/docbook/calstblx.dtd</code>.  This usually
happens when you accidentally try to install two versions of the same
package.  For instance, in the example above, the Nix Packages
collection contains two versions of <code class="literal">docbook-xml</code>, so
<span class="command"><strong>nix-env -i</strong></span> will try to install both.  The default
user environment builder has no way to way to resolve such conflicts,
so it just gives up.</p><p>Solution: remove one of the offending packages from the user
environment (if already installed) using <span class="command"><strong>nix-env
-e</strong></span>, or specify exactly which version should be installed
(e.g., <code class="literal">nix-env -i docbook-xml-4.2</code>).</p><p>Alternatively, you can modify the user environment builder
script (in
<code class="filename"><em class="replaceable"><code>prefix</code></em>/share/nix/corepkgs/buildenv/builder.pl</code>)
to implement some conflict resolution policy.  E.g., the script could
be modified to rename conflicting file names, or to pick one over the
other.</p></div><div class="section" title="B.2. &#8220;Too many links&#8221; error in the Nix store"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id499847"></a>B.2. <span class="quote">&#8220;<span class="quote">Too many links</span>&#8221;</span> error in the Nix
store</h2></div></div></div><p>Symptom: when building something, you get an error message such as

</p><pre class="screen">
...
<code class="literal">mkdir: cannot create directory `/nix/store/<em class="replaceable"><code>name</code></em>': Too many links</code></pre><p>

</p><p>This is usually because you have more than 32,000 subdirectories
in <code class="filename">/nix/store</code>, as can be seen using <span class="command"><strong>ls
-l</strong></span>:

</p><pre class="screen">
$ ls -l /nix/store
drwxrwxrwt 32000 nix nix 4620288 Sep 8 15:08 store</pre><p>

The <code class="literal">ext2</code> file system is limited to a inode link
count of 32,000 (each subdirectory increasing the count by one).
Furthermore, the <code class="literal">st_nlink</code> field of the
<code class="function">stat</code> system call is a 16-bit value.</p><p>This only happens on very large Nix installations (such as build
machines).</p><p>Quick solution: run the garbage collector.  You may want to use
the <code class="option">--max-links</code> option.</p><p>Real solution: put the Nix store on a file system that supports
more than 32,000 subdirectories per directory, such as ReiserFS.
(This doesn&#8217;t solve the <code class="literal">st_nlink</code> limit, but
ReiserFS lies to the kernel by reporting a link count of 1 if it
exceeds the limit.)</p></div></div><div class="appendix" title="Appendix C. Glossary"><div class="titlepage"><div><div><h2 class="title"><a name="id490343"></a>Appendix C. Glossary</h2></div></div></div><div class="glosslist"><dl><dt><a name="gloss-derivation"></a>derivation</dt><dd><p>A description of a build action.  The result of a
  derivation is a store object.  Derivations are typically specified
  in Nix expressions using the <a class="link" href="#ssec-derivation" title="5.2.4. Derivations"><code class="function">derivation</code>
  primitive</a>.  These are translated into low-level
  <span class="emphasis"><em>store derivations</em></span> (implicitly by
  <span class="command"><strong>nix-env</strong></span> and <span class="command"><strong>nix-build</strong></span>, or
  explicitly by <span class="command"><strong>nix-instantiate</strong></span>).</p></dd><dt>store</dt><dd><p>The location in the file system where store objects
  live.  Typically <code class="filename">/nix/store</code>.</p></dd><dt>store path</dt><dd><p>The location in the file system of a store object,
  i.e., an immediate child of the Nix store
  directory.</p></dd><dt>store object</dt><dd><p>A file that is an immediate child of the Nix store
  directory.  These can be regular files, but also entire directory
  trees.  Store objects can be sources (objects copied from outside of
  the store), derivation outputs (objects produced by running a build
  action), or derivations (files describing a build
  action).</p></dd><dt><a name="gloss-substitute"></a>substitute</dt><dd><p>A substitute is a command invocation stored in the
  Nix database that describes how to build a store object, bypassing
  normal the build mechanism (i.e., derivations).  Typically, the
  substitute builds the store object by downloading a pre-built
  version of the store object from some server.</p></dd><dt>purity</dt><dd><p>The assumption that equal Nix derivations when run
  always produce the same output.  This cannot be guaranteed in
  general (e.g., a builder can rely on external inputs such as the
  network or the system time) but the Nix model assumes
  it.</p></dd><dt>Nix expression</dt><dd><p>A high-level description of software packages and
  compositions thereof.  Deploying software using Nix entails writing
  Nix expressions for your packages.  Nix expressions are translated
  to derivations that are stored in the Nix store.  These derivations
  can then be built.</p></dd><dt><a name="gloss-reference"></a>reference</dt><dd><p>A store path <code class="varname">P</code> is said to have a
  reference to a store path <code class="varname">Q</code> if the store object
  at <code class="varname">P</code> contains the path <code class="varname">Q</code>
  somewhere.  This implies than an execution involving
  <code class="varname">P</code> potentially needs <code class="varname">Q</code> to be
  present.  The <span class="emphasis"><em>references</em></span> of a store path are
  the set of store paths to which it has a reference.</p></dd><dt><a name="gloss-closure"></a>closure</dt><dd><p>The closure of a store path is the set of store
  paths that are directly or indirectly &#8220;reachable&#8221; from that store
  path; that is, it&#8217;s the closure of the path under the <a class="link" href="#gloss-reference" title="reference">references</a> relation.  For instance,
  if the store object at path <code class="varname">P</code> contains a
  reference to path <code class="varname">Q</code>, then <code class="varname">Q</code> is
  in the closure of <code class="varname">P</code>.  For correct deployment it
  is necessary to deploy whole closures, since otherwise at runtime
  files could be missing.  The command <span class="command"><strong>nix-store
  -qR</strong></span> prints out closures of store paths.</p></dd><dt><a name="gloss-output-path"></a>output path</dt><dd><p>A store path produced by a derivation.</p></dd><dt><a name="gloss-deriver"></a>deriver</dt><dd><p>The deriver of an <a class="link" href="#gloss-output-path" title="output path">output path</a> is the store
  derivation that built it.</p></dd><dt><a name="gloss-validity"></a>validity</dt><dd><p>A store path is considered
  <span class="emphasis"><em>valid</em></span> if it exists in the file system, is
  listed in the Nix database as being valid, and if all paths in its
  closure are also valid.</p></dd><dt><a name="gloss-user-env"></a>user environment</dt><dd><p>An automatically generated store object that
  consists of a set of symlinks to &#8220;active&#8221; applications, i.e., other
  store paths.  These are generated automatically by <a class="link" href="#sec-nix-env" title="nix-env"><span class="command"><strong>nix-env</strong></span></a>.  See <a class="xref" href="#sec-profiles" title="4.2. Profiles">Section 4.2, &#8220;Profiles&#8221;</a>.</p></dd><dt><a name="gloss-profile"></a>profile</dt><dd><p>A symlink to the current <a class="link" href="#gloss-user-env" title="user environment">user environment</a> of a user, e.g.,
  <code class="filename">/nix/var/nix/profiles/default</code>.</p></dd></dl></div></div><div class="appendix" title="Appendix D. Nix Release Notes"><div class="titlepage"><div><div><h2 class="title"><a name="id481161"></a>Appendix D. Nix Release Notes</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#ssec-relnotes-0.16">D.1. Release 0.16 (August 17, 2010)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.15">D.2. Release 0.15 (March 17, 2010)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.14">D.3. Release 0.14 (February 4, 2010)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.13">D.4. Release 0.13 (November 5,
2009)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.12">D.5. Release 0.12 (November 20,
2008)</a></span></dt><dt><span class="section"><a href="#ssec-relnotes-0.11">D.6. Release 0.11 (December 31,
2007)</a></span></dt><dt><span class="section"><a href="#id504154">D.7. Release 0.10.1 (October 11, 2006)</a></span></dt><dt><span class="section"><a href="#id504169">D.8. Release 0.10 (October 6, 2006)</a></span></dt><dt><span class="section"><a href="#id504804">D.9. Release 0.9.2 (September 21, 2005)</a></span></dt><dt><span class="section"><a href="#id504844">D.10. Release 0.9.1 (September 20, 2005)</a></span></dt><dt><span class="section"><a href="#id504865">D.11. Release 0.9 (September 16, 2005)</a></span></dt><dt><span class="section"><a href="#id505019">D.12. Release 0.8.1 (April 13, 2005)</a></span></dt><dt><span class="section"><a href="#id505043">D.13. Release 0.8 (April 11, 2005)</a></span></dt><dt><span class="section"><a href="#id505427">D.14. Release 0.7 (January 12, 2005)</a></span></dt><dt><span class="section"><a href="#id505470">D.15. Release 0.6 (November 14, 2004)</a></span></dt><dt><span class="section"><a href="#id505679">D.16. Release 0.5 and earlier</a></span></dt></dl></div><div class="section" title="D.1. Release 0.16 (August 17, 2010)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ssec-relnotes-0.16"></a>D.1. Release 0.16 (August 17, 2010)</h2></div></div></div><p>This release has the following improvements:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The Nix expression evaluator is now much faster in most
    cases: typically, <a class="link" href="http://www.mail-archive.com/nix-dev@cs.uu.nl/msg04113.html" target="_top">3
    to 8 times compared to the old implementation</a>.  It also
    uses less memory.  It no longer depends on the ATerm
    library.</p></li><li class="listitem"><p>
      Support for configurable parallelism inside builders.  Build
      scripts have always had the ability to perform multiple build
      actions in parallel (for instance, by running <span class="command"><strong>make -j
      2</strong></span>), but this was not desirable because the number of
      actions to be performed in parallel was not configurable.  Nix
      now has an option <code class="option">--cores
      <em class="replaceable"><code>N</code></em></code> as well as a configuration
      setting <code class="varname">build-cores =
      <em class="replaceable"><code>N</code></em></code> that causes the
      environment variable <code class="envar">NIX_BUILD_CORES</code> to be set to
      <em class="replaceable"><code>N</code></em> when the builder is invoked.  The
      builder can use this at its discretion to perform a parallel
      build, e.g., by calling <span class="command"><strong>make -j
      <em class="replaceable"><code>N</code></em></strong></span>.  In Nixpkgs, this can be
      enabled on a per-package basis by setting the derivation
      attribute <code class="varname">enableParallelBuilding</code> to
      <code class="literal">true</code>.
    </p></li><li class="listitem"><p><span class="command"><strong>nix-store -q</strong></span> now supports XML output
    through the <code class="option">--xml</code> flag.</p></li><li class="listitem"><p>Several bug fixes.</p></li></ul></div></div><div class="section" title="D.2. Release 0.15 (March 17, 2010)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ssec-relnotes-0.15"></a>D.2. Release 0.15 (March 17, 2010)</h2></div></div></div><p>This is a bug-fix release.  Among other things, it fixes
building on Mac OS X (Snow Leopard), and improves the contents of
<code class="filename">/etc/passwd</code> and <code class="filename">/etc/group</code>
in <code class="literal">chroot</code> builds.</p></div><div class="section" title="D.3. Release 0.14 (February 4, 2010)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ssec-relnotes-0.14"></a>D.3. Release 0.14 (February 4, 2010)</h2></div></div></div><p>This release has the following improvements:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The garbage collector now starts deleting garbage much
    faster than before.  It no longer determines liveness of all paths
    in the store, but does so on demand.</p></li><li class="listitem"><p>Added a new operation, <span class="command"><strong>nix-store --query
    --roots</strong></span>, that shows the garbage collector roots that
    directly or indirectly point to the given store paths.</p></li><li class="listitem"><p>Removed support for converting Berkeley DB-based Nix
    databases to the new schema.</p></li><li class="listitem"><p>Removed the <code class="option">--use-atime</code> and
    <code class="option">--max-atime</code> garbage collector options.  They were
    not very useful in practice.</p></li><li class="listitem"><p>On Windows, Nix now requires Cygwin 1.7.x.</p></li><li class="listitem"><p>A few bug fixes.</p></li></ul></div></div><div class="section" title="D.4. Release 0.13 (November 5, 2009)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ssec-relnotes-0.13"></a>D.4. Release 0.13 (November 5,
2009)</h2></div></div></div><p>This is primarily a bug fix release.  It has some new
features:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Syntactic sugar for writing nested attribute sets.  Instead of

</p><pre class="programlisting">
{
  foo = {
    bar = 123;
    xyzzy = true;
  };
  a = { b = { c = "d"; }; };
}
</pre><p>

    you can write

</p><pre class="programlisting">
{
  foo.bar = 123;
  foo.xyzzy = true;
  a.b.c = "d";
}
</pre><p>

    This is useful, for instance, in NixOS configuration files.</p></li><li class="listitem"><p>Support for Nix channels generated by Hydra, the Nix-based
    continuous build system.  (Hydra generates NAR archives on the
    fly, so the size and hash of these archives isn&#8217;t known in
    advance.)</p></li><li class="listitem"><p>Support <code class="literal">i686-linux</code> builds directly on
    <code class="literal">x86_64-linux</code> Nix installations.  This is
    implemented using the <code class="function">personality()</code> syscall,
    which causes <span class="command"><strong>uname</strong></span> to return
    <code class="literal">i686</code> in child processes.</p></li><li class="listitem"><p>Various improvements to the <code class="literal">chroot</code>
    support.  Building in a <code class="literal">chroot</code> works quite well
    now.</p></li><li class="listitem"><p>Nix no longer blocks if it tries to build a path and another
    process is already building the same path.  Instead it tries to
    build another buildable path first.  This improves
    parallelism.</p></li><li class="listitem"><p>Support for large (&gt; 4 GiB) files in NAR archives.</p></li><li class="listitem"><p>Various (performance) improvements to the remote build
    mechanism.</p></li><li class="listitem"><p>New primops: <code class="varname">builtins.addErrorContext</code> (to
    add a string to stack traces &#8212; useful for debugging),
    <code class="varname">builtins.isBool</code>,
    <code class="varname">builtins.isString</code>,
    <code class="varname">builtins.isInt</code>,
    <code class="varname">builtins.intersectAttrs</code>.</p></li><li class="listitem"><p>OpenSolaris support (Sander van der Burg).</p></li><li class="listitem"><p>Stack traces are no longer displayed unless the
    <code class="option">--show-trace</code> option is used.</p></li><li class="listitem"><p>The scoping rules for <code class="literal">inherit
    (<em class="replaceable"><code>e</code></em>) ...</code> in recursive
    attribute sets have changed.  The expression
    <em class="replaceable"><code>e</code></em> can now refer to the attributes
    defined in the containing set.</p></li></ul></div></div><div class="section" title="D.5. Release 0.12 (November 20, 2008)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ssec-relnotes-0.12"></a>D.5. Release 0.12 (November 20,
2008)</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Nix no longer uses Berkeley DB to store Nix store metadata.
    The principal advantages of the new storage scheme are: it works
    properly over decent implementations of NFS (allowing Nix stores
    to be shared between multiple machines); no recovery is needed
    when a Nix process crashes; no write access is needed for
    read-only operations; no more running out of Berkeley DB locks on
    certain operations.</p><p>You still need to compile Nix with Berkeley DB support if
    you want Nix to automatically convert your old Nix store to the
    new schema.  If you don&#8217;t need this, you can build Nix with the
    <code class="filename">configure</code> option
    <code class="option">--disable-old-db-compat</code>.</p><p>After the automatic conversion to the new schema, you can
    delete the old Berkeley DB files:

    </p><pre class="screen">
$ cd /nix/var/nix/db
$ rm __db* log.* derivers references referrers reserved validpaths DB_CONFIG</pre><p>

    The new metadata is stored in the directories
    <code class="filename">/nix/var/nix/db/info</code> and
    <code class="filename">/nix/var/nix/db/referrer</code>.  Though the
    metadata is stored in human-readable plain-text files, they are
    not intended to be human-editable, as Nix is rather strict about
    the format.</p><p>The new storage schema may or may not require less disk
    space than the Berkeley DB environment, mostly depending on the
    cluster size of your file system.  With 1 KiB clusters (which
    seems to be the <code class="literal">ext3</code> default nowadays) it
    usually takes up much less space.</p></li><li class="listitem"><p>There is a new substituter that copies paths
  directly from other (remote) Nix stores mounted somewhere in the
  filesystem.  For instance, you can speed up an installation by
  mounting some remote Nix store that already has the packages in
  question via NFS or <code class="literal">sshfs</code>.  The environment
  variable <code class="envar">NIX_OTHER_STORES</code> specifies the locations of
  the remote Nix directories,
  e.g. <code class="literal">/mnt/remote-fs/nix</code>.</p></li><li class="listitem"><p>New <span class="command"><strong>nix-store</strong></span> operations
  <code class="option">--dump-db</code> and <code class="option">--load-db</code> to dump
  and reload the Nix database.</p></li><li class="listitem"><p>The garbage collector has a number of new options to
  allow only some of the garbage to be deleted.  The option
  <code class="option">--max-freed <em class="replaceable"><code>N</code></em></code> tells the
  collector to stop after at least <em class="replaceable"><code>N</code></em> bytes
  have been deleted.  The option <code class="option">--max-links
  <em class="replaceable"><code>N</code></em></code> tells it to stop after the
  link count on <code class="filename">/nix/store</code> has dropped below
  <em class="replaceable"><code>N</code></em>.  This is useful for very large Nix
  stores on filesystems with a 32000 subdirectories limit (like
  <code class="literal">ext3</code>).  The option <code class="option">--use-atime</code>
  causes store paths to be deleted in order of ascending last access
  time.  This allows non-recently used stuff to be deleted.  The
  option <code class="option">--max-atime <em class="replaceable"><code>time</code></em></code>
  specifies an upper limit to the last accessed time of paths that may
  be deleted.  For instance,

    </p><pre class="screen">
    $ nix-store --gc -v --max-atime $(date +%s -d "2 months ago")</pre><p>

  deletes everything that hasn&#8217;t been accessed in two months.</p></li><li class="listitem"><p><span class="command"><strong>nix-env</strong></span> now uses optimistic
  profile locking when performing an operation like installing or
  upgrading, instead of setting an exclusive lock on the profile.
  This allows multiple <span class="command"><strong>nix-env -i / -u / -e</strong></span>
  operations on the same profile in parallel.  If a
  <span class="command"><strong>nix-env</strong></span> operation sees at the end that the profile
  was changed in the meantime by another process, it will just
  restart.  This is generally cheap because the build results are
  still in the Nix store.</p></li><li class="listitem"><p>The option <code class="option">--dry-run</code> is now
  supported by <span class="command"><strong>nix-store -r</strong></span> and
  <span class="command"><strong>nix-build</strong></span>.</p></li><li class="listitem"><p>The information previously shown by
  <code class="option">--dry-run</code> (i.e., which derivations will be built
  and which paths will be substituted) is now always shown by
  <span class="command"><strong>nix-env</strong></span>, <span class="command"><strong>nix-store -r</strong></span> and
  <span class="command"><strong>nix-build</strong></span>.  The total download size of
  substitutable paths is now also shown.  For instance, a build will
  show something like

    </p><pre class="screen">
the following derivations will be built:
  /nix/store/129sbxnk5n466zg6r1qmq1xjv9zymyy7-activate-configuration.sh.drv
  /nix/store/7mzy971rdm8l566ch8hgxaf89x7lr7ik-upstart-jobs.drv
  ...
the following paths will be downloaded/copied (30.02 MiB):
  /nix/store/4m8pvgy2dcjgppf5b4cj5l6wyshjhalj-samba-3.2.4
  /nix/store/7h1kwcj29ip8vk26rhmx6bfjraxp0g4l-libunwind-0.98.6
  ...</pre><p>      
  
  </p></li><li class="listitem"><p>Language features:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>@-patterns as in Haskell.  For instance, in a
      function definition

      </p><pre class="programlisting">f = args @ {x, y, z}: <em class="replaceable"><code>...</code></em>;</pre><p>

      <code class="varname">args</code> refers to the argument as a whole, which
      is further pattern-matched against the attribute set pattern
      <code class="literal">{x, y, z}</code>.</p></li><li class="listitem"><p>&#8220;<code class="literal">...</code>&#8221; (ellipsis) patterns.
      An attribute set pattern can now say <code class="literal">...</code>  at
      the end of the attribute name list to specify that the function
      takes <span class="emphasis"><em>at least</em></span> the listed attributes, while
      ignoring additional attributes.  For instance,

      </p><pre class="programlisting">{stdenv, fetchurl, fuse, ...}: <em class="replaceable"><code>...</code></em></pre><p>

      defines a function that accepts any attribute set that includes
      at least the three listed attributes.</p></li><li class="listitem"><p>New primops:
      <code class="varname">builtins.parseDrvName</code> (split a package name
      string like <code class="literal">"nix-0.12pre12876"</code> into its name
      and version components, e.g. <code class="literal">"nix"</code> and
      <code class="literal">"0.12pre12876"</code>),
      <code class="varname">builtins.compareVersions</code> (compare two version
      strings using the same algorithm that <span class="command"><strong>nix-env</strong></span>
      uses), <code class="varname">builtins.length</code> (efficiently compute
      the length of a list), <code class="varname">builtins.mul</code> (integer
      multiplication), <code class="varname">builtins.div</code> (integer
      division).
      
      </p></li></ul></div><p>

  </p></li><li class="listitem"><p><span class="command"><strong>nix-prefetch-url</strong></span> now supports
  <code class="literal">mirror://</code> URLs, provided that the environment
  variable <code class="envar">NIXPKGS_ALL</code> points at a Nixpkgs
  tree.</p></li><li class="listitem"><p>Removed the commands
  <span class="command"><strong>nix-pack-closure</strong></span> and
  <span class="command"><strong>nix-unpack-closure</strong></span>.   You can do almost the same
  thing but much more efficiently by doing <code class="literal">nix-store --export
  $(nix-store -qR <em class="replaceable"><code>paths</code></em>) &gt; closure</code> and
  <code class="literal">nix-store --import &lt;
  closure</code>.</p></li><li class="listitem"><p>Lots of bug fixes, including a big performance bug in
  the handling of <code class="literal">with</code>-expressions.</p></li></ul></div></div><div class="section" title="D.6. Release 0.11 (December 31, 2007)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ssec-relnotes-0.11"></a>D.6. Release 0.11 (December 31,
2007)</h2></div></div></div><p>Nix 0.11 has many improvements over the previous stable release.
The most important improvement is secure multi-user support.  It also
features many usability enhancements and language extensions, many of
them prompted by NixOS, the purely functional Linux distribution based
on Nix.  Here is an (incomplete) list:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Secure multi-user support.  A single Nix store can
  now be shared between multiple (possible untrusted) users.  This is
  an important feature for NixOS, where it allows non-root users to
  install software.  The old setuid method for sharing a store between
  multiple users has been removed.  Details for setting up a
  multi-user store can be found in the manual.</p></li><li class="listitem"><p>The new command <span class="command"><strong>nix-copy-closure</strong></span>
  gives you an easy and efficient way to exchange software between
  machines.  It copies the missing parts of the closure of a set of
  store path to or from a remote machine via
  <span class="command"><strong>ssh</strong></span>.</p></li><li class="listitem"><p>A new kind of string literal: strings between double
  single-quotes (<code class="literal">''</code>) have indentation
  &#8220;intelligently&#8221; removed.  This allows large strings (such as shell
  scripts or configuration file fragments in NixOS) to cleanly follow
  the indentation of the surrounding expression.  It also requires
  much less escaping, since <code class="literal">''</code> is less common in
  most languages than <code class="literal">"</code>.</p></li><li class="listitem"><p><span class="command"><strong>nix-env</strong></span> <code class="option">--set</code>
  modifies the current generation of a profile so that it contains
  exactly the specified derivation, and nothing else.  For example,
  <code class="literal">nix-env -p /nix/var/nix/profiles/browser --set
  firefox</code> lets the profile named
  <code class="filename">browser</code> contain just Firefox.</p></li><li class="listitem"><p><span class="command"><strong>nix-env</strong></span> now maintains
  meta-information about installed packages in profiles.  The
  meta-information is the contents of the <code class="varname">meta</code>
  attribute of derivations, such as <code class="varname">description</code> or
  <code class="varname">homepage</code>.  The command <code class="literal">nix-env -q --xml
  --meta</code> shows all meta-information.</p></li><li class="listitem"><p><span class="command"><strong>nix-env</strong></span> now uses the
  <code class="varname">meta.priority</code> attribute of derivations to resolve
  filename collisions between packages.  Lower priority values denote
  a higher priority.  For instance, the GCC wrapper package and the
  Binutils package in Nixpkgs both have a file
  <code class="filename">bin/ld</code>, so previously if you tried to install
  both you would get a collision.  Now, on the other hand, the GCC
  wrapper declares a higher priority than Binutils, so the former&#8217;s
  <code class="filename">bin/ld</code> is symlinked in the user
  environment.</p></li><li class="listitem"><p><span class="command"><strong>nix-env -i / -u</strong></span>: instead of
  breaking package ties by version, break them by priority and version
  number.  That is, if there are multiple packages with the same name,
  then pick the package with the highest priority, and only use the
  version if there are multiple packages with the same
  priority.</p><p>This makes it possible to mark specific versions/variant in
  Nixpkgs more or less desirable than others.  A typical example would
  be a beta version of some package (e.g.,
  <code class="literal">gcc-4.2.0rc1</code>) which should not be installed even
  though it is the highest version, except when it is explicitly
  selected (e.g., <code class="literal">nix-env -i
  gcc-4.2.0rc1</code>).</p></li><li class="listitem"><p><span class="command"><strong>nix-env --set-flag</strong></span> allows meta
  attributes of installed packages to be modified.  There are several
  attributes that can be usefully modified, because they affect the
  behaviour of <span class="command"><strong>nix-env</strong></span> or the user environment
  build script:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><code class="varname">meta.priority</code> can be changed
      to resolve filename clashes (see above).</p></li><li class="listitem"><p><code class="varname">meta.keep</code> can be set to
      <code class="literal">true</code> to prevent the package from being
      upgraded or replaced.  Useful if you want to hang on to an older
      version of a package.</p></li><li class="listitem"><p><code class="varname">meta.active</code> can be set to
      <code class="literal">false</code> to &#8220;disable&#8221; the package.  That is, no
      symlinks will be generated to the files of the package, but it
      remains part of the profile (so it won&#8217;t be garbage-collected).
      Set it back to <code class="literal">true</code> to re-enable the
      package.</p></li></ul></div><p>

  </p></li><li class="listitem"><p><span class="command"><strong>nix-env -q</strong></span> now has a flag
  <code class="option">--prebuilt-only</code> (<code class="option">-b</code>) that causes
  <span class="command"><strong>nix-env</strong></span> to show only those derivations whose
  output is already in the Nix store or that can be substituted (i.e.,
  downloaded from somewhere).  In other words, it shows the packages
  that can be installed &#8220;quickly&#8221;, i.e., don&#8217;t need to be built from
  source.  The <code class="option">-b</code> flag is also available in
  <span class="command"><strong>nix-env -i</strong></span> and <span class="command"><strong>nix-env -u</strong></span> to
  filter out derivations for which no pre-built binary is
  available.</p></li><li class="listitem"><p>The new option <code class="option">--argstr</code> (in
  <span class="command"><strong>nix-env</strong></span>, <span class="command"><strong>nix-instantiate</strong></span> and
  <span class="command"><strong>nix-build</strong></span>) is like <code class="option">--arg</code>, except
  that the value is a string.  For example, <code class="literal">--argstr system
  i686-linux</code> is equivalent to <code class="literal">--arg system
  \"i686-linux\"</code> (note that <code class="option">--argstr</code>
  prevents annoying quoting around shell arguments).</p></li><li class="listitem"><p><span class="command"><strong>nix-store</strong></span> has a new operation
  <code class="option">--read-log</code> (<code class="option">-l</code>)
  <em class="parameter"><code>paths</code></em> that shows the build log of the given
  paths.</p></li><li class="listitem"><p>Nix now uses Berkeley DB 4.5.  The database is
  upgraded automatically, but you should be careful not to use old
  versions of Nix that still use Berkeley DB 4.4.</p></li><li class="listitem"><p>The option <code class="option">--max-silent-time</code>
  (corresponding to the configuration setting
  <code class="literal">build-max-silent-time</code>) allows you to set a
  timeout on builds &#8212; if a build produces no output on
  <code class="literal">stdout</code> or <code class="literal">stderr</code> for the given
  number of seconds, it is terminated.  This is useful for recovering
  automatically from builds that are stuck in an infinite
  loop.</p></li><li class="listitem"><p><span class="command"><strong>nix-channel</strong></span>: each subscribed
  channel is its own attribute in the top-level expression generated
  for the channel.  This allows disambiguation (e.g. <code class="literal">nix-env
  -i -A nixpkgs_unstable.firefox</code>).</p></li><li class="listitem"><p>The substitutes table has been removed from the
  database.  This makes operations such as <span class="command"><strong>nix-pull</strong></span>
  and <span class="command"><strong>nix-channel --update</strong></span> much, much
  faster.</p></li><li class="listitem"><p><span class="command"><strong>nix-pull</strong></span> now supports
  bzip2-compressed manifests.  This speeds up
  channels.</p></li><li class="listitem"><p><span class="command"><strong>nix-prefetch-url</strong></span> now has a
  limited form of caching.  This is used by
  <span class="command"><strong>nix-channel</strong></span> to prevent unnecessary downloads when
  the channel hasn&#8217;t changed.</p></li><li class="listitem"><p><span class="command"><strong>nix-prefetch-url</strong></span> now by default
  computes the SHA-256 hash of the file instead of the MD5 hash.  In
  calls to <code class="function">fetchurl</code> you should pass the
  <code class="literal">sha256</code> attribute instead of
  <code class="literal">md5</code>.  You can pass either a hexadecimal or a
  base-32 encoding of the hash.</p></li><li class="listitem"><p>Nix can now perform builds in an automatically
  generated &#8220;chroot&#8221;.  This prevents a builder from accessing stuff
  outside of the Nix store, and thus helps ensure purity.  This is an
  experimental feature.</p></li><li class="listitem"><p>The new command <span class="command"><strong>nix-store
  --optimise</strong></span> reduces Nix store disk space usage by finding
  identical files in the store and hard-linking them to each other.
  It typically reduces the size of the store by something like
  25-35%.</p></li><li class="listitem"><p><code class="filename">~/.nix-defexpr</code> can now be a
  directory, in which case the Nix expressions in that directory are
  combined into an attribute set, with the file names used as the
  names of the attributes.  The command <span class="command"><strong>nix-env
  --import</strong></span> (which set the
  <code class="filename">~/.nix-defexpr</code> symlink) is
  removed.</p></li><li class="listitem"><p>Derivations can specify the new special attribute
  <code class="varname">allowedReferences</code> to enforce that the references
  in the output of a derivation are a subset of a declared set of
  paths.  For example, if <code class="varname">allowedReferences</code> is an
  empty list, then the output must not have any references.  This is
  used in NixOS to check that generated files such as initial ramdisks
  for booting Linux don&#8217;t have any dependencies.</p></li><li class="listitem"><p>The new attribute
  <code class="varname">exportReferencesGraph</code> allows builders access to
  the references graph of their inputs.  This is used in NixOS for
  tasks such as generating ISO-9660 images that contain a Nix store
  populated with the closure of certain paths.</p></li><li class="listitem"><p>Fixed-output derivations (like
  <code class="function">fetchurl</code>) can define the attribute
  <code class="varname">impureEnvVars</code> to allow external environment
  variables to be passed to builders.  This is used in Nixpkgs to
  support proxy configuration, among other things.</p></li><li class="listitem"><p>Several new built-in functions:
  <code class="function">builtins.attrNames</code>,
  <code class="function">builtins.filterSource</code>,
  <code class="function">builtins.isAttrs</code>,
  <code class="function">builtins.isFunction</code>,
  <code class="function">builtins.listToAttrs</code>,
  <code class="function">builtins.stringLength</code>,
  <code class="function">builtins.sub</code>,
  <code class="function">builtins.substring</code>,
  <code class="function">throw</code>,
  <code class="function">builtins.trace</code>,
  <code class="function">builtins.readFile</code>.</p></li></ul></div></div><div class="section" title="D.7. Release 0.10.1 (October 11, 2006)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id504154"></a>D.7. Release 0.10.1 (October 11, 2006)</h2></div></div></div><p>This release fixes two somewhat obscure bugs that occur when
evaluating Nix expressions that are stored inside the Nix store
(<code class="literal">NIX-67</code>).  These do not affect most users.</p></div><div class="section" title="D.8. Release 0.10 (October 6, 2006)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id504169"></a>D.8. Release 0.10 (October 6, 2006)</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>This version of Nix uses Berkeley DB 4.4 instead of 4.3.
The database is upgraded automatically, but you should be careful not
to use old versions of Nix that still use Berkeley DB 4.3.  In
particular, if you use a Nix installed through Nix, you should run

</p><pre class="screen">
$ nix-store --clear-substitutes</pre><p>

first.</p></div><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Also, the database schema has changed slighted to fix a
performance issue (see below).  When you run any Nix 0.10 command for
the first time, the database will be upgraded automatically.  This is
irreversible.</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="command"><strong>nix-env</strong></span> usability improvements:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>An option <code class="option">--compare-versions</code>
      (or <code class="option">-c</code>) has been added to <span class="command"><strong>nix-env
      --query</strong></span> to allow you to compare installed versions of
      packages to available versions, or vice versa.  An easy way to
      see if you are up to date with what&#8217;s in your subscribed
      channels is <code class="literal">nix-env -qc \*</code>.</p></li><li class="listitem"><p><code class="literal">nix-env --query</code> now takes as
      arguments a list of package names about which to show
      information, just like <code class="option">--install</code>, etc.: for
      example, <code class="literal">nix-env -q gcc</code>.  Note that to show
      all derivations, you need to specify
      <code class="literal">\*</code>.</p></li><li class="listitem"><p><code class="literal">nix-env -i
      <em class="replaceable"><code>pkgname</code></em></code> will now install
      the highest available version of
      <em class="replaceable"><code>pkgname</code></em>, rather than installing all
      available versions (which would probably give collisions)
      (<code class="literal">NIX-31</code>).</p></li><li class="listitem"><p><code class="literal">nix-env (-i|-u) --dry-run</code> now
      shows exactly which missing paths will be built or
      substituted.</p></li><li class="listitem"><p><code class="literal">nix-env -qa --description</code>
      shows human-readable descriptions of packages, provided that
      they have a <code class="literal">meta.description</code> attribute (which
      most packages in Nixpkgs don&#8217;t have yet).</p></li></ul></div><p>
  
  </p></li><li class="listitem"><p>New language features:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Reference scanning (which happens after each
      build) is much faster and takes a constant amount of
      memory.</p></li><li class="listitem"><p>String interpolation.  Expressions like

</p><pre class="programlisting">
"--with-freetype2-library=" + freetype + "/lib"</pre><p>

      can now be written as

</p><pre class="programlisting">
"--with-freetype2-library=${freetype}/lib"</pre><p>

      You can write arbitrary expressions within
      <code class="literal">${<em class="replaceable"><code>...</code></em>}</code>, not just
      identifiers.</p></li><li class="listitem"><p>Multi-line string literals.</p></li><li class="listitem"><p>String concatenations can now involve
      derivations, as in the example <code class="code">"--with-freetype2-library="
      + freetype + "/lib"</code>.  This was not previously possible
      because we need to register that a derivation that uses such a
      string is dependent on <code class="literal">freetype</code>.  The
      evaluator now properly propagates this information.
      Consequently, the subpath operator (<code class="literal">~</code>) has
      been deprecated.</p></li><li class="listitem"><p>Default values of function arguments can now
      refer to other function arguments; that is, all arguments are in
      scope in the default values
      (<code class="literal">NIX-45</code>).</p></li><li class="listitem"><p>Lots of new built-in primitives, such as
      functions for list manipulation and integer arithmetic.  See the
      manual for a complete list.  All primops are now available in
      the set <code class="varname">builtins</code>, allowing one to test for
      the availability of primop in a backwards-compatible
      way.</p></li><li class="listitem"><p>Real let-expressions: <code class="literal">let x = ...;
      ... z = ...; in ...</code>.</p></li></ul></div><p>

  </p></li><li class="listitem"><p>New commands <span class="command"><strong>nix-pack-closure</strong></span> and
  <span class="command"><strong>nix-unpack-closure</strong></span> than can be used to easily
  transfer a store path with all its dependencies to another machine.
  Very convenient whenever you have some package on your machine and
  you want to copy it somewhere else.</p></li><li class="listitem"><p>XML support:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><code class="literal">nix-env -q --xml</code> prints the
      installed or available packages in an XML representation for
      easy processing by other tools.</p></li><li class="listitem"><p><code class="literal">nix-instantiate --eval-only
      --xml</code> prints an XML representation of the resulting
      term.  (The new flag <code class="option">--strict</code> forces &#8216;deep&#8217;
      evaluation of the result, i.e., list elements and attributes are
      evaluated recursively.)</p></li><li class="listitem"><p>In Nix expressions, the primop
      <code class="function">builtins.toXML</code> converts a term to an XML
      representation.  This is primarily useful for passing structured
      information to builders.</p></li></ul></div><p>

  </p></li><li class="listitem"><p>You can now unambigously specify which derivation to
  build or install in <span class="command"><strong>nix-env</strong></span>,
  <span class="command"><strong>nix-instantiate</strong></span> and <span class="command"><strong>nix-build</strong></span>
  using the <code class="option">--attr</code> / <code class="option">-A</code> flags, which
  takes an attribute name as argument.  (Unlike symbolic package names
  such as <code class="literal">subversion-1.4.0</code>, attribute names in an
  attribute set are unique.)  For instance, a quick way to perform a
  test build of a package in Nixpkgs is <code class="literal">nix-build
  pkgs/top-level/all-packages.nix -A
  <em class="replaceable"><code>foo</code></em></code>.  <code class="literal">nix-env -q
  --attr</code> shows the attribute names corresponding to each
  derivation.</p></li><li class="listitem"><p>If the top-level Nix expression used by
  <span class="command"><strong>nix-env</strong></span>, <span class="command"><strong>nix-instantiate</strong></span> or
  <span class="command"><strong>nix-build</strong></span> evaluates to a function whose arguments
  all have default values, the function will be called automatically.
  Also, the new command-line switch <code class="option">--arg
  <em class="replaceable"><code>name</code></em>
  <em class="replaceable"><code>value</code></em></code> can be used to specify
  function arguments on the command line.</p></li><li class="listitem"><p><code class="literal">nix-install-package --url
  <em class="replaceable"><code>URL</code></em></code> allows a package to be
  installed directly from the given URL.</p></li><li class="listitem"><p>Nix now works behind an HTTP proxy server; just set
  the standard environment variables <code class="envar">http_proxy</code>,
  <code class="envar">https_proxy</code>, <code class="envar">ftp_proxy</code> or
  <code class="envar">all_proxy</code> appropriately.  Functions such as
  <code class="function">fetchurl</code> in Nixpkgs also respect these
  variables.</p></li><li class="listitem"><p><code class="literal">nix-build -o
  <em class="replaceable"><code>symlink</code></em></code> allows the symlink to
  the build result to be named something other than
  <code class="literal">result</code>.</p></li><li class="listitem"><p>Platform support:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Support for 64-bit platforms, provided a <a class="link" href="http://bugzilla.sen.cwi.nl:8080/show_bug.cgi?id=606" target="_top">suitably
      patched ATerm library</a> is used.  Also, files larger than 2
      GiB are now supported.</p></li><li class="listitem"><p>Added support for Cygwin (Windows,
      <code class="literal">i686-cygwin</code>), Mac OS X on Intel
      (<code class="literal">i686-darwin</code>) and Linux on PowerPC
      (<code class="literal">powerpc-linux</code>).</p></li><li class="listitem"><p>Users of SMP and multicore machines will
      appreciate that the number of builds to be performed in parallel
      can now be specified in the configuration file in the
      <code class="literal">build-max-jobs</code> setting.</p></li></ul></div><p>

  </p></li><li class="listitem"><p>Garbage collector improvements:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Open files (such as running programs) are now
      used as roots of the garbage collector.  This prevents programs
      that have been uninstalled from being garbage collected while
      they are still running.  The script that detects these
      additional runtime roots
      (<code class="filename">find-runtime-roots.pl</code>) is inherently
      system-specific, but it should work on Linux and on all
      platforms that have the <span class="command"><strong>lsof</strong></span>
      utility.</p></li><li class="listitem"><p><code class="literal">nix-store --gc</code>
      (a.k.a. <span class="command"><strong>nix-collect-garbage</strong></span>) prints out the
      number of bytes freed on standard output.  <code class="literal">nix-store
      --gc --print-dead</code> shows how many bytes would be freed
      by an actual garbage collection.</p></li><li class="listitem"><p><code class="literal">nix-collect-garbage -d</code>
      removes all old generations of <span class="emphasis"><em>all</em></span> profiles
      before calling the actual garbage collector (<code class="literal">nix-store
      --gc</code>).  This is an easy way to get rid of all old
      packages in the Nix store.</p></li><li class="listitem"><p><span class="command"><strong>nix-store</strong></span> now has an
      operation <code class="option">--delete</code> to delete specific paths
      from the Nix store.  It won&#8217;t delete reachable (non-garbage)
      paths unless <code class="option">--ignore-liveness</code> is
      specified.</p></li></ul></div><p>

  </p></li><li class="listitem"><p>Berkeley DB 4.4&#8217;s process registry feature is used
  to recover from crashed Nix processes.</p></li><li class="listitem"><p>A performance issue has been fixed with the
  <code class="literal">referer</code> table, which stores the inverse of the
  <code class="literal">references</code> table (i.e., it tells you what store
  paths refer to a given path).  Maintaining this table could take a
  quadratic amount of time, as well as a quadratic amount of Berkeley
  DB log file space (in particular when running the garbage collector)
  (<code class="literal">NIX-23</code>).</p></li><li class="listitem"><p>Nix now catches the <code class="literal">TERM</code> and
  <code class="literal">HUP</code> signals in addition to the
  <code class="literal">INT</code> signal.  So you can now do a <code class="literal">killall
  nix-store</code> without triggering a database
  recovery.</p></li><li class="listitem"><p><span class="command"><strong>bsdiff</strong></span> updated to version
  4.3.</p></li><li class="listitem"><p>Substantial performance improvements in expression
  evaluation and <code class="literal">nix-env -qa</code>, all thanks to <a class="link" href="http://valgrind.org/" target="_top">Valgrind</a>.  Memory use has
  been reduced by a factor 8 or so.  Big speedup by memoisation of
  path hashing.</p></li><li class="listitem"><p>Lots of bug fixes, notably:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Make sure that the garbage collector can run
      succesfully when the disk is full
      (<code class="literal">NIX-18</code>).</p></li><li class="listitem"><p><span class="command"><strong>nix-env</strong></span> now locks the profile
      to prevent races between concurrent <span class="command"><strong>nix-env</strong></span>
      operations on the same profile
      (<code class="literal">NIX-7</code>).</p></li><li class="listitem"><p>Removed misleading messages from
      <code class="literal">nix-env -i</code> (e.g., <code class="literal">installing
      `foo'</code> followed by <code class="literal">uninstalling
      `foo'</code>) (<code class="literal">NIX-17</code>).</p></li></ul></div><p>

  </p></li><li class="listitem"><p>Nix source distributions are a lot smaller now since
  we no longer include a full copy of the Berkeley DB source
  distribution (but only the bits we need).</p></li><li class="listitem"><p>Header files are now installed so that external
  programs can use the Nix libraries.</p></li></ul></div></div><div class="section" title="D.9. Release 0.9.2 (September 21, 2005)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id504804"></a>D.9. Release 0.9.2 (September 21, 2005)</h2></div></div></div><p>This bug fix release fixes two problems on Mac OS X:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If Nix was linked against statically linked versions
  of the ATerm or Berkeley DB library, there would be dynamic link
  errors at runtime.</p></li><li class="listitem"><p><span class="command"><strong>nix-pull</strong></span> and
  <span class="command"><strong>nix-push</strong></span> intermittently failed due to race
  conditions involving pipes and child processes with error messages
  such as <code class="literal">open2: open(GLOB(0x180b2e4), &gt;&amp;=9) failed: Bad
  file descriptor at /nix/bin/nix-pull line 77</code> (issue
  <code class="literal">NIX-14</code>).</p></li></ul></div><p>

</p></div><div class="section" title="D.10. Release 0.9.1 (September 20, 2005)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id504844"></a>D.10. Release 0.9.1 (September 20, 2005)</h2></div></div></div><p>This bug fix release addresses a problem with the ATerm library
when the <code class="option">--with-aterm</code> flag in
<span class="command"><strong>configure</strong></span> was <span class="emphasis"><em>not</em></span> used.</p></div><div class="section" title="D.11. Release 0.9 (September 16, 2005)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id504865"></a>D.11. Release 0.9 (September 16, 2005)</h2></div></div></div><p>NOTE: this version of Nix uses Berkeley DB 4.3 instead of 4.2.
The database is upgraded automatically, but you should be careful not
to use old versions of Nix that still use Berkeley DB 4.2.  In
particular, if you use a Nix installed through Nix, you should run

</p><pre class="screen">
$ nix-store --clear-substitutes</pre><p>

first.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Unpacking of patch sequences is much faster now
  since we no longer do redundant unpacking and repacking of
  intermediate paths.</p></li><li class="listitem"><p>Nix now uses Berkeley DB 4.3.</p></li><li class="listitem"><p>The <code class="function">derivation</code> primitive is
  lazier.  Attributes of dependent derivations can mutually refer to
  each other (as long as there are no data dependencies on the
  <code class="varname">outPath</code> and <code class="varname">drvPath</code> attributes
  computed by <code class="function">derivation</code>).</p><p>For example, the expression <code class="literal">derivation
  attrs</code> now evaluates to (essentially)

  </p><pre class="programlisting">
attrs // {
  type = "derivation";
  outPath = derivation! attrs;
  drvPath = derivation! attrs;
}</pre><p>

  where <code class="function">derivation!</code> is a primop that does the
  actual derivation instantiation (i.e., it does what
  <code class="function">derivation</code> used to do).  The advantage is that
  it allows commands such as <span class="command"><strong>nix-env -qa</strong></span> and
  <span class="command"><strong>nix-env -i</strong></span> to be much faster since they no longer
  need to instantiate all derivations, just the
  <code class="varname">name</code> attribute.</p><p>Also, it allows derivations to cyclically reference each
  other, for example,

  </p><pre class="programlisting">
webServer = derivation {
  ...
  hostName = "svn.cs.uu.nl";
  services = [svnService];
};
 
svnService = derivation {
  ...
  hostName = webServer.hostName;
};</pre><p>

  Previously, this would yield a black hole (infinite recursion).</p></li><li class="listitem"><p><span class="command"><strong>nix-build</strong></span> now defaults to using
  <code class="filename">./default.nix</code> if no Nix expression is
  specified.</p></li><li class="listitem"><p><span class="command"><strong>nix-instantiate</strong></span>, when applied to
  a Nix expression that evaluates to a function, will call the
  function automatically if all its arguments have
  defaults.</p></li><li class="listitem"><p>Nix now uses libtool to build dynamic libraries.
  This reduces the size of executables.</p></li><li class="listitem"><p>A new list concatenation operator
  <code class="literal">++</code>.  For example, <code class="literal">[1 2 3] ++ [4 5
  6]</code> evaluates to <code class="literal">[1 2 3 4 5
  6]</code>.</p></li><li class="listitem"><p>Some currently undocumented primops to support
  low-level build management using Nix (i.e., using Nix as a Make
  replacement).  See the commit messages for <code class="literal">r3578</code>
  and <code class="literal">r3580</code>.</p></li><li class="listitem"><p>Various bug fixes and performance
  improvements.</p></li></ul></div></div><div class="section" title="D.12. Release 0.8.1 (April 13, 2005)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id505019"></a>D.12. Release 0.8.1 (April 13, 2005)</h2></div></div></div><p>This is a bug fix release.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Patch downloading was broken.</p></li><li class="listitem"><p>The garbage collector would not delete paths that
  had references from invalid (but substitutable)
  paths.</p></li></ul></div></div><div class="section" title="D.13. Release 0.8 (April 11, 2005)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id505043"></a>D.13. Release 0.8 (April 11, 2005)</h2></div></div></div><p>NOTE: the hashing scheme in Nix 0.8 changed (as detailed below).
As a result, <span class="command"><strong>nix-pull</strong></span> manifests and channels built
for Nix 0.7 and below will now work anymore.  However, the Nix
expression language has not changed, so you can still build from
source.  Also, existing user environments continue to work.  Nix 0.8
will automatically upgrade the database schema of previous
installations when it is first run.</p><p>If you get the error message

</p><pre class="screen">
you have an old-style manifest `/nix/var/nix/manifests/[...]'; please
delete it</pre><p>

you should delete previously downloaded manifests:

</p><pre class="screen">
$ rm /nix/var/nix/manifests/*</pre><p>

If <span class="command"><strong>nix-channel</strong></span> gives the error message

</p><pre class="screen">
manifest `http://catamaran.labs.cs.uu.nl/dist/nix/channels/[channel]/MANIFEST'
is too old (i.e., for Nix &lt;= 0.7)</pre><p>

then you should unsubscribe from the offending channel
(<span class="command"><strong>nix-channel --remove
<em class="replaceable"><code>URL</code></em></strong></span>; leave out
<code class="literal">/MANIFEST</code>), and subscribe to the same URL, with
<code class="literal">channels</code> replaced by <code class="literal">channels-v3</code>
(e.g., <a class="link" href="http://catamaran.labs.cs.uu.nl/dist/nix/channels-v3/nixpkgs-unstable" target="_top">http://catamaran.labs.cs.uu.nl/dist/nix/channels-v3/nixpkgs-unstable</a>).</p><p>Nix 0.8 has the following improvements:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The cryptographic hashes used in store paths are now
  160 bits long, but encoded in base-32 so that they are still only 32
  characters long (e.g.,
  <code class="filename">/nix/store/csw87wag8bqlqk7ipllbwypb14xainap-atk-1.9.0</code>).
  (This is actually a 160 bit truncation of a SHA-256
  hash.)</p></li><li class="listitem"><p>Big cleanups and simplifications of the basic store
  semantics.  The notion of &#8220;closure store expressions&#8221; is gone (and
  so is the notion of &#8220;successors&#8221;); the file system references of a
  store path are now just stored in the database.</p><p>For instance, given any store path, you can query its closure:

  </p><pre class="screen">
$ nix-store -qR $(which firefox)
... lots of paths ...</pre><p>

  Also, Nix now remembers for each store path the derivation that
  built it (the &#8220;deriver&#8221;):

  </p><pre class="screen">
$ nix-store -qR $(which firefox)
/nix/store/4b0jx7vq80l9aqcnkszxhymsf1ffa5jd-firefox-1.0.1.drv</pre><p>

  So to see the build-time dependencies, you can do

  </p><pre class="screen">
$ nix-store -qR $(nix-store -qd $(which firefox))</pre><p>

  or, in a nicer format:

  </p><pre class="screen">
$ nix-store -q --tree $(nix-store -qd $(which firefox))</pre><p>

  </p><p>File system references are also stored in reverse.  For
  instance, you can query all paths that directly or indirectly use a
  certain Glibc:

  </p><pre class="screen">
$ nix-store -q --referrers-closure \
    /nix/store/8lz9yc6zgmc0vlqmn2ipcpkjlmbi51vv-glibc-2.3.4</pre><p>

  </p></li><li class="listitem"><p>The concept of fixed-output derivations has been
  formalised.  Previously, functions such as
  <code class="function">fetchurl</code> in Nixpkgs used a hack (namely,
  explicitly specifying a store path hash) to prevent changes to, say,
  the URL of the file from propagating upwards through the dependency
  graph, causing rebuilds of everything.  This can now be done cleanly
  by specifying the <code class="varname">outputHash</code> and
  <code class="varname">outputHashAlgo</code> attributes.  Nix itself checks
  that the content of the output has the specified hash.  (This is
  important for maintaining certain invariants necessary for future
  work on secure shared stores.)</p></li><li class="listitem"><p>One-click installation :-) It is now possible to
  install any top-level component in Nixpkgs directly, through the web
  &#8212; see, e.g., <a class="link" href="http://catamaran.labs.cs.uu.nl/dist/nixpkgs-0.8/" target="_top">http://catamaran.labs.cs.uu.nl/dist/nixpkgs-0.8/</a>.
  All you have to do is associate
  <code class="filename">/nix/bin/nix-install-package</code> with the MIME type
  <code class="literal">application/nix-package</code> (or the extension
  <code class="filename">.nixpkg</code>), and clicking on a package link will
  cause it to be installed, with all appropriate dependencies.  If you
  just want to install some specific application, this is easier than
  subscribing to a channel.</p></li><li class="listitem"><p><span class="command"><strong>nix-store -r
  <em class="replaceable"><code>PATHS</code></em></strong></span> now builds all the
  derivations PATHS in parallel.  Previously it did them sequentially
  (though exploiting possible parallelism between subderivations).
  This is nice for build farms.</p></li><li class="listitem"><p><span class="command"><strong>nix-channel</strong></span> has new operations
  <code class="option">--list</code> and
  <code class="option">--remove</code>.</p></li><li class="listitem"><p>New ways of installing components into user
  environments:

  </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Copy from another user environment:

    </p><pre class="screen">
$ nix-env -i --from-profile .../other-profile firefox</pre><p>

    </p></li><li class="listitem"><p>Install a store derivation directly (bypassing the
    Nix expression language entirely):

    </p><pre class="screen">
$ nix-env -i /nix/store/z58v41v21xd3...-aterm-2.3.1.drv</pre><p>

    (This is used to implement <span class="command"><strong>nix-install-package</strong></span>,
    which is therefore immune to evolution in the Nix expression
    language.)</p></li><li class="listitem"><p>Install an already built store path directly:

    </p><pre class="screen">
$ nix-env -i /nix/store/hsyj5pbn0d9i...-aterm-2.3.1</pre><p>

    </p></li><li class="listitem"><p>Install the result of a Nix expression specified
    as a command-line argument:

    </p><pre class="screen">
$ nix-env -f .../i686-linux.nix -i -E 'x: x.firefoxWrapper'</pre><p>

    The difference with the normal installation mode is that
    <code class="option">-E</code> does not use the <code class="varname">name</code>
    attributes of derivations.  Therefore, this can be used to
    disambiguate multiple derivations with the same
    name.</p></li></ul></div></li><li class="listitem"><p>A hash of the contents of a store path is now stored
  in the database after a succesful build.  This allows you to check
  whether store paths have been tampered with: <span class="command"><strong>nix-store
  --verify --check-contents</strong></span>.</p></li><li class="listitem"><p>Implemented a concurrent garbage collector.  It is now
    always safe to run the garbage collector, even if other Nix
    operations are happening simultaneously.</p><p>However, there can still be GC races if you use
    <span class="command"><strong>nix-instantiate</strong></span> and <span class="command"><strong>nix-store
    --realise</strong></span> directly to build things.  To prevent races,
    use the <code class="option">--add-root</code> flag of those commands.</p></li><li class="listitem"><p>The garbage collector now finally deletes paths in
  the right order (i.e., topologically sorted under the &#8220;references&#8221;
  relation), thus making it safe to interrupt the collector without
  risking a store that violates the closure
  invariant.</p></li><li class="listitem"><p>Likewise, the substitute mechanism now downloads
  files in the right order, thus preserving the closure invariant at
  all times.</p></li><li class="listitem"><p>The result of <span class="command"><strong>nix-build</strong></span> is now
  registered as a root of the garbage collector.  If the
  <code class="filename">./result</code> link is deleted, the GC root
  disappears automatically.</p></li><li class="listitem"><p>The behaviour of the garbage collector can be changed
    globally by setting options in
    <code class="filename">/nix/etc/nix/nix.conf</code>.

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><code class="literal">gc-keep-derivations</code> specifies
      whether deriver links should be followed when searching for live
      paths.</p></li><li class="listitem"><p><code class="literal">gc-keep-outputs</code> specifies
      whether outputs of derivations should be followed when searching
      for live paths.</p></li><li class="listitem"><p><code class="literal">env-keep-derivations</code>
      specifies whether user environments should store the paths of
      derivations when they are added (thus keeping the derivations
      alive).</p></li></ul></div><p>

  </p></li><li class="listitem"><p>New <span class="command"><strong>nix-env</strong></span> query flags
  <code class="option">--drv-path</code> and
  <code class="option">--out-path</code>.</p></li><li class="listitem"><p><span class="command"><strong>fetchurl</strong></span> allows SHA-1 and SHA-256
  in addition to MD5.  Just specify the attribute
  <code class="varname">sha1</code> or <code class="varname">sha256</code> instead of
  <code class="varname">md5</code>.</p></li><li class="listitem"><p>Manual updates.</p></li></ul></div><p>

</p></div><div class="section" title="D.14. Release 0.7 (January 12, 2005)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id505427"></a>D.14. Release 0.7 (January 12, 2005)</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Binary patching.  When upgrading components using
  pre-built binaries (through nix-pull / nix-channel), Nix can
  automatically download and apply binary patches to already installed
  components instead of full downloads.  Patching is &#8220;smart&#8221;: if there
  is a <span class="emphasis"><em>sequence</em></span> of patches to an installed
  component, Nix will use it.  Patches are currently generated
  automatically between Nixpkgs (pre-)releases.</p></li><li class="listitem"><p>Simplifications to the substitute
  mechanism.</p></li><li class="listitem"><p>Nix-pull now stores downloaded manifests in
  <code class="filename">/nix/var/nix/manifests</code>.</p></li><li class="listitem"><p>Metadata on files in the Nix store is canonicalised
  after builds: the last-modified timestamp is set to 0 (00:00:00
  1/1/1970), the mode is set to 0444 or 0555 (readable and possibly
  executable by all; setuid/setgid bits are dropped), and the group is
  set to the default.  This ensures that the result of a build and an
  installation through a substitute is the same; and that timestamp
  dependencies are revealed.</p></li></ul></div></div><div class="section" title="D.15. Release 0.6 (November 14, 2004)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id505470"></a>D.15. Release 0.6 (November 14, 2004)</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Rewrite of the normalisation engine.

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Multiple builds can now be performed in parallel
      (option <code class="option">-j</code>).</p></li><li class="listitem"><p>Distributed builds.  Nix can now call a shell
      script to forward builds to Nix installations on remote
      machines, which may or may not be of the same platform
      type.</p></li><li class="listitem"><p>Option <code class="option">--fallback</code> allows
      recovery from broken substitutes.</p></li><li class="listitem"><p>Option <code class="option">--keep-going</code> causes
      building of other (unaffected) derivations to continue if one
      failed.</p></li></ul></div><p>

    </p></li><li class="listitem"><p>Improvements to the garbage collector (i.e., it
  should actually work now).</p></li><li class="listitem"><p>Setuid Nix installations allow a Nix store to be
  shared among multiple users.</p></li><li class="listitem"><p>Substitute registration is much faster
  now.</p></li><li class="listitem"><p>A utility <span class="command"><strong>nix-build</strong></span> to build a
  Nix expression and create a symlink to the result int the current
  directory; useful for testing Nix derivations.</p></li><li class="listitem"><p>Manual updates.</p></li><li class="listitem"><p><span class="command"><strong>nix-env</strong></span> changes:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Derivations for other platforms are filtered out
      (which can be overriden using
      <code class="option">--system-filter</code>).</p></li><li class="listitem"><p><code class="option">--install</code> by default now
      uninstall previous derivations with the same
      name.</p></li><li class="listitem"><p><code class="option">--upgrade</code> allows upgrading to a
      specific version.</p></li><li class="listitem"><p>New operation
      <code class="option">--delete-generations</code> to remove profile
      generations (necessary for effective garbage
      collection).</p></li><li class="listitem"><p>Nicer output (sorted,
      columnised).</p></li></ul></div><p>
    
    </p></li><li class="listitem"><p>More sensible verbosity levels all around (builder
  output is now shown always, unless <code class="option">-Q</code> is
  given).</p></li><li class="listitem"><p>Nix expression language changes:

    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>New language construct: <code class="literal">with
      <em class="replaceable"><code>E1</code></em>;
      <em class="replaceable"><code>E2</code></em></code> brings all attributes
      defined in the attribute set <em class="replaceable"><code>E1</code></em> in
      scope in <em class="replaceable"><code>E2</code></em>.</p></li><li class="listitem"><p>Added a <code class="function">map</code>
      function.</p></li><li class="listitem"><p>Various new operators (e.g., string
      concatenation).</p></li></ul></div><p>

    </p></li><li class="listitem"><p>Expression evaluation is much
  faster.</p></li><li class="listitem"><p>An Emacs mode for editing Nix expressions (with
  syntax highlighting and indentation) has been
  added.</p></li><li class="listitem"><p>Many bug fixes.</p></li></ul></div></div><div class="section" title="D.16. Release 0.5 and earlier"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id505679"></a>D.16. Release 0.5 and earlier</h2></div></div></div><p>Please refer to the Subversion commit log messages.</p></div></div></div></body></html>
